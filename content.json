{"meta":{"title":"linhongxun's blog","subtitle":"","description":"沉淀技术","author":"linhongxun","url":"https://hxlpub.github.io","root":"/"},"pages":[{"title":"书单","date":"2022-03-13T09:28:04.918Z","updated":"2022-03-13T09:28:04.918Z","comments":false,"path":"books/index.html","permalink":"https://hxlpub.github.io/books/index.html","excerpt":"","text":""},{"title":"关于","date":"2022-03-12T13:59:18.462Z","updated":"2022-03-12T13:59:18.462Z","comments":false,"path":"about/index.html","permalink":"https://hxlpub.github.io/about/index.html","excerpt":"","text":"个人详细介绍"},{"title":"分类","date":"2022-03-13T09:14:58.632Z","updated":"2022-03-12T13:59:18.462Z","comments":false,"path":"categories/index.html","permalink":"https://hxlpub.github.io/categories/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2022-03-13T09:14:18.985Z","updated":"2022-03-12T13:59:18.462Z","comments":false,"path":"repository/index.html","permalink":"https://hxlpub.github.io/repository/index.html","excerpt":"","text":""},{"title":"标签","date":"2022-03-13T09:25:23.619Z","updated":"2022-03-13T09:25:23.619Z","comments":false,"path":"tags/index.html","permalink":"https://hxlpub.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"git_problemsshooting","slug":"git-problemsshooting","date":"2022-05-10T14:19:51.000Z","updated":"2022-05-11T07:51:31.455Z","comments":true,"path":"2022/05/10/git-problemsshooting/","link":"","permalink":"https://hxlpub.github.io/2022/05/10/git-problemsshooting/","excerpt":"","text":"Failed to connect to github.com port 443:connection timed out解决方法： 1git config --global --unset http.proxy &amp;&amp; git config --global --unset https.proxy curl: (56) OpenSSL SSL_read: Connection reset by peer, errno 104解决方法： Running commands in /opt/daos/build/external/release/spdkRUN: git submodule initSubmodule ‘dpdk’ (https://github.com/spdk/dpdk.git) registered for path ‘dpdk’Submodule ‘intel-ipsec-mb’ (https://github.com/spdk/intel-ipsec-mb.git) registered for path ‘intel-ipsec-mb’Submodule ‘isa-l’ (https://github.com/spdk/isa-l.git) registered for path ‘isa-l’Submodule ‘libvfio-user’ (https://github.com/nutanix/libvfio-user.git) registered for path ‘libvfio-user’Submodule ‘ocf’ (https://github.com/Open-CAS/ocf.git) registered for path ‘ocf’RUN: git submodule updateCloning into ‘/opt/daos/build/external/release/spdk/dpdk’…fatal: unable to access ‘https://github.com/spdk/dpdk.git/&#39;: OpenSSL SSL_read: Connection reset by peer, errno 104fatal: clone of ‘https://github.com/spdk/dpdk.git&#39; into submodule path ‘/opt/daos/build/external/release/spdk/dpdk’ failedFailed to clone ‘dpdk’. Retry scheduledCloning into ‘/opt/daos/build/external/release/spdk/intel-ipsec-mb’…Cloning into ‘/opt/daos/build/external/release/spdk/isa-l’…Cloning into ‘/opt/daos/build/external/release/spdk/libvfio-user’…fatal: unable to access ‘https://github.com/nutanix/libvfio-user.git/&#39;: OpenSSL SSL_read: Connection reset by peer, errno 104fatal: clone of ‘https://github.com/nutanix/libvfio-user.git&#39; into submodule path ‘/opt/daos/build/external/release/spdk/libvfio-user’ failedFailed to clone ‘libvfio-user’. Retry scheduledCloning into ‘/opt/daos/build/external/release/spdk/ocf’…fatal: unable to access ‘https://github.com/Open-CAS/ocf.git/&#39;: Failed to connect to github.com port 443: Connection refusedfatal: clone of ‘https://github.com/Open-CAS/ocf.git&#39; into submodule path ‘/opt/daos/build/external/release/spdk/ocf’ failedFailed to clone ‘ocf’. Retry scheduledCloning into ‘/opt/daos/build/external/release/spdk/dpdk’…fatal: unable to access ‘https://github.com/spdk/dpdk.git/&#39;: Failed to connect to github.com port 443: Connection refusedfatal: clone of ‘https://github.com/spdk/dpdk.git&#39; into submodule path ‘/opt/daos/build/external/release/spdk/dpdk’ failedFailed to clone ‘dpdk’ a second time, abortingDownloadFailure: Failed to get /opt/daos/build/external/release/spdk from https://github.com/spdk/spdk.git:","categories":[{"name":"git","slug":"git","permalink":"https://hxlpub.github.io/categories/git/"}],"tags":[{"name":"版本管理","slug":"版本管理","permalink":"https://hxlpub.github.io/tags/%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86/"}]},{"title":"typora activate","slug":"typora-activate","date":"2022-04-30T11:15:26.000Z","updated":"2022-04-30T11:22:01.294Z","comments":true,"path":"2022/04/30/typora-activate/","link":"","permalink":"https://hxlpub.github.io/2022/04/30/typora-activate/","excerpt":"","text":"链接：https://pan.baidu.com/s/19QqJXAf9dTIYDe_kJ4P0fA提取码：nfl7","categories":[{"name":"开发工具","slug":"开发工具","permalink":"https://hxlpub.github.io/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"Typora","slug":"Typora","permalink":"https://hxlpub.github.io/tags/Typora/"}]},{"title":"day01_表、栈、队列","slug":"datastructures_tutorial","date":"2022-04-28T12:11:08.000Z","updated":"2022-05-03T03:36:19.975Z","comments":true,"path":"2022/04/28/datastructures_tutorial/","link":"","permalink":"https://hxlpub.github.io/2022/04/28/datastructures_tutorial/","excerpt":"","text":"参考 本文参考自《数据结构与算法分析C++描述》第三版，作者Mark Allen Weiss 1.表1)链表可以解决什么问题？其一般思想是？ 表的数组实现带来的问题 数组实现printList线性时间，findKth 常数时间，但插入和删除操作在整个表中发生时，时间开销最坏的情况是线性的O(N)，数组就不合适。 链表一般思想 为避免插入和删除带来的线性开销，允许表可以不连续存储，否则表的部分或全部都要整体移动。 下图表示了链表的一般性思想： 以及插入和删除方法的一般性思想： 当删除最后一项时，需要找到最后一项前面的项，才能去更新其next 链接到NULL，需要O(N),如果双向链表则只需要O(1) ​ 2.栈3.队列","categories":[{"name":"数据结构&算法分析","slug":"数据结构-算法分析","permalink":"https://hxlpub.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/"}],"tags":[{"name":"Structures&Algorithm","slug":"Structures-Algorithm","permalink":"https://hxlpub.github.io/tags/Structures-Algorithm/"}]},{"title":"一.搭建知识体系","slug":"c","date":"2022-04-23T10:12:50.000Z","updated":"2022-05-06T00:45:18.050Z","comments":true,"path":"2022/04/23/c/","link":"","permalink":"https://hxlpub.github.io/2022/04/23/c/","excerpt":"","text":"1.本篇目的：着重介绍C的几个重要特性一级底层原理 2.本篇的结构 第一部分：几个重要的特性与底层原理 第二部分：结合开源项目特性应用 第三部分：良好的编码风格（附录） 第一部分：几个重要的特性与底层原理 预处理器几个特性 #include指令：文件包含，该指令所在的行都将被替换为由文件名指定的文件的内容，一种将所有声明捆绑在一起的较好的办法，保证所有的源文件有相同的定义与变量声明 #include “文件” ：先在源文件所在位置查找该文件，如果在该位置未找到，再根据相应规则查找 #include &lt;文件&gt; ：根据相应规则查找 #define指令：宏替换，#define 名字 替换文本 宏：将函数定义为宏可避免调用函数时所需的运行时开销 变量 类型 作用域 存储位置 生命周期 特点 static 所在文件（static 外部变量）、 所在函数（static 局部变量） 定义后一直占据存储空间 只被初始化一次（程序执行前），初始化表达式是常量表达式，没有初始化表达式的元素被初始化为0 register 局部变量 、函数形参 寄存器 程序更小，执行速度更快 外部变量external 只被初始化一次（程序执行前），初始化表达式必须是常量表达式，没有初始化表达式的元素被初始化为0; 局部变量 函数内部 函数被调用期间 每次进入函数或程序块都初始化，没有初始化表达式的元素被初始化为0 指针 运算符&amp;：取地址，只能应用于内存中对象，即变量与数组元素，不能作用与表达式、常量、或register变量​ 运算符：间接寻址或间接引用运算符，作用于指针时，将访问指针所指向的对象。​ &amp;、优先级高于算术运算符​ 指针变量可以相互赋值，指向相同的对象 1）指针与数组 ： 一般，指针编写的程序比用数组下标编写的程序执行速度快​ 一个通过数组和下标实现的表达式可等价地通过指针和偏移量实现 char s[] == char *s 、&amp;a[2] == a+2 （a数组） 2）特性 某些情况下对指针进行比较运算（如指针p、q指向同一个数组的成员） 指针可以和整数相加或相减 指针的算术运算具有一致性：所有的指针运算都会自动考虑它所指向的对象的长度 有效的指针运算： 相同类型指针之间赋值运算 指针同整数之间的加法减法 指向相同数组中元素的两个指针间的减法和比较运算 指针赋值为0或指针与0之间的比较运算 3）指针数组、指针的指针 如char *lineptr[10] 初始化：如，static char *name[] = {“xiaoming”,”xiaoqiang”} 指针数组优点：数组的每一个元素的长度可以不同 4)函数指针 K&amp;R P99 运算符优先级 1）优先级1：数组下标[]，圆括号( )，成员选择（对象）.，成员选择（指针）-&gt; 结合方向为左到右 2）优先级2：负号运算符-，强制类型转换，自增运算符++，自减运算符–，取值运算符，取地址运算符&amp;，逻辑非运算符！，按位取反运算符~，长度运算sizeof符，结合方向为右到左 3）优先级3：除/，乘*，余数%，结合方向为左到右 4）优先级4：加+，减-，结合方向为左到右 5）优先级5：左移&lt;&lt;，右移&gt;&gt;，结合方向为左到右 6）优先级6：大于&gt;，大于等于&gt;=，小于&lt;，小于等于&lt;=，结合方向为左到右 7）优先级7：等于==，不等于!=，结合方向为左到右 8）优先级8：级别先后为，按位与&amp;，按位异或^，按位或| ，逻辑与&amp;&amp;，逻辑或|| 条件运算符?:，注意得是条件运算结合方向为右到左 9）优先级9：赋值运算符=，除后赋值/=，乘后赋值*=，取模后赋值%=，加后赋值+=，减后赋值-=，左移后赋值&lt;&lt;=，右移后赋值&gt;&gt;=，按位与后赋值&amp;=，按位异或后赋值^=，按位或后赋值|=，结合方向为右到左 结构 struct point { int x; int y; }; 声明：struct {int x,int y} x,y,z; #分配存储空间 struct point pt; 初始化： struct point maxpt = {320, 200}; 成员：maxpt.x maxpt.y 嵌套： struct rect { struct point pt1; struct point pt2; }; struct rect screen; 成员： screen.pt1.x 合法操作： 1.作为一个整体赋值和赋值 2.通过&amp;取地址 3.访问其成员 结构指针： struct point *ptrstr; ptrstr -&gt; x 结构数组 struct key {​ char *word;​ int count;} keytab[] = { 123 &#123; &quot;auto&quot;, 0 &#125;,&#123; &quot;break&quot;, 0 &#125;,&#123; &quot;case&quot;, 0 &#125; } 结构指针 关键字统计 自引用结构 K$R P116 ex:统计输入所有单词出现频次（二叉树） 表查找 类型定义（typedef） 联合 位字段 命令行参数 1234567891011121314#include &lt;stdio.h&gt;#include &lt;string.h&gt;int main(int argc, char *argv[] )&#123; #./test -x 注意优先级顺序 printf(&quot;%s\\n&quot;,argv[0]);#./test printf(&quot;%c\\n&quot;,(*++argv)[0]);#- argv指向argv[1] printf(&quot;%c\\n&quot;,*++argv[0]);#x,先与[]结合,所以依然指向argv[1] printf(&quot;%d\\n&quot;,argc);#2&#125;~ 运算符集合 控制流语句 标准库 输入输出：printf (“%d”,i)、scanf(“%d”,&amp;i) 文件访问： 1.打开文件，返回文件指针 123FILE *fp;FILE *fopen(char *name,char *mode) fp = fopen(name,mode) 12345672.文件读写int getc(FILE *fp)int putc(FILE *fp)#define getchar() getc(stdin) ​ #define putchar(c) putc((c), stdout) 1int fscanf(FILE *fp, char *format, ...) ​ int fprintf(FILE *fp, char *format, …) 12345678910111213141516171819202122233.关闭文件int fclose (FILE *fp)错误处理stderr 和exitfprintf(stderr, &quot;%s: can&#x27;t open %s\\n&quot;,prog, *argv);int ferror（FILE *fp）#若流fp中出错，则函数返回一个非0值int feof(FILE *fp) #如果指定的文件到达文件结尾，返回一个非0值行输入行输出char *fgets(char *line, int maxline, FILE *fp) #读文件一行到lineint fputs(char *line, FILE *fp)#写line到文件其他函数![字符和字符串操作函数](https://github.com/hxlpub/imgs/blob/master/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AD%97%E7%AC%A6%E7%B1%BB%E5%87%BD%E6%95%B0.png?raw=true&amp;ynotemdtimestamp=1650186921046) UNIX系统接口 系统调用：操作系统内的函数，实现标准库函数，不同的操作系统实现其标准库函数的方式和方法不同 read、write#输入输出 int n_read = read(int fd, char *buf, int n);int n_written = write(int fd, char *buf, int n); open、create#读写之前显式打开文件，open打开已存在文件，如果打开一个不存在文件报错，而create创建新文件或覆盖已有旧文件 #flags ：O_RDONLY、O_WRONLY、O_RDWR，perms：权限， int fd;int open(char *name, int flags, int perms);fd = open(name, flags, perms); int creat(char *name, int perms);fd = creat(name, perms); close、unlink# lseek#随机访问，不实际读写数据 long lseek(int fd, long offset, int origin); 第二部分：结合开源项目特性应用 第三部分：良好的编码风格（附录）正确缩进适当空格运算符两边各加一个空格字符","categories":[{"name":"c","slug":"c","permalink":"https://hxlpub.github.io/categories/c/"}],"tags":[{"name":"c","slug":"c","permalink":"https://hxlpub.github.io/tags/c/"}]},{"title":"一、daos RAS事件-rebuild","slug":"daos_2.0","date":"2022-04-17T07:57:07.000Z","updated":"2022-04-17T09:27:23.421Z","comments":true,"path":"2022/04/17/daos_2.0/","link":"","permalink":"https://hxlpub.github.io/2022/04/17/daos_2.0/","excerpt":"","text":"参考 https://docs.daos.io/v2.0/admin/administration/","categories":[{"name":"分布式-对象存储-daos","slug":"分布式-对象存储-daos","permalink":"https://hxlpub.github.io/categories/%E5%88%86%E5%B8%83%E5%BC%8F-%E5%AF%B9%E8%B1%A1%E5%AD%98%E5%82%A8-daos/"}],"tags":[{"name":"对象存储","slug":"对象存储","permalink":"https://hxlpub.github.io/tags/%E5%AF%B9%E8%B1%A1%E5%AD%98%E5%82%A8/"}]},{"title":"1000codes_数据结构类","slug":"1000codes","date":"2022-04-16T12:42:24.000Z","updated":"2022-05-03T04:08:29.389Z","comments":true,"path":"2022/04/16/1000codes/","link":"","permalink":"https://hxlpub.github.io/2022/04/16/1000codes/","excerpt":"","text":"1.","categories":[{"name":"codes","slug":"codes","permalink":"https://hxlpub.github.io/categories/codes/"}],"tags":[{"name":"codes","slug":"codes","permalink":"https://hxlpub.github.io/tags/codes/"}]},{"title":"python常见问题","slug":"python-common-problems","date":"2022-04-06T07:44:09.000Z","updated":"2022-04-09T12:36:33.876Z","comments":true,"path":"2022/04/06/python-common-problems/","link":"","permalink":"https://hxlpub.github.io/2022/04/06/python-common-problems/","excerpt":"","text":"“ModuleNotFoundError: No module named ‘xxx’","categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"https://hxlpub.github.io/tags/Python/"}]},{"title":"理解if__name","slug":"ifname","date":"2022-04-03T10:16:20.000Z","updated":"2022-04-05T09:32:06.889Z","comments":true,"path":"2022/04/03/ifname/","link":"","permalink":"https://hxlpub.github.io/2022/04/03/ifname/","excerpt":"","text":"1.参考","categories":[{"name":"Python","slug":"Python","permalink":"https://hxlpub.github.io/categories/Python/"}],"tags":[{"name":"python","slug":"python","permalink":"https://hxlpub.github.io/tags/python/"}]},{"title":"linux_shortcut","slug":"linux-shortcut","date":"2022-04-03T06:46:36.000Z","updated":"2022-04-03T07:20:23.251Z","comments":true,"path":"2022/04/03/linux-shortcut/","link":"","permalink":"https://hxlpub.github.io/2022/04/03/linux-shortcut/","excerpt":"","text":"跳转到指定行 123:n ---跳到第n行，需要回车ngg或nG ---跳到第n行,无需回车vim +n filename --- 打开文件后跳到文件第n行 多行注释和多行删除 123456789101112131415161718192021222324252627281.多行注释依次进行按下esc -&gt; Ctrl+v -&gt; 上下键选择多行 -&gt; shift+i -&gt; 输入注释//或# -&gt; 按下esc2.删除多行注释Ctrl+v -&gt; 上下键选择多行 -&gt; x 或 d (若// 执行两次，若# 一次即可 )3.多行删除:set nu -&gt; :起始行:终止行 -&gt; 回车若误删，使用 u 恢复4.其他单行删除，：1（待删除行）d多行删除 ，：1,10d光标所在行，dd光标所在行以下的N行，Ndd复制少量行文本的情况，复制第6行（包括）下面的2行数据，放到第9行下面 方法1： 光标放到第6行， 输入：2yy 光标放到第9行， 输入：p 此方法适合复制少量行文本的情况，复制第6行（包括）下面的2行数据，放到第9行下面。 方法2： 命令行模式下输入 6,9 co 12 复制第6行到第9行之间的内容到第12行后面。","categories":[{"name":"Linux","slug":"Linux","permalink":"https://hxlpub.github.io/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://hxlpub.github.io/tags/Linux/"}]},{"title":"define_a_systemd_service","slug":"define-a-systemd-service","date":"2022-04-01T11:05:53.000Z","updated":"2022-04-03T05:35:40.254Z","comments":true,"path":"2022/04/01/define-a-systemd-service/","link":"","permalink":"https://hxlpub.github.io/2022/04/01/define-a-systemd-service/","excerpt":"how to define a systemd service","text":"how to define a systemd service 将编译生成的二进制文件 修改/usr/lib/systemd/system/daos_agent.service ExecStart=/usr/local/daos/bin/daos_agent -i -o &lt;’path to agent configuration file/daos_agent.yml’&gt; systemctl daemon-reload systemctl enable daos_agent.service systemctl start daos_agent.service","categories":[{"name":"Linux","slug":"Linux","permalink":"https://hxlpub.github.io/categories/Linux/"}],"tags":[{"name":"systemd","slug":"systemd","permalink":"https://hxlpub.github.io/tags/systemd/"}]},{"title":"python_newer","slug":"python-newer","date":"2022-03-29T10:09:39.000Z","updated":"2022-04-03T10:15:18.190Z","comments":true,"path":"2022/03/29/python-newer/","link":"","permalink":"https://hxlpub.github.io/2022/03/29/python-newer/","excerpt":"","text":"python的特点 相比之下，Python 更易于使用，无论在 Windows、Mac OS X 或 Unix 操作系统上它都会帮助你更快地完成任务 与 Shell 脚本或批处理文件相比，它为编写大型程序提供了更多的结构和支持。 Python 提供了比 C 更多的错误检查，并且作为一门 高级语言，它内置支持高级的数据结构类型，例如：灵活的数组和字典。 Python 允许你将程序分割为不同的模块，以便在其他的 Python 程序中重用。Python 内置提供了大量的标准模块，你可以将其用作程序的基础，或者作为学习 Python 编程的示例。这些模块提供了诸如文件 I/O、系统调用、Socket 支持，甚至类似 Tk 的用户图形界面（GUI）工具包接口 Python 是一门解释型语言，因为无需编译和链接，你可以在程序开发中节省宝贵的时间。Python 解释器可以交互的使用，这使得试验语言的特性、编写临时程序或在自底向上的程序开发中测试方法非常容易。你甚至还可以把它当做一个桌面计算器。 Python 让程序编写的紧凑和可读。用 Python 编写的程序通常比同样的 C、C++ 或 Java 程序更短小，这是因为以下几个原因: 12345* 高级数据结构使你可以在一条语句中表达复杂的操作；* 语句组使用缩进代替开始和结束大括号来组织；* 变量或参数无需声明。 Python 是 可扩展 的：如果你会 C 语言编程便可以轻易地为解释器添加内置函数或模块，或者为了对性能瓶颈作优化，或者将 Python 程序与只有二进制形式的库（比如某个专业的商业图形库）连接起来。一旦你真正掌握了它，你可以将 Python 解释器集成进某个 C 应用程序，并把它当作那个程序的扩展或命令行语言。 ​","categories":[{"name":"Python","slug":"Python","permalink":"https://hxlpub.github.io/categories/Python/"}],"tags":[{"name":"python","slug":"python","permalink":"https://hxlpub.github.io/tags/python/"}]},{"title":"newpc_test_for_hexo_blog","slug":"newpc","date":"2022-01-15T09:05:23.000Z","updated":"2022-03-26T08:50:54.949Z","comments":true,"path":"2022/01/15/newpc/","link":"","permalink":"https://hxlpub.github.io/2022/01/15/newpc/","excerpt":"","text":"ps:new year love more ！！！","categories":[{"name":"startup","slug":"startup","permalink":"https://hxlpub.github.io/categories/startup/"}],"tags":[{"name":"love more","slug":"love-more","permalink":"https://hxlpub.github.io/tags/love-more/"}]},{"title":"设计模式","slug":"system_design_thinking","date":"2022-01-13T02:16:07.000Z","updated":"2022-03-26T08:51:57.827Z","comments":true,"path":"2022/01/13/system_design_thinking/","link":"","permalink":"https://hxlpub.github.io/2022/01/13/system_design_thinking/","excerpt":"","text":"1、异步同步阻塞非阻塞（以下知乎十分有趣） https://www.zhihu.com/question/26393784 老张爱喝茶，废话不说，煮开水。 出场人物：老张，水壶两把（普通水壶，简称水壶；会响的水壶，简称响水壶）。 1)老张把水壶放到火上，立等水开。（同步阻塞） 老张觉得自己有点傻 2)老张把水壶放到火上，去客厅看电视，时不时去厨房看看水开没有。（同步非阻塞） 老张还是觉得自己有点傻，于是变高端了，买了把会响笛的那种水壶。水开之后，能大声发出嘀~~~~的噪音。 3)老张把响水壶放到火上，立等水开。（异步阻塞） 老张觉得这样傻等意义不大 4)老张把响水壶放到火上，去客厅看电视，水壶响之前不再去看它了，响了再去拿壶。（异步非阻塞） 老张觉得自己聪明了。 所谓同步异步，只是对于水壶而言。 普通水壶，同步；响水壶，异步。 虽然都能干活，但响水壶可以在自己完工之后，提示老张水开了。这是普通水壶所不能及的。 同步只能让调用者去轮询自己（情况2中），造成老张效率的低下。所谓阻塞非阻塞，仅仅对于老张而言。 立等的老张，阻塞；看电视的老张，非阻塞。 情况1和情况3中老张就是阻塞的，媳妇喊他都不知道。虽然3中响水壶是异步的，可对于立等的老张没有太大的意义。所以一般异步是配合非阻塞使用的，这样才能发挥异步的效用。 作者：知乎用户链接：https://www.zhihu.com/question/26393784/answer/513257548来源：知乎著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://hxlpub.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://hxlpub.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"golang之编码规范","slug":"go_base_coding_rule","date":"2022-01-09T04:47:30.000Z","updated":"2022-03-26T09:06:21.612Z","comments":true,"path":"2022/01/09/go_base_coding_rule/","link":"","permalink":"https://hxlpub.github.io/2022/01/09/go_base_coding_rule/","excerpt":"","text":"","categories":[{"name":"golang","slug":"golang","permalink":"https://hxlpub.github.io/categories/golang/"}],"tags":[{"name":"golang","slug":"golang","permalink":"https://hxlpub.github.io/tags/golang/"}]},{"title":"golang之必知必会","slug":"go_base","date":"2022-01-09T04:47:30.000Z","updated":"2022-04-16T12:38:10.268Z","comments":true,"path":"2022/01/09/go_base/","link":"","permalink":"https://hxlpub.github.io/2022/01/09/go_base/","excerpt":"","text":"go简介Go 是一个开源的编程语言，它能让构造简单、可靠且高效的软件变得容易。 特色 简洁、快速、安全 并行、有趣、开源 内存管理、数组安全、编译迅速 Go 语言最主要的特性： 自动垃圾回收 更丰富的内置类型 函数多返回值 错误处理 匿名函数和闭包 类型和接口 并发编程 反射 语言交互性 用途 Go 语言被设计成一门应用于搭载 Web 服务器，存储集群或类似用途的巨型中央服务器的系统编程语言。 对于高性能分布式系统领域而言，Go 语言无疑比大多数其它语言有着更高的开发效率。它提供了海量并行的支持，这对于游戏服务端的开发而言是再好不过了。 hello go 123456789101112131415161718package mainimport &quot;fmt&quot;func main()&#123; fmt.Println(&quot;hello go!!!&quot;)&#125;[root@192 go]# go run hello.go #go run 执行hello go!!![root@192 go]# go build hello.go #go build 编译生成二进制[root@192 go]# lltotal 1896-rwxr-xr-x. 1 root root 1937013 Mar 14 10:00 hello-rw-r--r--. 1 root root 70 Mar 14 09:59 hello.go[root@192 go]# ./hello hello go!!! 程序结构 包声明 引入包 函数 变量 语句 &amp; 表达式 注释 12345678package mainimport &quot;fmt&quot;func main() &#123;// 注意&#123; 不能在单独的行上，否则会报错 /* 这是我的第一个简单的程序 */ fmt.Println(&quot;Hello, World!&quot;)&#125; 第一行代码 package main 定义了包名。你必须在源文件中非注释的第一行指明这个文件属于哪个包，如：package main。package main表示一个可独立执行的程序，每个 Go 应用程序都包含一个名为 main 的包。 下一行 import “fmt” 告诉 Go 编译器这个程序需要使用 fmt 包（的函数，或其他元素），fmt 包实现了格式化 IO（输入/输出）的函数。 下一行 func main() 是程序开始执行的函数。main 函数是每一个可执行程序所必须包含的，一般来说都是在启动后第一个执行的函数（如果有 init() 函数则会先执行该函数）。 下一行 /…/ 是注释，在程序执行时将被忽略。单行注释是最常见的注释形式，你可以在任何地方使用以 // 开头的单行注释。多行注释也叫块注释，均已以 /* 开头，并以 */ 结尾，且不可以嵌套使用，多行注释一般用于包的文档描述或注释成块的代码片段。 下一行 fmt.Println(…) 可以将字符串输出到控制台，并在最后自动增加换行字符 \\n。使用 fmt.Print(“hello, world\\n”) 可以得到相同的结果。Print 和 Println 这两个函数也支持使用变量，如：fmt.Println(arr)。如果没有特别指定，它们会以默认的打印格式将变量 arr 输出到控制台。 当标识符（包括常量、变量、类型、函数名、结构字段等等）以一个大写字母开头，如：Group1，那么使用这种形式的标识符的对象就可以被外部包的代码所使用（客户端程序需要先导入这个包），这被称为导出（像面向对象语言中的 public）；标识符如果以小写字母开头，则对包外是不可见的，但是他们在整个包的内部是可见并且可用的（像面向对象语言中的 protected ）。 基础语法 Go 标记 ​ Go 程序可以由多个标记组成，可以是关键字，标识符，常量，字符串，符号。如以下 GO 语句由 6 个标记组成： 1fmt.Println(&quot;Hello, World!&quot;) ​ 6 个标记是(每行一个)： 1234561. fmt2. .3. Println4. (5. &quot;Hello, World!&quot;6. ) 行分隔符 在 Go 程序中，一行代表一个语句结束。每个语句不需要像 C 家族中的其它语言一样以分号 ; 结尾，因为这些工作都将由 Go 编译器自动完成。 如果你打算将多个语句写在同一行，它们则必须使用 ; 人为区分，但在实际开发中我们并不鼓励这种做法。 以下为两个语句： 12fmt.Println(&quot;Hello, World!&quot;)fmt.Println(&quot;菜鸟教程：runoob.com&quot;) 注释 注释不会被编译，每一个包应该有相关注释。 单行注释是最常见的注释形式，你可以在任何地方使用以 // 开头的单行注释。多行注释也叫块注释，均已以 /* 开头，并以 */ 结尾。如： 12345// 单行注释/* Author by 菜鸟教程 我是多行注释 */ 标识符 标识符用来命名变量、类型等程序实体。一个标识符实际上就是一个或是多个字母(AZ和az)数字(0~9)、下划线_组成的序列，但是第一个字符必须是字母或下划线而不能是数字。 以下是有效的标识符： 12mahesh kumar abc move_name a_123myname50 _temp j a23b9 retVal 以下是无效的标识符： 1ab（以数字开头） case（Go 语言的关键字） a+b（运算符是不允许的） 字符串连接 Go 语言的字符串可以通过 + 实现： 实例 12345package mainimport &quot;fmt&quot;func main() &#123; fmt.Println(&quot;Google&quot; + &quot;Runoob&quot;)&#125; 关键字 下面列举了 Go 代码中会使用到的 25 个关键字或保留字： break default func interface select case defer go map struct chan else goto package switch const fallthrough if range type continue for import return var 除了以上介绍的这些关键字，Go 语言还有 36 个预定义标识符： append bool byte cap close complex complex64 complex128 uint16 copy false float32 float64 imag int int8 int16 uint32 int32 int64 iota len make new nil panic uint64 print println real recover string true uint uint8 uintptr 程序一般由关键字、常量、变量、运算符、类型和函数组成。 程序中可能会使用到这些分隔符：括号 ()，中括号 [] 和大括号 {}。 程序中可能会使用到这些标点符号：.、,、;、: 和 …。 Go 语言的空格 Go 语言中变量的声明必须使用空格隔开，如： 1var age int 语句中适当使用空格能让程序更易阅读。 无空格： 1fruit=apples+oranges 在变量与运算符间加入空格，程序看起来更加美观，如： 1fruit = apples + oranges; 格式化字符串 Go 语言中使用 fmt.Sprintf 格式化字符串并赋值给新串： 实例 package main import ( “fmt”) 12345678func main() &#123; // %d 表示整型数字，%s 表示字符串 var stockcode=123 var enddate=&quot;2020-12-31&quot; var url=&quot;Code=%d&amp;endDate=%s&quot; var target_url=fmt.Sprintf(url,stockcode,enddate) fmt.Println(target_url)&#125; 输出结果为： 1Code=123&amp;endDate=2020-12-31 Go 可以使用 fmt.Sprintf 来格式化字符串，格式如下： 1fmt.Sprintf(格式化样式, 参数列表…) 格式化样式：字符串形式，格式化符号以 % 开头， %s 字符串格式，%d 十进制的整数格式。 参数列表：多个参数以逗号分隔，个数必须与格式化样式中的个数一一对应，否则运行时会报错。 Go 字符串格式化符号: 格 式 描 述 %v 按值的本来值输出 %+v 在 %v 基础上，对结构体字段名和值进行展开 %#v 输出 Go 语言语法格式的值 %T 输出 Go 语言语法格式的类型和值 %% 输出 % 本体 %b 整型以二进制方式显示 %o 整型以八进制方式显示 %d 整型以十进制方式显示 %x 整型以十六进制方式显示 %X 整型以十六进制、字母大写方式显示 %U Unicode 字符 %f 浮点数 %p 指针，十六进制方式显示 数据类型在 Go 编程语言中，数据类型用于声明函数和变量。 数据类型的出现是为了把数据分成所需内存大小不同的数据，编程的时候需要用大数据的时候才需要申请大内存，就可以充分利用内存。 Go 语言按类别有以下几种数据类型： 序号 类型和描述 1 布尔型 布尔型的值只可以是常量 true 或者 false。一个简单的例子：var b bool = true。 2 数字类型 整型 int 和浮点型 float32、float64，Go 语言支持整型和浮点型数字，并且支持复数，其中位的运算采用补码。 3 字符串类型: 字符串就是一串固定长度的字符连接起来的字符序列。Go 的字符串是由单个字节连接起来的。Go 语言的字符串的字节使用 UTF-8 编码标识 Unicode 文本。 4 派生类型: 包括：(a) 指针类型（Pointer）(b) 数组类型(c) 结构化类型(struct)(d) Channel 类型(e) 函数类型(f) 切片类型(g) 接口类型（interface）(h) Map 类型 数字类型 Go 也有基于架构的类型，例如：int、uint 和 uintptr。 序号 类型和描述 1 uint8 无符号 8 位整型 (0 到 255) 2 uint16 无符号 16 位整型 (0 到 65535) 3 uint32 无符号 32 位整型 (0 到 4294967295) 4 uint64 无符号 64 位整型 (0 到 18446744073709551615) 5 int8 有符号 8 位整型 (-128 到 127) 6 int16 有符号 16 位整型 (-32768 到 32767) 7 int32 有符号 32 位整型 (-2147483648 到 2147483647) 8 int64 有符号 64 位整型 (-9223372036854775808 到 9223372036854775807) 浮点型 序号 类型和描述 1 float32 IEEE-754 32位浮点型数 2 float64 IEEE-754 64位浮点型数 3 complex64 32 位实数和虚数 4 complex128 64 位实数和虚数 其他数字类型 以下列出了其他更多的数字类型： 序号 类型和描述 1 byte 类似 uint8 2 rune 类似 int32 3 uint 32 或 64 位 4 int 与 uint 一样大小 5 uintptr 无符号整型，用于存放一个指针 变量变量来源于数学，是计算机语言中能储存计算结果或能表示值抽象概念。 变量可以通过变量名访问。 Go 语言变量名由字母、数字、下划线组成，其中首个字符不能为数字。 声明变量的一般形式是使用 var 关键字： 1var identifier type 可以一次声明多个变量： 1var identifier1, identifier2 type 12345678910111213package mainimport &quot;fmt&quot;func main() &#123; var a string = &quot;Runoob&quot; fmt.Println(a) var b, c int = 1, 2 fmt.Println(b, c)&#125;以上实例输出结果为：Runoob1 2 变量声明 第一种，指定变量类型，如果没有初始化，则变量默认为零值。 123456789101112131415161718192021222324var v_name v_typev_name = value零值就是变量没有做初始化时系统默认设置的值。package mainimport &quot;fmt&quot;func main() &#123; // 声明一个变量并初始化 var a = &quot;RUNOOB&quot; fmt.Println(a) // 没有初始化就为零值 var b int fmt.Println(b) // bool 零值为 false var c bool fmt.Println(c)&#125;以上实例执行结果为：RUNOOB0false 数值类型（包括complex64/128）为 0 布尔类型为 false 字符串为 **””**（空字符串） 以下几种类型为 nil： ```govar a *intvar a []intvar a map[string] intvar a chan intvar a func(string) intvar a error // error 是接口package mainimport “fmt”func main() {var i int var f float64 var b bool var s string fmt.Printf(&quot;%v %v %v %q\\n&quot;, i, f, b, s) }输出结果是：0 0 false “”12345**第二种，根据值自行判定变量类型。**```govar v_name = value 123456789package mainimport &quot;fmt&quot;func main() &#123; var d = true fmt.Println(d)&#125;输出结果是：true 第三种，如果变量已经使用 var 声明过了，再使用 *:=* 声明变量，就产生编译错误，格式： 1v_name := value 12var intVal int intVal :=1 // 这时候会产生编译错误，因为 intVal 已经声明，不需要重新声明 直接使用下面的语句即可： 12345intVal := 1 // 此时不会产生编译错误，因为有声明新的变量，因为 := 是一个声明语句intVal := 1 相等于：var intVal int intVal =1 多变量声明 1234567891011121314//类型相同多个变量, 非全局变量var vname1, vname2, vname3 typevname1, vname2, vname3 = v1, v2, v3var vname1, vname2, vname3 = v1, v2, v3 // 和 python 很像,不需要显示声明类型，自动推断vname1, vname2, vname3 := v1, v2, v3 // 出现在 := 左侧的变量不应该是已经被声明过的，否则会导致编译错误// 这种因式分解关键字的写法一般用于声明全局变量var ( vname1 v_type1 vname2 v_type2) 123456789101112131415161718192021package mainvar x, y intvar ( // 这种因式分解关键字的写法一般用于声明全局变量 a int b bool)var c, d int = 1, 2var e, f = 123, &quot;hello&quot;//这种不带声明格式的只能在函数体中出现//g, h := 123, &quot;hello&quot;func main()&#123; g, h := 123, &quot;hello&quot; println(x, y, a, b, c, d, e, f, g, h)&#125;以上实例执行结果为：0 0 0 false 1 2 123 hello 123 hello 简短形式，使用 := 赋值操作符 a := 50 或 b := false。 a 和 b 的类型（int 和 bool）将由编译器自动推断。 这是使用变量的首选形式，但是它只能被用在函数体内，而不可以用于全局变量的声明与赋值。使用操作符 := 可以高效地创建一个新的变量，称之为初始化声明。 注意事项 如果在相同的代码块中，我们不可以再次对于相同名称的变量使用初始化声明，例如：a := 20 就是不被允许的，编译器会提示错误 no new variables on left side of :=，但是 a = 20 是可以的，因为这是给相同的变量赋予一个新的值。 如果你在定义变量 a 之前使用它，则会得到编译错误 undefined: a。 如果你声明了一个局部变量却没有在相同的代码块中使用它，同样会得到编译错误; 但是全局变量是允许声明但不使用的。 同一类型的多个变量可以声明在同一行，如： 1var a, b, c int 多变量可以在同一行进行赋值，如： 123var a, b intvar c stringa, b, c = 5, 7, &quot;abc&quot; 上面这行假设了变量 a，b 和 c 都已经被声明，否则的话应该这样使用： 1a, b, c := 5, 7, &quot;abc&quot; 右边的这些值以相同的顺序赋值给左边的变量，所以 a 的值是 5， b 的值是 7，c 的值是 “abc”。 这被称为 并行 或 同时 赋值。 如果你想要交换两个变量的值，则可以简单地使用 a, b = b, a，两个变量的类型必须是相同。 空白标识符 _ 也被用于抛弃值，如值 5 在：_, b = 5, 7 中被抛弃。 _ 实际上是一个只写变量，你不能得到它的值。这样做是因为 Go 语言中你必须使用所有被声明的变量，但有时你并不需要使用从一个函数得到的所有返回值。 并行赋值也被用于当一个函数返回多个返回值时，比如这里的 val 和错误 err 是通过调用 Func1 函数同时得到：val, err = Func1(var1)。 常量常量是一个简单值的标识符，在程序运行时，不会被修改的量。 常量中的数据类型只可以是布尔型、数字型（整数型、浮点型和复数）和字符串型。 常量的定义格式： 1const identifier [type] = value 你可以省略类型说明符 [type]，因为编译器可以根据变量的值来推断其类型。 显式类型定义： const b string = &quot;abc&quot; 隐式类型定义： const b = &quot;abc&quot; 多个相同类型的声明可以简写为： 1const c_name1, c_name2 = value1, value2 12345678910111213141516171819package mainimport &quot;fmt&quot;func main() &#123; const LENGTH int = 10 const WIDTH int = 5 var area int const a, b, c = 1, false, &quot;str&quot; //多重赋值 area = LENGTH * WIDTH fmt.Printf(&quot;面积为 : %d&quot;, area) println() println(a, b, c) &#125;以上实例运行结果为：面积为 : 501 false str 常量还可以用作枚举： 12345const ( Unknown = 0 Female = 1 Male = 2) 常量可以用len(), cap(), unsafe.Sizeof()函数计算表达式的值。常量表达式中，函数必须是内置函数，否则编译不过： 实例 123456789101112package mainimport &quot;unsafe&quot;const ( a = &quot;abc&quot; b = len(a) c = unsafe.Sizeof(a))func main()&#123; println(a, b, c)&#125; 以上实例运行结果为： 1abc 3 16 iota iota，特殊常量，可以认为是一个可以被编译器修改的常量。 iota 在 const关键字出现时将被重置为 0(const 内部的第一行之前)，const 中每新增一行常量声明将使 iota 计数一次(iota 可理解为 const 语句块中的行索引)。 iota 可以被用作枚举值： 12345const ( a = iota b = iota c = iota) 第一个 iota 等于 0，每当 iota 在新的一行被使用时，它的值都会自动加 1；所以 a=0, b=1, c=2 可以简写为如下形式： 12345const ( a = iota b c) 123456789101112131415161718192021package mainimport &quot;fmt&quot;func main() &#123; const ( a = iota //0 b //1 c //2 d = &quot;ha&quot; //独立值，iota += 1 e //&quot;ha&quot; iota += 1 f = 100 //iota +=1 g //100 iota +=1 h = iota //7,恢复计数 i //8 ) fmt.Println(a,b,c,d,e,f,g,h,i)&#125;以上实例运行结果为：0 1 2 ha ha 100 100 7 8 运算符注意：go没有三目运算符 优先级 分类 运算符 结合性 1 逗号运算符 , 从左到右 2 赋值运算符 =、+=、-=、*=、/=、 %=、 &gt;&gt;=、 &lt;&lt;=、&amp;=、^=、|= 从右到左 3 逻辑或 || 从左到右 4 逻辑与 &amp;&amp; 从左到右 5 按位或 | 从左到右 6 按位异或 ^ 从左到右 7 按位与 &amp; 从左到右 8 相等/不等 ==、!= 从左到右 9 关系运算符 &lt;、&lt;=、&gt;、&gt;= 从左到右 10 位移运算符 &lt;&lt;、&gt;&gt; 从左到右 11 加法/减法 +、- 从左到右 12 乘法/除法/取余 *（乘号）、/、% 从左到右 13 单目运算符 + 、-、 !、 ~、 (type)*、 &amp; sizeof （待确认） 从右到左 14 后缀运算符 ( )、[ ]、-&gt;、.、++、– 从左到右 http://c.biancheng.net/view/5559.html 条件语句Go 语言提供了以下几种条件判断语句： 语句 描述 if 语句 if 语句 由一个布尔表达式后紧跟一个或多个语句组成。 if…else 语句 if 语句 后可以使用可选的 else 语句, else 语句中的表达式在布尔表达式为 false 时执行。 if 嵌套语句 你可以在 if 或 else if 语句中嵌入一个或多个 if 或 else if 语句。 switch 语句 switch 语句用于基于不同条件执行不同动作。 select 语句 select 语句类似于 switch 语句，但是select会随机执行一个可运行的case。如果没有case可运行，它将阻塞，直到有case可运行。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798991001011021031041051061071081091101111121131141151161171181191201211221231241251261271281291301.if if 布尔表达式 &#123; /* 如果条件为 true 则执行以下语句 */ &#125;2.if elseif 布尔表达式 &#123; /* 如果条件为 true 则执行以下语句 */&#125; else &#123; /* 如果条件为 false 则执行以下语句 */ &#125;3.if嵌套 if 布尔表达式1 &#123; /* if 条件语句为 true 执行 */ if 布尔表达式2 &#123; /* if 条件语句为 true 执行 */ &#125; &#125;4.switchswitch var1 &#123; case val1: ... case val2: ... default: ...&#125;/* 定义局部变量 */ var grade string = &quot;B&quot; var marks int = 90 switch marks &#123; case 90: grade = &quot;A&quot; case 80: grade = &quot;B&quot; case 50,60,70 : grade = &quot;C&quot; default: grade = &quot;D&quot; &#125; switch &#123; case grade == &quot;A&quot; : fmt.Printf(&quot;优秀!\\n&quot; ) case grade == &quot;B&quot;, grade == &quot;C&quot; : fmt.Printf(&quot;良好\\n&quot; ) case grade == &quot;D&quot; : fmt.Printf(&quot;及格\\n&quot; ) case grade == &quot;F&quot;: fmt.Printf(&quot;不及格\\n&quot; ) default: fmt.Printf(&quot;差\\n&quot; ); &#125;5.Type Switchswitch 语句还可以被用于 type-switch 来判断某个 interface 变量中实际存储的变量类型。Type Switch 语法格式如下：switch x.(type)&#123; case type: statement(s); case type: statement(s); /* 你可以定义任意个数的case */ default: /* 可选 */ statement(s);&#125;var x interface&#123;&#125; switch i := x.(type) &#123; case nil: fmt.Printf(&quot; x 的类型 :%T&quot;,i) case int: fmt.Printf(&quot;x 是 int 型&quot;) case float64: fmt.Printf(&quot;x 是 float64 型&quot;) case func(int) float64: fmt.Printf(&quot;x 是 func(int) 型&quot;) case bool, string: fmt.Printf(&quot;x 是 bool 或 string 型&quot; ) default: fmt.Printf(&quot;未知型&quot;) &#125; 6.fallthrough使用 fallthrough 会强制执行后面的 case 语句，fallthrough 不会判断下一条 case 的表达式结果是否为 true。func main()&#123; switch &#123; case false: fmt.Println(&quot;1、case 条件语句为 false&quot;) fallthrough case true: fmt.Println(&quot;2、case 条件语句为 true&quot;) fallthrough case false: fmt.Println(&quot;3、case 条件语句为 false&quot;) fallthrough case true: fmt.Println(&quot;4、case 条件语句为 true&quot;) case false: fmt.Println(&quot;5、case 条件语句为 false&quot;) fallthrough default: fmt.Println(&quot;6、默认 case&quot;) &#125;&#125;以上代码执行结果为：2、case 条件语句为 true3、case 条件语句为 false4、case 条件语句为 true从以上代码输出的结果可以看出：switch 从第一个判断表达式为 true 的 case 开始执行，如果 case 带有 fallthrough，程序会继续执行下一条 case，且它不会去判断下一个 case 的表达式是否为 true。7.select select是 Go 中的一个控制结构，类似于用于通信的 switch 语句。每个 case 必须是一个通信操作，要么是发送要么是接收。select 随机执行一个可运行的 case。如果没有 case 可运行，它将阻塞，直到有 case 可运行。一个默认的子句应该总是可运行的。select 语句的语法如下：select &#123; case communication clause : statement(s); case communication clause : statement(s); /* 你可以定义任意数量的 case */ default : /* 可选 */ statement(s);&#125;以下描述了 select 语句的语法：每个 case 都必须是一个通信所有 channel 表达式都会被求值所有被发送的表达式都会被求值如果任意某个通信可以进行，它就执行，其他被忽略。如果有多个 case 都可以运行，Select 会随机公平地选出一个执行。其他不会执行。否则：1.如果有 default 子句，则执行该语句。2.如果没有 default 子句，select 将阻塞，直到某个通信可以运行；Go 不会重新对 channel 或值进行求值。以上代码执行结果为：no communication 循环语句函数匿名函数​ https://www.jianshu.com/p/91140fdd6e91 变量作用域数组指针结构体注意结构体标签如，Age int json:&quot;age,omitempty&quot; https://www.cnblogs.com/liyutian/p/10050320.html 切片Go 语言切片是对数组的抽象。 Go 数组的长度不可改变，在特定场景中这样的集合就不太适用，Go 中提供了一种灵活，功能强悍的内置类型切片(“动态数组”)，与数组相比切片的长度是不固定的，可以追加元素，在追加时可能使切片的容量增大。 定义切片： 你可以声明一个未指定大小的数组来定义切片： 1var identifier []type 切片不需要说明长度。 或使用 make() 函数来创建切片: 123var slice1 []type = make([]type, len)也可以简写为slice1 := make([]type, len) 也可以指定容量，其中 capacity 为可选参数。 1make([]T, length, capacity) 这里 len 是数组的长度并且也是切片的初始长度。 切片初始化 1s :=[] int &#123;1,2,3 &#125; 直接初始化切片，**[]** 表示是切片类型，**{1,2,3}** 初始化值依次是 1,2,3，其 cap=len=3。 1s := arr[:] 初始化切片 s，是数组 arr 的引用。 1s := arr[startIndex:endIndex] 将 arr 中从下标 startIndex 到 endIndex-1 下的元素创建为一个新的切片。 1s := arr[startIndex:] 默认 endIndex 时将表示一直到arr的最后一个元素。 1s := arr[:endIndex] 默认 startIndex 时将表示从 arr 的第一个元素开始。 1s1 := s[startIndex:endIndex] 通过切片 s 初始化切片 s1。 1s :=make([]int,len,cap) 通过内置函数 make() 初始化切片s，**[]int** 标识为其元素类型为 int 的切片。 切片是可索引的，并且可以由 len() 方法获取长度。 切片提供了计算容量的方法 cap() 可以测量切片最长可以达到多少。 以下为具体实例： 实例 12345678910111213package mainimport &quot;fmt&quot;func main() &#123; var numbers = make([]int,3,5) printSlice(numbers)&#125;func printSlice(x []int)&#123; fmt.Printf(&quot;len=%d cap=%d slice=%v**\\n**&quot;,len(x),cap(x),x)&#125; 以上实例运行输出结果为: 1len=3 cap=5 slice=[0 0 0] 空(nil)切片 一个切片在未初始化之前默认为 nil，长度为 0，实例如下： 实例 12345678910111213141516package mainimport &quot;fmt&quot;func main() &#123; var numbers []int printSlice(numbers) if(numbers == nil)&#123; fmt.Printf(&quot;切片是空的&quot;) &#125;&#125;func printSlice(x []int)&#123; fmt.Printf(&quot;len=%d cap=%d slice=%v**\\n**&quot;,len(x),cap(x),x)&#125; 以上实例运行输出结果为: 12len=0 cap=0 slice=[]切片是空的 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package mainimport &quot;fmt&quot;func main() &#123; /* 创建切片 */ numbers := []int&#123;0,1,2,3,4,5,6,7,8&#125; printSlice(numbers) /* 打印原始切片 */ fmt.Println(&quot;numbers ==&quot;, numbers) /* 打印子切片从索引1(包含) 到索引4(不包含)*/ fmt.Println(&quot;numbers[1:4] ==&quot;, numbers[1:4]) /* 默认下限为 0*/ fmt.Println(&quot;numbers[:3] ==&quot;, numbers[:3]) /* 默认上限为 len(s)*/ fmt.Println(&quot;numbers[4:] ==&quot;, numbers[4:]) numbers1 := make([]int,0,5) printSlice(numbers1) /* 打印子切片从索引 0(包含) 到索引 2(不包含) */ number2 := numbers[:2] printSlice(number2) /* 打印子切片从索引 2(包含) 到索引 5(不包含) */ number3 := numbers[2:5] printSlice(number3)&#125;func printSlice(x []int)&#123; fmt.Printf(&quot;len=%d cap=%d slice=%v\\n&quot;,len(x),cap(x),x)&#125;执行以上代码输出结果为：len=9 cap=9 slice=[0 1 2 3 4 5 6 7 8]numbers == [0 1 2 3 4 5 6 7 8]numbers[1:4] == [1 2 3]numbers[:3] == [0 1 2]numbers[4:] == [4 5 6 7 8]len=0 cap=5 slice=[]len=2 cap=9 slice=[0 1]len=3 cap=7 slice=[2 3 4] append() 和 copy() 函数 如果想增加切片的容量，我们必须创建一个新的更大的切片并把原分片的内容都拷贝过来。 下面的代码描述了从拷贝切片的 copy 方法和向切片追加新元素的 append 方法。 1234567891011121314151617181920212223242526272829303132333435363738package mainimport &quot;fmt&quot;func main() &#123; var numbers []int printSlice(numbers) /* 允许追加空切片 */ numbers = append(numbers, 0) printSlice(numbers) /* 向切片添加一个元素 */ numbers = append(numbers, 1) printSlice(numbers) /* 同时添加多个元素 */ numbers = append(numbers, 2,3,4) printSlice(numbers) /* 创建切片 numbers1 是之前切片的两倍容量*/ numbers1 := make([]int, len(numbers), (cap(numbers))*2) /* 拷贝 numbers 的内容到 numbers1 */ copy(numbers1,numbers) printSlice(numbers1) &#125;func printSlice(x []int)&#123; fmt.Printf(&quot;len=%d cap=%d slice=%v\\n&quot;,len(x),cap(x),x)&#125;以上代码执行输出结果为：len=0 cap=0 slice=[]len=1 cap=1 slice=[0]len=2 cap=2 slice=[0 1]len=5 cap=6 slice=[0 1 2 3 4]len=5 cap=12 slice=[0 1 2 3 4] 范围Map（集合）递归函数类型转换接口错误处理并发channel 参考： https://www.runoob.com/w3cnote/go-channel-intro.html Channel是Go中的一个核心类型，你可以把它看成一个管道，通过它并发核心单元就可以发送或者接收数据进行通讯(communication)。 它的操作符是箭头 &lt;- 。 12ch &lt;- v // 发送值v到Channel ch中v := &lt;-ch // 从Channel ch中接收数据，并将数据赋值给v (箭头的指向就是数据的流向) 就像 map 和 slice 数据类型一样, channel必须先创建再使用: 1ch := make(chan int) channel类型 Channel类型的定义格式如下： 1ChannelType = ( &quot;chan&quot; | &quot;chan&quot; &quot;&lt;-&quot; | &quot;&lt;-&quot; &quot;chan&quot; ) ElementType . 它包括三种类型的定义。可选的&lt;-代表channel的方向。如果没有指定方向，那么Channel就是双向的，既可以接收数据，也可以发送数据。 123chan T // 可以接收和发送类型为 T 的数据chan&lt;- float64 // 只可以用来发送 float64 类型的数据&lt;-chan int // 只可以用来接收 int 类型的数据 &lt;-总是优先和最左边的类型结合。 1234chan&lt;- chan int // 等价 chan&lt;- (chan int)chan&lt;- &lt;-chan int // 等价 chan&lt;- (&lt;-chan int)&lt;-chan &lt;-chan int // 等价 &lt;-chan (&lt;-chan int)chan (&lt;-chan int) 使用make初始化Channel,并且可以设置容量: 1make(chan int, 100) 容量(capacity)代表Channel容纳的最多的元素的数量，代表Channel的缓存的大小。如果没有设置容量，或者容量设置为0, 说明Channel没有缓存，只有sender和receiver都准备好了后它们的通讯(communication)才会发生(Blocking)。如果设置了缓存，就有可能不发生阻塞， 只有buffer满了后 send才会阻塞， 而只有缓存空了后receive才会阻塞。一个nil channel不会通信。 可以通过内建的close方法可以关闭Channel。 你可以在多个goroutine从/往 一个channel 中 receive/send 数据, 不必考虑额外的同步措施。 Channel可以作为一个先入先出(FIFO)的队列，接收的数据和发送的数据的顺序是一致的。 channel的 receive支持 multi-valued assignment，如 1v, ok := &lt;-ch 它可以用来检查Channel是否已经被关闭了。 send语句send语句用来往Channel中发送数据， 如ch &lt;- 3。它的定义如下: 12SendStmt = Channel &quot;&lt;-&quot; Expression .Channel = Expression . 在通讯(communication)开始前channel和expression必选先求值出来(evaluated)，比如下面的(3+4)先计算出7然后再发送给channel。 12345c := make(chan int)defer close(c)go func() &#123; c &lt;- 3 + 4 &#125;()i := &lt;-cfmt.Println(i) send被执行前(proceed)通讯(communication)一直被阻塞着。如前所言，无缓存的channel只有在receiver准备好后send才被执行。如果有缓存，并且缓存未满，则send会被执行。 往一个已经被close的channel中继续发送数据会导致run-time panic。 往nil channel中发送数据会一致被阻塞着。 ​ receive 操作符&lt;-ch用来从channel ch中接收数据，这个表达式会一直被block,直到有数据可以接收。 从一个nil channel中接收数据会一直被block。 从一个被close的channel中接收数据不会被阻塞，而是立即返回，接收完已发送的数据后会返回元素类型的零值(zero value)。 如前所述，你可以使用一个额外的返回参数来检查channel是否关闭。 123x, ok := &lt;-chx, ok = &lt;-chvar x, ok = &lt;-ch 如果OK 是false，表明接收的x是产生的零值，这个channel被关闭了或者为空。 blocking 默认情况下，发送和接收会一直阻塞着，直到另一方准备好。这种方式可以用来在gororutine中进行同步，而不必使用显示的锁或者条件变量。 如官方的例子中x, y := &lt;-c, &lt;-c这句会一直等待计算结果发送到channel中。 12345678910111213141516import &quot;fmt&quot;func sum(s []int, c chan int) &#123; sum := 0 for _, v := range s &#123; sum += v &#125; c &lt;- sum // send sum to c&#125;func main() &#123; s := []int&#123;7, 2, 8, -9, 4, 0&#125; c := make(chan int) go sum(s[:len(s)/2], c) go sum(s[len(s)/2:], c) x, y := &lt;-c, &lt;-c // receive from c fmt.Println(x, y, x+y)&#125; Buffered channels Range select timeout Timer and Ticker close 同步 开发工具 其他： 符号… https://blog.csdn.net/jeffrey11223/article/details/79166724 package作用以及定义 https://www.jianshu.com/p/df33ee0d51ce go test 测试","categories":[{"name":"golang","slug":"golang","permalink":"https://hxlpub.github.io/categories/golang/"}],"tags":[{"name":"golang","slug":"golang","permalink":"https://hxlpub.github.io/tags/golang/"}]},{"title":"Makefile","slug":"Makefile","date":"2021-11-09T11:56:07.000Z","updated":"2022-03-26T09:11:58.775Z","comments":true,"path":"2021/11/09/Makefile/","link":"","permalink":"https://hxlpub.github.io/2021/11/09/Makefile/","excerpt":"","text":"​","categories":[{"name":"编译","slug":"编译","permalink":"https://hxlpub.github.io/categories/%E7%BC%96%E8%AF%91/"}],"tags":[{"name":"Makefile","slug":"Makefile","permalink":"https://hxlpub.github.io/tags/Makefile/"}]},{"title":"1.C++_构建知识体系","slug":"cplusplus","date":"2021-11-06T03:55:07.000Z","updated":"2022-05-09T11:14:30.292Z","comments":true,"path":"2021/11/06/cplusplus/","link":"","permalink":"https://hxlpub.github.io/2021/11/06/cplusplus/","excerpt":"","text":"本文目的回顾并构建c++ 知识体系 语言特性 静态类型的、编译式的、通用的、大小写敏感的、不规则的编程语言，支持过程化编程、面向对象编程和泛型编程。（使用静态类型的编程语言是在编译时执行类型检查，而不是在运行时执行类型检查。） 面向对象的特性： 封装 抽象 继承 多态 标准库 ​ 标准的 C++ 由三个重要部分组成： 核心语言，提供了所有构件块，包括变量、数据类型和常量，等等。 C++ 标准库，提供了大量的函数，用于操作文件、字符串等。 标准模板库（STL），提供了大量的方法，用于操作数据结构等。 C++ 通常用于编写设备驱动程序和其他要求实时性的直接操作硬件的软件。 C++ 广泛用于教学和研究。 任何一个使用苹果电脑或 Windows PC 机的用户都在间接地使用 C++，因为这些系统的主要用户接口是使用 C++ 编写的。 基本语法 C++ 程序可以定义为对象的集合，这些对象通过调用彼此的方法进行交互 对象 - 对象具有状态和行为。例如：一只狗的状态 - 颜色、名称、品种，行为 - 摇动、叫唤、吃。对象是类的实例。 类 - 类可以定义为描述对象行为/状态的模板/蓝图。 方法 - 从基本上说，一个方法表示一种行为。一个类可以包含多个方法。可以在方法中写入逻辑、操作数据以及执行所有的动作。 即时变量 - 每个对象都有其独特的即时变量。对象的状态是由这些即时变量的值创建的。 分号是语句结束符。也就是说，每个语句必须以分号结束。它表明一个逻辑实体的结束。 语句块是一组使用大括号括起来的按逻辑连接的语句。 不以行末作为结束符的标识，因此，您可以在一行上放置多个语句。 1x = y; y = y+1; add(x, y); 标识符 C++ 标识符是用来标识变量、函数、类、模块，或任何其他用户自定义项目的名称。 一个标识符以字母 A-Z 或 a-z 或下划线 _ 开始，后跟零个或多个字母、下划线和数字（0-9）。 C++ 标识符内不允许出现标点字符，比如 @、&amp; 和 %。 大小写敏感 关键字 https://www.runoob.com/w3cnote/cpp-keyword-intro.html asm else new this auto enum operator throw bool explicit private true break export protected try case extern public typedef catch false register typeid char float reinterpret_cast typename class for return union const friend short unsigned const_cast goto signed using continue if sizeof virtual default inline static void delete int static_cast volatile do long struct wchar_t double mutable switch while dynamic_cast namespace template 注释 C++ 注释一般有两种： // - 一般用于单行注释。 /*** … */** - 一般用于多行注释。 数据类型 基本内置类型 类型 关键字 布尔型 bool 字符型 char 整型 int 浮点型 float 双浮点型 double 无类型 void 宽字符型 wchar_t 一些基本类型可以使用一个或多个类型修饰符进行修饰： signed unsigned short long 各种变量类型在内存中存储值时需要占用的内存，以及该类型的变量所能存储的最大值和最小值。 注意：不同系统会有所差异，一字节为 8 位，各种类型的存储大小与系统位数有关。 注意：默认情况下，int、short、long都是带符号的，即 signed。 注意：long int 8 个字节，int 都是 4 个字节，早期的 C 编译器定义了 long int 占用 4 个字节，int 占用 2 个字节，新版的 C/C++ 标准兼容了早期的这一设定。 typedef声明 为已有类型取一个新名字 语法：typedef type newname 例子：typedef int newint; ​ newint a; 枚举类型 派生数据类型，它是由用户定义的若干枚举常量的集合。 如果一个变量只有几种可能的值，可以定义为枚举(enumeration)类型。所谓”枚举”是指将变量的值一一列举出来，变量的值只能在列举出来的值的范围内。 语法： 123456enum 枚举名&#123; 标识符[=整型常数]， 标识符[=整型常数]， ... 标识符[=整型常数]&#125; 枚举变量; 实例： 12345678#定义一个颜色枚举变量cenum color &#123; red, orange, white&#125; c;#赋值 redc = red; 说明： 如果枚举不初始化（=整型常数），默认从第一个开始，第一个名称为0，第二个为1，…依次类推。 默认，后一个名称总比前面一个大1，但给某个名称手动赋值后，其后名称值会顺延,前面按默认值。 例子： 12#red = 0 bule=6enum color &#123; red, green=5, bule&#125;; 变量类型 不带初始化的定义：带有静态存储持续时间的变量会被隐式初始化为 NULL（所有字节的值都是 0），其他所有变量的初始值是未定义的。 变量声明 变量声明向编译器保证变量以给定的类型和名称存在，这样编译器在不需要知道变量完整细节的情况下也能继续进一步的编译。 变量声明只在编译时有它的意义，在程序连接时编译器需要实际的变量声明。 当您使用多个文件且只在其中一个文件中定义变量时（定义变量的文件在程序连接时是可用的），变量声明就显得非常有用。您可以使用 extern 关键字在任何地方声明一个变量。 可以在 C++ 程序中多次声明一个变量，但变量只能在某个文件、函数或代码块中被定义一次。 同样的，在函数声明时，提供一个函数名，而函数的实际定义则可以在任何地方进行。 变量作用域 作用域是程序的一个区域，一般来说有三个地方可以定义变量： 在函数或一个代码块内部声明的变量，称为局部变量。 在函数参数的定义中声明的变量，称为形式参数。 在所有函数外部声明的变量，称为全局变量。 在程序中，局部变量和全局变量的名称可以相同，但是在函数内，局部变量的值会覆盖全局变量的值。 初始化 当局部变量被定义时，系统不会对其初始化，您必须自行对其初始化。 定义全局变量时，系统会自动初始化为下列值： 数据类型 初始化默认值 int 0 char ‘\\0’ float 0 double 0 pointer NULL 常量 定义 在 C++ 中，有两种简单的定义常量的方式： 使用 #define 预处理器。 格式：#define identifier value 例子：#define LENGTH 10(把常量定义为大写字母形式，是一个很好的编程实践。) 使用 const 关键字。 修饰符类型 C++ 允许在 char、int 和 double 数据类型前放置修饰符。 修饰符用于改变基本类型的含义，所以它更能满足各种情境的需求。 下面列出了数据类型修饰符： signed （可修饰整型、字符型，也可修饰long\\short） unsigned（可修饰整型、字符型，也可修饰long\\short） long（可修饰双精度型） short（可修饰整型） 允许使用速记符号来声明无符号短整数或无符号长整数。您可以不写 int，只写单词 unsigned、short 或 long，int 是隐含的。 ​ 例子： 12unsigned x;unsigned int y; 类型限定符 限定符 含义 const const 类型的对象在程序执行期间不能被修改改变。 volatile 修饰符 volatile 告诉编译器不需要优化volatile声明的变量，让程序可以直接从内存中读取变量。对于一般的变量编译器会对变量进行优化，将内存中的变量值放在寄存器中以加快读写效率。 restrict 由 restrict 修饰的指针是唯一一种访问它所指向的对象的方式。只有 C99 增加了新的类型限定符 restrict。 存储类 存储类定义 C++ 程序中变量/函数的范围（可见性）和生命周期。这些说明符放置在它们所修饰的类型之前。下面列出 C++ 程序中可用的存储类： auto 自 C++ 11 以来，auto 关键字用于两种情况：声明变量时根据初始化表达式自动推断该变量的类型、声明函数时函数返回值的占位符。 例子： 1234auto f=3.14; //doubleauto s(&quot;hello&quot;); //const char*auto z = new auto(9); // int*auto x1 = 5, x2 = 5.0, x3=&#x27;r&#x27;;//错误，必须是初始化为同一类型 register register 存储类用于定义存储在寄存器中而不是 RAM 中的局部变量。这意味着变量的最大尺寸等于寄存器的大小（通常是一个词），且不能对它应用一元的 ‘&amp;’ 运算符（因为它没有内存位置）。 123&#123; register int miles;&#125; 寄存器只用于需要快速访问的变量，比如计数器。还应注意的是，定义 ‘register’ 并不意味着变量将被存储在寄存器中，它意味着变量可能存储在寄存器中，这取决于硬件和实现的限制。 static static 存储类指示编译器在程序的生命周期内保持局部变量的存在，而不需要在每次它进入和离开作用域时进行创建和销毁。因此，使用 static 修饰局部变量可以在函数调用之间保持局部变量的值。 static 修饰符也可以应用于全局变量。当 static 修饰全局变量时，会使变量的作用域限制在声明它的文件内。 在 C++ 中，当 static 用在类数据成员上时，会导致仅有一个该成员的副本被类的所有对象共享。 extern extern 存储类用于提供一个全局变量的引用，全局变量对所有的程序文件都是可见的。当您使用 ‘extern’ 时，对于无法初始化的变量，会把变量名指向一个之前定义过的存储位置。 当您有多个文件且定义了一个可以在其他文件中使用的全局变量或函数时，可以在其他文件中使用 extern 来得到已定义的变量或函数的引用。可以这么理解，extern 是用来在另一个文件中声明一个全局变量或函数。 extern 修饰符通常用于当有两个或多个文件共享相同的全局变量或函数的时候 mutable mutable 说明符仅适用于类的对象。 它允许对象的成员替代常量。也就是说，mutable 成员可以通过 const 成员函数修改。 thread_local (C++11) 使用 thread_local 说明符声明的变量仅可在它在其上创建的线程上访问。 变量在创建线程时创建，并在销毁线程时销毁。 每个线程都有其自己的变量副本。 thread_local 说明符可以与 static 或 extern 合并。 可以将 thread_local 仅应用于数据声明和定义，thread_local 不能用于函数声明或定义。 以下演示了可以被声明为 thread_local 的变量： 1234567891011thread_local int x; // 命名空间下的全局变量class X&#123; static thread_local std::string s; // 类的static成员变量&#125;;static thread_local std::string X::s; // X::s 是需要定义的 void foo()&#123; thread_local std::vector&lt;int&gt; v; // 本地变量&#125; 从 C++ 17 开始，auto 关键字不再是 C++ 存储类说明符，且 register 关键字被弃用。 运算符 运算符是一种告诉编译器执行特定的数学或逻辑操作的符号。C++ 内置了丰富的运算符，并提供了以下类型的运算符： 算术运算符 运算符 描述 实例 + 把两个操作数相加 A + B 将得到 30 - 从第一个操作数中减去第二个操作数 A - B 将得到 -10 * 把两个操作数相乘 A * B 将得到 200 / 分子除以分母 B / A 将得到 2 % 取模运算符，整除后的余数 B % A 将得到 0 ++ 自增运算符，整数值增加 1 A++ 将得到 11 – 自减运算符，整数值减少 1 A– 将得到 9 关系运算符 运算符 描述 实例 == 检查两个操作数的值是否相等，如果相等则条件为真。 (A == B) 不为真。 != 检查两个操作数的值是否相等，如果不相等则条件为真。 (A != B) 为真。 &gt; 检查左操作数的值是否大于右操作数的值，如果是则条件为真。 (A &gt; B) 不为真。 &lt; 检查左操作数的值是否小于右操作数的值，如果是则条件为真。 (A &lt; B) 为真。 &gt;= 检查左操作数的值是否大于或等于右操作数的值，如果是则条件为真。 (A &gt;= B) 不为真。 &lt;= 检查左操作数的值是否小于或等于右操作数的值，如果是则条件为真。 (A &lt;= B) 为真。 逻辑运算符 运算符 描述 实例 &amp;&amp; 称为逻辑与运算符。如果两个操作数都 true，则条件为 true。 (A &amp;&amp; B) 为 false。 || 称为逻辑或运算符。如果两个操作数中有任意一个 true，则条件为 true。 (A || B) 为 true。 ! 称为逻辑非运算符。用来逆转操作数的逻辑状态，如果条件为 true 则逻辑非运算符将使其为 false。 !(A &amp;&amp; B) 为 true。 位运算符 p q p &amp; q p | q p ^ q 0 0 0 0 0 0 1 0 1 1 1 1 1 1 0 1 0 0 1 1 ~、&lt;&lt;、&gt;&gt;运算，其中 ~ 取反运算符，按二进制位进行”取反”运算。运算规则：~1=-2; ~0=-1; (~A ) 将得到 -61，即为 1100 0011，一个有符号二进制数的补码形式。（此处有错） 赋值运算符 运算符 描述 实例 = 简单的赋值运算符，把右边操作数的值赋给左边操作数 C = A + B 将把 A + B 的值赋给 C += 加且赋值运算符，把右边操作数加上左边操作数的结果赋值给左边操作数 C += A 相当于 C = C + A -= 减且赋值运算符，把左边操作数减去右边操作数的结果赋值给左边操作数 C -= A 相当于 C = C - A *= 乘且赋值运算符，把右边操作数乘以左边操作数的结果赋值给左边操作数 C *= A 相当于 C = C * A /= 除且赋值运算符，把左边操作数除以右边操作数的结果赋值给左边操作数 C /= A 相当于 C = C / A %= 求模且赋值运算符，求两个操作数的模赋值给左边操作数 C %= A 相当于 C = C % A &lt;&lt;= 左移且赋值运算符 C &lt;&lt;= 2 等同于 C = C &lt;&lt; 2 &gt;&gt;= 右移且赋值运算符 C &gt;&gt;= 2 等同于 C = C &gt;&gt; 2 &amp;= 按位与且赋值运算符 C &amp;= 2 等同于 C = C &amp; 2 ^= 按位异或且赋值运算符 C ^= 2 等同于 C = C ^ 2 |= 杂项运算符 运算符 描述 sizeof sizeof 运算符返回变量的大小。例如，sizeof(a) 将返回 4，其中 a 是整数。 Condition ? X : Y 条件运算符。如果 Condition 为真 ? 则值为 X : 否则值为 Y。 , 逗号运算符会顺序执行一系列运算。整个逗号表达式的值是以逗号分隔的列表中的最后一个表达式的值。 .（点）和 -&gt;（箭头） 成员运算符用于引用类、结构和共用体的成员。 Cast 强制转换运算符把一种数据类型转换为另一种数据类型。例如，int(2.2000) 将返回 2。 &amp; 指针运算符 &amp; 返回变量的地址。例如 &a; 将给出变量的实际地址。 * 指针运算符 * 指向一个变量。例如，*var; 将指向变量 var。 优先级 类别 运算符 结合性 后缀 () [] -&gt; . ++ - - 从左到右 一元 + - ! ~ ++ - - (type)* &amp; sizeof 从右到左 乘除 * / % 从左到右 加减 + - 从左到右 移位 &lt;&lt; &gt;&gt; 从左到右 关系 &lt; &lt;= &gt; &gt;= 从左到右 相等 == != 从左到右 位与 AND &amp; 从左到右 位异或 XOR ^ 从左到右 位或 OR | 从左到右 逻辑与 AND &amp;&amp; 从左到右 逻辑或 OR || 从左到右 条件 ?: 从右到左 赋值 = += -= *= /= %=&gt;&gt;= &lt;&lt;= &amp;= ^= |= 从右到左 逗号 , 从左到右 循环 循环类型 描述 while 循环 当给定条件为真时，重复语句或语句组。它会在执行循环主体之前测试条件。 for 循环 多次执行一个语句序列，简化管理循环变量的代码。 do…while 循环 除了它是在循环主体结尾测试条件外，其他与 while 语句类似。 嵌套循环 您可以在 while、for 或 do..while 循环内使用一个或多个循环。 控制语句 描述 break 语句 终止 loop 或 switch 语句，程序流将继续执行紧接着 loop 或 switch 的下一条语句。 continue 语句 引起循环跳过主体的剩余部分，立即重新开始测试条件。 goto 语句 将控制转移到被标记的语句。但是不建议在程序中使用 goto 语句。 判断 语句 描述 if 语句 一个 if 语句 由一个布尔表达式后跟一个或多个语句组成。 if…else 语句 一个 if 语句 后可跟一个可选的 else 语句，else 语句在布尔表达式为假时执行。 嵌套 if 语句 您可以在一个 if 或 else if 语句内使用另一个 if 或 else if 语句。 switch 语句 一个 switch 语句允许测试一个变量等于多个值时的情况。 嵌套 switch 语句 您可以在一个 switch 语句内使用另一个 switch 语句。 ？：运算符 格式：Exp1 ? Exp2 : Exp3; 函数 当调用函数时，有三种向函数传递参数的方式： 调用类型 描述 传值调用 该方法把参数的实际值赋值给函数的形式参数。在这种情况下，修改函数内的形式参数对实际参数没有影响。 指针调用 该方法把参数的地址赋值给形式参数。在函数内，该地址用于访问调用中要用到的实际参数。这意味着，修改形式参数会影响实际参数。 引用调用 该方法把参数的引用赋值给形式参数。在函数内，该引用用于访问调用中要用到的实际参数。这意味着，修改形式参数会影响实际参数。 参数默认值 定义一个函数，可以为参数列表中后边的每一个参数指定默认值。当调用函数时，如果实际参数的值留空，则使用这个默认值。如果指定了值，则会忽略默认值，使用传递的值。 例子： 12345int sum(int a, int b=20) &#123; int result; result = a + b; return (result); &#125;result = sum(a, b);//a+b，a,b均使用传递值cout &lt;&lt; &quot;Total value is :&quot; &lt;&lt; result &lt;&lt; endl;result = sum(a);//a+20cout &lt;&lt; &quot;Total value is :&quot; &lt;&lt; result &lt;&lt; endl; lambda函数表达式 C++11 提供了对匿名函数的支持,称为 Lambda 函数(也叫 Lambda 表达式)。 Lambda 表达式把函数看作对象。Lambda 表达式可以像对象一样使用，比如可以将它们赋给变量和作为参数传递，还可以像函数一样对其求值。 Lambda 表达式本质上与函数声明非常类似。 Lambda 表达式具体形式如下: 12[capture](parameters)-&gt;return-type&#123;body&#125;[capture](parameters)&#123;body&#125;//无返回值，则 例子： 123[](int x, int y)&#123; return x &lt; y ; &#125;//无返回值[]&#123; ++global_x; &#125; //无输入参数和返回值[](int x, int y) -&gt; int &#123; int z = x + y; return z + x; &#125;//既有输入又有返回值 在Lambda表达式内可以访问当前作用域的变量，这是Lambda表达式的闭包（Closure）行为。 与JavaScript闭包不同，C++变量传递有传值和传引用的区别。可以通过前面的[]来指定： 123456[] // 沒有定义任何变量。使用未定义变量会引发错误。[x, &amp;y] // x以传值方式传入（默认），y以引用方式传入。[&amp;] // 任何被使用到的外部变量都隐式地以引用方式加以引用。[=] // 任何被使用到的外部变量都隐式地以传值方式加以引用。[&amp;, x] // x显式地以传值方式加以引用。其余变量以引用方式加以引用。[=, &amp;z] // z显式地以引用方式加以引用。其余变量以传值方式加以引用。 外有一点需要注意。对于[=]或[&amp;]的形式，lambda 表达式可以直接使用 this 指针。但是，对于[]的形式，如果要使用 this 指针，必须显式传入： 1[this]() &#123; this-&gt;someFunc(); &#125;(); 数字 内置数学运算函数，#include 随机数 关于随机数生成器，有两个相关的函数。 一个是 **rand()**，该函数只返回一个伪随机数。 生成随机数之前必须先调用 srand() 函数。#设置种子 1234567891011121314151617181920212223#include &lt;iostream&gt;#include &lt;ctime&gt;#include &lt;cstdlib&gt; using namespace std; int main ()&#123; int i,j; // 设置种子 srand( (unsigned)time( NULL ) ); /* 生成 10 个随机数 */ for( i = 0; i &lt; 10; i++ ) &#123; // 生成实际的随机数 j= rand(); cout &lt;&lt;&quot;随机数： &quot; &lt;&lt; j &lt;&lt; endl; &#125; return 0;&#125; 数组 声明 12type arrayName [ arraySize ];例1：int arr[10]; 初始化 123double balance[5] = &#123;1000.0, 2.0, 3.4, 7.0, 50.0&#125;;//大括号 &#123; &#125; 之间的值的数目不能大于我们在数组声明时在方括号 [ ] 中指定的元素数目。double balance[] = &#123;1000.0, 2.0, 3.4, 7.0, 50.0&#125;;//省略掉了数组的大小，数组的大小则为初始化时元素的个数。balance[4] = 50.0;//单独赋值 访问数组元素 1double salary = balance[9]; 数组详解 概念 描述 多维数组 C++ 支持多维数组。多维数组最简单的形式是二维数组。 指向数组的指针 您可以通过指定不带索引的数组名称来生成一个指向数组中第一个元素的指针。 传递数组给函数 您可以通过指定不带索引的数组名称来给函数传递一个指向数组的指针。 从函数返回数组 C++ 允许从函数返回数组。 字符串 C++ 提供了以下两种类型的字符串表示形式： C 风格字符串 字符串实际上是使用 null 字符 \\0 终止的一维字符数组。因此，一个以 null 结尾的字符串，包含了组成字符串的字符。 1char site[7] = &#123;&#x27;R&#x27;, &#x27;U&#x27;, &#x27;N&#x27;, &#x27;O&#x27;, &#x27;O&#x27;, &#x27;B&#x27;, &#x27;\\0&#x27;&#125;; C++ 中有大量的函数用来操作以 null 结尾的字符串: 序号 函数 &amp; 目的 1 strcpy(s1, s2); 复制字符串 s2 到字符串 s1。 2 strcat(s1, s2); 连接字符串 s2 到字符串 s1 的末尾。连接字符串也可以用 + 号，例如: string str1 = &quot;runoob&quot;; string str2 = &quot;google&quot;; string str = str1 + str2; 3 strlen(s1); 返回字符串 s1 的长度。#字符的数量，不包含后面的’\\0’，而sizeof()是返回字节数 4 strcmp(s1, s2); 如果 s1 和 s2 是相同的，则返回 0；如果 s1&lt;s2 则返回值小于 0；如果 s1&gt;s2 则返回值大于 0。 5 strchr(s1, ch); 返回一个指针，指向字符串 s1 中字符 ch 的第一次出现的位置。 6 strstr(s1, s2); 返回一个指针，指向字符串 s1 中字符串 s2 的第一次出现的位置。 C++ 引入的 string 类类型 C++ 标准库提供了 string 类类型 #include 123456789101112// 复制 str1 到 str3str3 = str1;cout &lt;&lt; &quot;str3 : &quot; &lt;&lt; str3 &lt;&lt; endl; // 连接 str1 和 str2str3 = str1 + str2;cout &lt;&lt; &quot;str1 + str2 : &quot; &lt;&lt; str3 &lt;&lt; endl; // 连接后，str3 的总长度len = str3.size();cout &lt;&lt; &quot;str3.size() : &quot; &lt;&lt; len &lt;&lt; endl; 指针 概念 描述 C++ Null 指针 C++ 支持空指针。NULL 指针是一个定义在标准库中的值为零的常量。 C++ 指针的算术运算 可以对指针进行四种算术运算：++、–、+、- C++ 指针 vs 数组 指针和数组之间有着密切的关系。 C++ 指针数组 可以定义用来存储指针的数组。 C++ 指向指针的指针 C++ 允许指向指针的指针。 C++ 传递指针给函数 通过引用或地址传递参数，使传递的参数在调用函数中被改变。 C++ 从函数返回指针 C++ 允许函数返回指针到局部变量、静态变量和动态内存分配。 引用 引用变量是一个别名，也就是说，它是某个已存在变量的另一个名字。一旦把引用初始化为某个变量，就可以使用该引用名称或变量名称来指向变量。 引用很容易与指针混淆，它们之间有三个主要的不同： 不存在空引用。引用必须连接到一块合法的内存。 一旦引用被初始化为一个对象，就不能被指向到另一个对象。指针可以在任何时候指向到另一个对象。 引用必须在创建时被初始化。指针可以在任何时间被初始化。 创建： 123int i = 17;//为i 声明引用变量rint&amp; r = i;//r是一个初始化为i 的整型引用 引用通常用于函数参数列表和函数返回值。 必须清楚的两个与 C++ 引用相关的重要概念： 概念 描述 把引用作为参数 C++ 支持把引用作为参数传给函数，这比传一般的参数更安全。 把引用作为返回值 可以从 C++ 函数中返回引用，就像返回其他数据类型一样。 日期时间 C++ 标准库没有提供所谓的日期类型。 C++ 继承了 C 语言用于日期和时间操作的结构和函数。 为了使用日期和时间相关的函数和结构，需要在 C++ 程序中引用 头文件。 基本输入输出 C++ 的 I/O 发生在流中，流是字节序列。如果字节流是从设备（如键盘、磁盘驱动器、网络连接等）流向内存，这叫做输入操作。如果字节流是从内存流向设备（如显示屏、打印机、磁盘驱动器、网络连接等），这叫做输出操作。 IO库头文件 头文件 函数和描述 该文件定义了 cin、cout、cerr 和 clog 对象，分别对应于标准输入流、标准输出流、非缓冲标准错误流和缓冲标准错误流。 该文件通过所谓的参数化的流操纵器（比如 setw 和 setprecision），来声明对执行标准化 I/O 有用的服务。 该文件为用户控制的文件处理声明服务。我们将在文件和流的相关章节讨论它的细节。 标准输出流-cout 预定义的对象 cout 是 iostream 类的一个实例。cout 对象”连接”到标准输出设备，通常是显示屏。cout 是与流插入运算符 &lt;&lt; 结合使用的 例子： 12345678910#include &lt;iostream&gt; using namespace std; int main( )&#123; char str[] = &quot;Hello C++&quot;; cout &lt;&lt; &quot;Value of str is : &quot; &lt;&lt; str &lt;&lt; endl;&#125; 标准输入流-cin 预定义的对象 cin 是 iostream 类的一个实例。cin 对象附属到标准输入设备，通常是键盘。cin 是与流提取运算符 &gt;&gt; 结合使用的. 例： 12345678910111213#include &lt;iostream&gt; using namespace std; int main( )&#123; char name[50]; cout &lt;&lt; &quot;请输入您的名称： &quot;; cin &gt;&gt; name; cout &lt;&lt; &quot;您的名称是： &quot; &lt;&lt; name &lt;&lt; endl; &#125; C++ 编译器根据要输入值的数据类型，选择合适的流提取运算符来提取值，并把它存储在给定的变量中。 流提取运算符 &gt;&gt; 在一个语句中可以多次使用，如果要求输入多个数据，可以使用如下语句： 1cin &gt;&gt; name &gt;&gt; age;//相当与cin &gt;&gt; name;cin &gt;&gt; age; 标准错误流 预定义的对象 cerr 是 iostream 类的一个实例。cerr 对象附属到标准输出设备，通常也是显示屏，但是 cerr 对象是非缓冲的，且每个流插入到 cerr 都会立即输出。 cerr 也是与流插入运算符 &lt;&lt; 结合使用的 1234567#include &lt;iostream&gt;using namespace std;int main( )&#123; char str[] = &quot;Unable to read....&quot;; cerr &lt;&lt; &quot;Error message : &quot; &lt;&lt; str &lt;&lt; endl;&#125; 标准日志流 预定义的对象 clog 是 iostream 类的一个实例。clog 对象附属到标准输出设备，通常也是显示屏，但是 clog 对象是缓冲的。这意味着每个流插入到 clog 都会先存储在缓冲区，直到缓冲填满或者缓冲区刷新时才会输出。 clog 也是与流插入运算符 &lt;&lt; 结合使用的 例： 1234567#include &lt;iostream&gt; using namespace std;int main( )&#123; char str[] = &quot;Unable to read....&quot;; clog &lt;&lt; &quot;Error message : &quot; &lt;&lt; str &lt;&lt; endl;&#125; 数据结构 面向对象 类&amp;对象 类定义 定义一个类，本质上是定义一个数据类型的蓝图。这实际上并没有定义任何数据，但它定义了类的名称意味着什么，也就是说，它定义了类的对象包括了什么，以及可以在这个对象上执行哪些操作。 例： 1234567class Box&#123; public: double length; // 盒子的长度 double breadth; // 盒子的宽度 double height; // 盒子的高度&#125;; 对象定义 类提供了对象蓝图。 继承 重载运算符和重载函数 多态 数据抽象 数据封装 接口（抽象类）","categories":[{"name":"cplusplus","slug":"cplusplus","permalink":"https://hxlpub.github.io/categories/cplusplus/"}],"tags":[{"name":"cplusplus","slug":"cplusplus","permalink":"https://hxlpub.github.io/tags/cplusplus/"}]},{"title":"hexo搭建博客","slug":"hexo_build_blog","date":"2021-09-15T13:08:37.000Z","updated":"2022-03-26T08:28:47.664Z","comments":true,"path":"2021/09/15/hexo_build_blog/","link":"","permalink":"https://hxlpub.github.io/2021/09/15/hexo_build_blog/","excerpt":"","text":"2021-10-21–评论系统上线啦！！！ 1.点击页面小爱心","categories":[{"name":"Hexo","slug":"Hexo","permalink":"https://hxlpub.github.io/categories/Hexo/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://hxlpub.github.io/tags/Hexo/"}]},{"title":"golang实现tcp协议","slug":"go_tcp","date":"2021-09-15T07:42:30.000Z","updated":"2022-03-26T08:28:36.809Z","comments":true,"path":"2021/09/15/go_tcp/","link":"","permalink":"https://hxlpub.github.io/2021/09/15/go_tcp/","excerpt":"","text":"1、client端client.go123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475//tcpclient 为client.go所在的上一层目录package tcpclientimport ( &quot;net&quot; &quot;fmt&quot; //&quot;io/ioutil&quot; &quot;strconv&quot; //&quot;../log&quot; //&quot;strings&quot; //&quot;bytes&quot; //&quot;encoding/xml&quot;)//组装tcp请求func RequestMsg(serialNum string, randomNum string, toAddr string, fromAddr string) string &#123; body := &quot;&lt;?xml version=\\&quot;1.0\\&quot;?&gt;\\r\\n&quot; + &quot;&lt;Config&gt;\\r\\n&quot; + &quot;&lt;CmdType&gt;ACTIVE&lt;/CmdType&gt;\\r\\n&quot; + &quot;&lt;CmdInfo&gt;GetActiveInfo&lt;/CmdInfo&gt;\\r\\n&quot; + &quot;&lt;SerialNumInfo&gt;\\r\\n&quot; + &quot;&lt;SerialNum&gt;&quot; + serialNum + &quot;&lt;/SerialNum&gt;\\r\\n&quot; + &quot;&lt;/SerialNumInfo&gt;\\r\\n&quot; + &quot;&lt;/Config&gt;&quot; head := &quot;HIK-PRODUCT\\r\\n&quot; + &quot;Via:HIKSTOR/1.0/TCP\\r\\n&quot; + &quot;From:&quot; + fromAddr + &quot;\\r\\n&quot; + &quot;To:&quot; + toAddr + &quot;\\r\\n&quot; + &quot;Call-ID:&quot; + randomNum + &quot;\\r\\n&quot; + &quot;Content-Type:xml\\r\\n&quot; + &quot;Content-Length:&quot; + strconv.Itoa(len(body)) + &quot;\\r\\n\\r\\n&quot; return head + body //return body&#125;//向server端发起请求func GetBomInfoFromThirdServ(serialNum string,randomNum string, toAddr string, fromAddr string) (string,error) &#123; //主动发起连接请求 conn,err :=net.Dial(&quot;tcp&quot;,&quot;10.192.44.183:35004&quot;) if err != nil &#123; fmt.Println(&quot;dial err&quot;,err) return &quot;&quot;, err &#125; defer conn.Close() //向服务端发送请求 reqmsg := RequestMsg(serialNum,randomNum,toAddr,fromAddr) _, err = conn.Write([]byte(reqmsg)) if err != nil &#123; fmt.Println(&quot;send err=&quot;, err) //出错退出 return &quot;&quot;,err &#125; //接收响应 buf := make([]byte, 1024) //response, err :=ioutil.ReadAll(conn) //if err != nil &#123; // fmt.Println(&quot;rec err&quot;,err) // return &quot;&quot;, err //&#125; n, err :=conn.Read(buf) //fmt.Println(&quot;n=&quot;, n) if err != nil &#123; fmt.Println(&quot;服务器read err=&quot;, err) //出错退出 return &quot;&quot;,err &#125; return string(buf[:n-1]),nil //return buf,nil &#125; 2、server端server.go","categories":[{"name":"golang","slug":"golang","permalink":"https://hxlpub.github.io/categories/golang/"}],"tags":[{"name":"golang","slug":"golang","permalink":"https://hxlpub.github.io/tags/golang/"}]},{"title":"排序","slug":"algorithm","date":"2021-09-14T09:26:07.000Z","updated":"2022-03-26T09:08:17.422Z","comments":true,"path":"2021/09/14/algorithm/","link":"","permalink":"https://hxlpub.github.io/2021/09/14/algorithm/","excerpt":"","text":"1.二分排序 K&amp;R P99","categories":[{"name":"算法","slug":"算法","permalink":"https://hxlpub.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"排序算法","slug":"排序算法","permalink":"https://hxlpub.github.io/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"}]},{"title":"GCC编译","slug":"compile_debug","date":"2021-09-14T09:26:07.000Z","updated":"2022-03-26T07:50:26.967Z","comments":true,"path":"2021/09/14/compile_debug/","link":"","permalink":"https://hxlpub.github.io/2021/09/14/compile_debug/","excerpt":"","text":"​ GCC原名为GNU C语言编译器（GNU C Compiler），只能处理C语言。但其很快扩展，变得可处理C++，后来又扩展为能够支持更多编程语言，如Fortran、Pascal、Objective -C、Java、Ada、Go以及各类处理器架构上的汇编语言等，所以改名GNU编译器套件（GNU Compiler Collection）。 ​ 虽然我们称GCC是C语言的编译器，但使用gcc由C语言源代码文件生成可执行文件的过程不仅仅是编译的过程，而是要经历四个相互关联的步骤∶ ​ 预处理（也称预编译，Preprocessing） ​ 编译（Compilation） ​ 汇编（Assembly） ​ 链接（Linking）","categories":[{"name":"编译","slug":"编译","permalink":"https://hxlpub.github.io/categories/%E7%BC%96%E8%AF%91/"}],"tags":[{"name":"编译","slug":"编译","permalink":"https://hxlpub.github.io/tags/%E7%BC%96%E8%AF%91/"}]},{"title":"编译原理","slug":"compiler","date":"2021-09-14T09:26:07.000Z","updated":"2022-03-26T09:00:17.844Z","comments":true,"path":"2021/09/14/compiler/","link":"","permalink":"https://hxlpub.github.io/2021/09/14/compiler/","excerpt":"","text":"section 1 GCC​ GCC原名为GNU C语言编译器（GNU C Compiler），只能处理C语言。但其很快扩展，变得可处理C++，后来又扩展为能够支持更多编程语言，如Fortran、Pascal、Objective -C、Java、Ada、Go以及各类处理器架构上的汇编语言等，所以改名GNU编译器套件（GNU Compiler Collection）。 ​ 虽然我们称GCC是C语言的编译器，但使用gcc由C语言源代码文件生成可执行文件的过程不仅仅是编译的过程，而是要经历四个相互关联的步骤∶ ​ 预处理（也称预编译，Preprocessing） ​ 编译（Compilation） ​ 汇编（Assembly） ​ 链接（Linking） section2 Makefile概述 什么是makefile？ windows开发IDE为我们做了这部分的工作，而在Linux 端开发，必须要自己写makefile,会不会写makefile，从一个侧面说明了一个人是否具备完成大型工程的能力。会不会写makefile，从一个侧面说明了一个人是否具备完成大型工程的能力。","categories":[{"name":"编译","slug":"编译","permalink":"https://hxlpub.github.io/categories/%E7%BC%96%E8%AF%91/"}],"tags":[{"name":"编译","slug":"编译","permalink":"https://hxlpub.github.io/tags/%E7%BC%96%E8%AF%91/"}]},{"title":"Python之必知必会","slug":"Python","date":"2021-09-14T09:26:07.000Z","updated":"2022-04-06T07:44:13.251Z","comments":true,"path":"2021/09/14/Python/","link":"","permalink":"https://hxlpub.github.io/2021/09/14/Python/","excerpt":"","text":"环境配置import 时找不到模块，修改python sys.path import syssys.path.append(‘/home/daos/site_scons’) 基础语法 编码 默认情况下，Python 3 源码文件以 UTF-8 编码，所有字符串都是 unicode 字符串。 当然你也可以为源码文件指定不同的编码： 1# -*- coding: cp-1252 -*- 标识符 第一个字符必须是字母表中字母或下划线 _ 。 标识符的其他的部分由字母、数字和下划线组成。 标识符对大小写敏感。 在 Python 3 中，可以用中文作为变量名，非 ASCII 标识符也是允许的了。 保留字(关键字) 保留字即关键字，我们不能把它们用作任何标识符名称。Python 的标准库提供了一个 keyword 模块，可以输出当前版本的所有关键字： 12345&gt;&gt;&gt; import keyword&gt;&gt;&gt; keyword.kwlist[&#x27;False&#x27;, &#x27;None&#x27;, &#x27;True&#x27;, &#x27;__peg_parser__&#x27;, &#x27;and&#x27;, &#x27;as&#x27;, &#x27;assert&#x27;, &#x27;async&#x27;, &#x27;await&#x27;, &#x27;break&#x27;, &#x27;class&#x27;, &#x27;continue&#x27;, &#x27;def&#x27;, &#x27;del&#x27;, &#x27;elif&#x27;, &#x27;else&#x27;, &#x27;except&#x27;, &#x27;finally&#x27;, &#x27;for&#x27;, &#x27;from&#x27;, &#x27;global&#x27;, &#x27;if&#x27;, &#x27;import&#x27;, &#x27;in&#x27;, &#x27;is&#x27;, &#x27;lambda&#x27;, &#x27;nonlocal&#x27;, &#x27;not&#x27;, &#x27;or&#x27;, &#x27;pass&#x27;, &#x27;raise&#x27;, &#x27;return&#x27;, &#x27;try&#x27;, &#x27;while&#x27;, &#x27;with&#x27;, &#x27;yield&#x27;]&gt;&gt;&gt; 注释 123456789101112# 单行注释 # print (&quot;Hello, Python!&quot;) # 第二个注释、 # 多行注释 &#x27;&#x27;&#x27;&#x27;注释内容&#x27;&#x27;&#x27; 和&quot;&quot;&quot;注释内容&quot;&quot;&quot; &#x27;&#x27;&#x27; 第三注释 第四注释 &#x27;&#x27;&#x27; &quot;&quot;&quot; 第五注释 第六注释 &quot;&quot;&quot; 行与缩进 python最具特色的就是使用缩进来表示代码块，不需要使用大括号 {} 。 缩进的空格数是可变的，但是同一个代码块的语句必须包含相同的缩进空格数。 12345678910111213if True: print (&quot;Answer&quot;) print (&quot;True&quot;) else: print (&quot;Answer&quot;) print (&quot;False&quot;) # 缩进不一致，会导致运行错误 root@192 python]# python test.py File &quot;/home/tests/python/test.py&quot;, line 14 print (&quot;False&quot;) ^ IndentationError: unindent does not match any outer indentation level 多行语句 Python 通常是一行写完一条语句，但如果语句很长，我们可以使用反斜杠 ** 来实现多行语句，例如： 123total = item_one + \\ item_two + \\ item_three 在 [], {}, 或 () 中的多行语句，不需要使用反斜杠 ****，例如： 12total = [&#x27;item_one&#x27;, &#x27;item_two&#x27;, &#x27;item_three&#x27;, &#x27;item_four&#x27;, &#x27;item_five&#x27;] 数字类型 int (整数), 如 1, 只有一种整数类型 int，表示为长整型，没有 python2 中的 Long。 bool (布尔), 如 True。 float (浮点数), 如 1.23、3E-2 complex (复数), 如 1 + 2j、 1.1 + 2.2j 字符串 Python 中单引号 ‘ 和双引号 “ 使用完全相同。 使用三引号(‘’’ 或 “””)可以指定一个多行字符串。 转义符 ****。 反斜杠可以用来转义，使用 r 可以让反斜杠不发生转义。 如 r”this is a line with \\n” 则 \\n 会显示，并不是换行。 按字面意义级联字符串，如 “this “ “is “ “string” 会被自动转换为 this is string。 字符串可以用 + 运算符连接在一起，用 ***** 运算符重复。 Python 中的字符串有两种索引方式，从左往右以 0 开始，从右往左以 -1 开始。 Python 中的字符串不能改变。 Python 没有单独的字符类型，一个字符就是长度为 1 的字符串。 字符串的截取的语法格式如下：变量[头下标:尾下标:步长] 12345678910111213141516171819202122232425262728293031323334word = &#x27;字符串&#x27; sentence = &quot;这是一个句子。&quot; paragraph = &quot;&quot;&quot;这是一个段落， 可以由多行组成&quot;&quot;&quot; #!/usr/bin/python3 str=&#x27;123456789&#x27; print(str) # 输出字符串 print(str[0:-1]) # 输出第一个到倒数第二个的所有字符 print(str[0]) # 输出字符串第一个字符 print(str[2:5]) # 输出从第三个开始到第五个的字符 print(str[2:]) # 输出从第三个开始后的所有字符 print(str[1:5:2]) # 输出从第二个开始到第五个且每隔一个的字符（步长为2） print(str * 2) # 输出字符串两次 print(str + &#x27;你好&#x27;) # 连接字符串 print(&#x27;------------------------------&#x27;) print(&#x27;hello\\nrunoob&#x27;) # 使用反斜杠(\\)+n转义特殊字符 print(r&#x27;hello\\nrunoob&#x27;) # 在字符串前面添加一个 r，表示原始字符串，不会发生转义 123456789 12345678 1 345 3456789 24 123456789123456789 123456789你好 ------------------------------ hello runoob hello\\nrunoob 空行 函数之间或类的方法之间用空行分隔，表示一段新的代码的开始。类和函数入口之间也用一行空行分隔，以突出函数入口的开始。 空行与代码缩进不同，空行并不是 Python 语法的一部分。书写时不插入空行，Python 解释器运行也不会出错。但是空行的作用在于分隔两段不同功能或含义的代码，便于日后代码的维护或重构。 记住：空行也是程序代码的一部分。 等待用户输入 1234567input(&quot;\\n\\n按下 enter 键后退出。&quot;) [root@192 python]# python test.py True press enter to exit 同一行显示多条语句 在同一行中使用多条语句，语句之间使用分号 ; 分割 1import sys; x = &#x27;runoob&#x27;; sys.stdout.write(x + &#x27;\\n&#x27;) 多个语句构成代码组 缩进相同的一组语句构成一个代码块，我们称之代码组。 像if、while、def和class这样的复合语句，首行以关键字开始，以冒号( : )结束，该行之后的一行或多行代码构成代码组。 我们将首行及后面的代码组称为一个子句(clause)。 123456if expression : suite elif expression : suite else : suite print print 默认输出是换行的，如果要实现不换行需要在变量末尾加上 **end=””**： 123456789101112131415161718#!/usr/bin/python3 x=&quot;a&quot; y=&quot;b&quot; # 换行输出 print( x ) print( y ) print(&#x27;---------&#x27;) # 不换行输出 print( x, end=&quot; &quot; ) print( y, end=&quot; &quot; ) print() a b --------- a b import 与 from … import 在 python 用 import 或者 from…import 来导入相应的模块。 将整个模块(somemodule)导入，格式为： import somemodule 从某个模块中导入某个函数,格式为： from somemodule import somefunction 从某个模块中导入多个函数,格式为： from somemodule import firstfunc, secondfunc, thirdfunc 将某个模块中的全部函数导入，格式为： from somemodule import * 1234567891011#导入sys 模块 import sys print(&#x27;================Python import mode==========================&#x27;) print (&#x27;命令行参数为:&#x27;) for i in sys.argv: print (i) print (&#x27;\\n python 路径为&#x27;,sys.path) #导入sys模块的argv 和path成员 from sys import argv,path # 导入特定的成员 print(&#x27;================python from import===================================&#x27;) print(&#x27;path:&#x27;,path) # 因为已经导入path成员，所以此处引用时不需要加sys.path 命令行参数 稍后补充 基本数据类型 变量不需要声明。每个变量在使用前都必须赋值，变量赋值以后该变量才会被创建。 变量就是变量，它没有类型，我们所说的”类型”是变量所指的内存中对象的类型。 12345678#!/usr/bin/python3counter = 100 # 整型变量miles = 1000.0 # 浮点型变量name = &quot;runoob&quot; # 字符串print (counter)print (miles)print (name) 多变量赋值 12a = b = c = 1a, b, c = 1, 2, &quot;hello&quot; 标准数据类型 python3 中有6中标准数据类型： Number（数字） String（字符串） List（列表） Tuple（元组） Set（集合） Dictionary（字典） 不可变数据（3 个）：Number（数字）、String（字符串）、Tuple（元组）； 可变数据（3 个）：List（列表）、Dictionary（字典）、Set（集合）。 Number Python3 支持 int、float、bool、complex（复数）。 内置的 type() 函数可以用来查询变量所指的对象类型。 123&gt;&gt;&gt; a, b, c, d = 20, 5.5, True, 4+3j&gt;&gt;&gt; print(type(a), type(b), type(c), type(d))&lt;class &#x27;int&#x27;&gt; &lt;class &#x27;float&#x27;&gt; &lt;class &#x27;bool&#x27;&gt; &lt;class &#x27;complex&#x27;&gt; 还可以用 isinstance 来判断： 1234&gt;&gt;&gt; a = 111&gt;&gt;&gt; isinstance(a, int)True&gt;&gt;&gt; isinstance 和 type 的区别在于： type()不会认为子类是一种父类类型。 isinstance()会认为子类是一种父类类型。 123456789101112131415161718192021222324252627282930&gt;&gt;&gt; class A:... pass... &gt;&gt;&gt; class B(A):... pass... &gt;&gt;&gt; isinstance(A(), A)True&gt;&gt;&gt; type(A()) == A True&gt;&gt;&gt; isinstance(B(), A)True&gt;&gt;&gt; type(B()) == AFalse注意：Python3 中，bool 是 int 的子类，True 和 False 可以和数字相加， True==1、False==0 会返回 True，但可以通过 is 来判断类型。&gt;&gt;&gt; issubclass(bool, int) True&gt;&gt;&gt; True==1True&gt;&gt;&gt; False==0True&gt;&gt;&gt; True+12&gt;&gt;&gt; False+11&gt;&gt;&gt; 1 is TrueFalse&gt;&gt;&gt; 0 is FalseFalse 使用del语句删除单个或多个对象。例如： 12del vardel var_a, var_b 数值运算 1234567891011121314&gt;&gt;&gt; 5 + 4 # 加法9&gt;&gt;&gt; 4.3 - 2 # 减法2.3&gt;&gt;&gt; 3 * 7 # 乘法21&gt;&gt;&gt; 2 / 4 # 除法，得到一个浮点数0.5&gt;&gt;&gt; 2 // 4 # 除法，得到一个整数0&gt;&gt;&gt; 17 % 3 # 取余2&gt;&gt;&gt; 2 ** 5 # 乘方32 String 使用单引号’’或双引号””将字符串括起来，并使用\\转义特殊字符 反斜杠()可以作为续行符，表示下一行是上一行的延续。也可以使用 “””…””” 或者 ‘’’…’’’ 跨越多行 字符串的截取格式：变量[头下标:尾下标] 从前索引：索引值从0开始 从后索引：索引值从-1开始 +：字符串连接符 *数字：复制当前字符串，数字是复制的次数 实例 12345678910111213141516171819202122# -*- coding: utf-8 -*-#!/usr/bin/python3.6str = &#x27;string&#x27;print(str) print(str[0:-1]) #打印第一个到倒数第二个字符print(str[0]) print(str[2:5]) #第三个到第五个，注意与上面的[0:-1]有区别print(str*2) print(str+&#x27;TEST&#x27;)print(&#x27;stri\\ng&#x27;)print(r&#x27;stri\\ng&#x27;)[root@192 python]# python data_type.py stringstrinsrinstringstringstringTESTstrigstri\\ng List 使用最频繁的数据类型 列表中元素的类型可以不相同，它支持数字，字符串甚至可以包含列表（所谓嵌套）。 1、List写在方括号之间，元素用逗号隔开。 2、和字符串一样，list可以被索引和切片。 3、List可以使用+操作符进行拼接。 4、List中的元素是可以改变的。 123变量[头下标:尾下标] 也可以 变量[头下标:尾下标:步长]索引值以 0 为开始值，-1 为从末尾的开始位置。 实例1 1234567891011121314151617181920212223242526272829list = [&#x27;a&#x27;, 1, 2.3, 4.56]tinylist = [&#x27;123&#x27;, &#x27;tinylist&#x27;]print(list)print(list[0])print(list[1:3])print(list[2:])print(tinylist*2)print(list+tinylist)list[0] = 9print(list)list[1:3] = [8, 7]print(list)list[3:]=[]print(list)list.append(6)print(list)print(list[0:3:2])[root@192 python]# python data_type.py [&#x27;a&#x27;, 1, 2.3, 4.56]a[1, 2.3][2.3, 4.56][&#x27;123&#x27;, &#x27;tinylist&#x27;, &#x27;123&#x27;, &#x27;tinylist&#x27;][&#x27;a&#x27;, 1, 2.3, 4.56, &#x27;123&#x27;, &#x27;tinylist&#x27;][9, 1, 2.3, 4.56][9, 8, 7, 4.56][9, 8, 7][9, 8, 7, 6][9, 7] List 内置了很多方法，如append()、pop()等 实例2 字符翻转 123456789101112def reverserWords(input): inputWords = input.split(&#x27; &#x27;) inputWords = inputWords[-1::-1] output = &#x27; &#x27;.join(inputWords) return outputif __name__ == &quot;__main__&quot;: input = &#x27;I like you&#x27; rw = reverserWords(input) print(rw) 元组 1、与字符串一样，元组的元素不能修改。 虽然tuple的元素不可改变，但它可以包含可变的对象，比如list列表。 2、元组也可以被索引和切片，方法一样。 3、注意构造包含 0 或 1 个元素的元组的特殊语法规则。 12tup1 = () # 空元组tup2 = (20,) # 一个元素，需要在元素后添加逗号 4、元组也可以使用+操作符进行拼接。 5、 Set 集合 集合（set）是由一个或数个形态各异的大小整体组成的，构成集合的事物或对象称作元素或是成员。 基本功能是进行成员关系测试和删除重复元素。 创建格式：注意创建一个空集，必须用set() 而不能用{}（因为{}是用来创建一个空字典） 123parame = &#123;value1, value2, ...&#125;或者set(value) 实例 1234567891011121314151617181920212223242526#setsites = &#123;&#x27;google&#x27;, &#x27;baidu&#x27;, &#x27;ali&#x27;&#125;print(sites)if &#x27;ali&#x27; in sites: print(&#x27;ali in sites&#x27;)else: print(&#x27;ali not in sites &#x27;)#set 集合运算a=set(&#x27;abracadabra&#x27;)b=set(&#x27;alacazam&#x27;)print(a)print(a - b) #差集print(a | b) #并集print(a &amp; b) #交集print(a ^ b) #a和b中不同时存在的元素输出：set([&#x27;baidu&#x27;, &#x27;google&#x27;, &#x27;ali&#x27;])ali in sitesset([&#x27;a&#x27;, &#x27;r&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;])set([&#x27;r&#x27;, &#x27;b&#x27;, &#x27;d&#x27;])set([&#x27;a&#x27;, &#x27;c&#x27;, &#x27;b&#x27;, &#x27;d&#x27;, &#x27;m&#x27;, &#x27;l&#x27;, &#x27;r&#x27;, &#x27;z&#x27;])set([&#x27;a&#x27;, &#x27;c&#x27;])set([&#x27;b&#x27;, &#x27;d&#x27;, &#x27;m&#x27;, &#x27;l&#x27;, &#x27;r&#x27;, &#x27;z&#x27;]) Dictionary 1、非常有用的内置数据类型 2、字典是一种映射类型，它的元素是键值对。一个无序的 键(key) : 值(value) 的集合 3、字典的关键字必须为不可变类型，且不能重复。 4、创建空字典使用 { }。 5、在同一个字典中，键(key)必须是唯一的 6、构造函数 dict() 可以直接从键值对序列中构建字典 7、字典类型也有一些内置的函数，例如 clear()、keys()、values() 等。 实例1 12345678910111213141516dict = &#123;&#125;dict[&#x27;one&#x27;] = &#x27;you&#x27;dict[2] = &#x27;me&#x27;tinydict = &#123;&#x27;one&#x27;:&#x27;you&#x27;, &#x27;two&#x27;:&#x27;and&#x27;, &#x27;three&#x27;:&#x27;me&#x27;&#125;print(dict[&#x27;one&#x27;])print(dict[2])print(tinydict.keys())print(tinydict.values())输出：youme[&#x27;three&#x27;, &#x27;two&#x27;, &#x27;one&#x27;][&#x27;me&#x27;, &#x27;and&#x27;, &#x27;you&#x27;] 实例2 123456&gt;&gt;&gt; dict([(&#x27;Runoob&#x27;, 1), (&#x27;Google&#x27;, 2), (&#x27;Taobao&#x27;, 3)])&#123;&#x27;Runoob&#x27;: 1, &#x27;Google&#x27;: 2, &#x27;Taobao&#x27;: 3&#125;&gt;&gt;&gt; &#123;x: x**2 for x in (2, 4, 6)&#125;&#123;2: 4, 4: 16, 6: 36&#125;&gt;&gt;&gt; dict(Runoob=1, Google=2, Taobao=3)&#123;&#x27;Runoob&#x27;: 1, &#x27;Google&#x27;: 2, &#x27;Taobao&#x27;: 3&#125; 数据类型转换Python 数据类型转换可以分为两种： 隐式类型转换 - 自动完成 较低数据类型（整数）就会转换为较高数据类型（浮点数）以避免数据丢失。 显式类型转换 - 需要使用类型函数来转换 在显式类型转换中，用户将对象的数据类型转换为所需的数据类型。 我们使用 int()、float()、str() 等预定义函数来执行显式类型转换。 整型和字符串类型进行运算，就可以用强制类型转换来完成 常用的几个内置函数： 函数 描述 [int(x ,base]) 将x转换为一个整数 float(x) 将x转换到一个浮点数 [complex(real ,imag]) 创建一个复数 str(x) 将对象 x 转换为字符串 repr(x) 将对象 x 转换为表达式字符串 eval(str) 用来计算在字符串中的有效Python表达式,并返回一个对象 tuple(s) 将序列 s 转换为一个元组 list(s) 将序列 s 转换为一个列表 set(s) 转换为可变集合 dict(d) 创建一个字典。d 必须是一个 (key, value)元组序列。 frozenset(s) 转换为不可变集合 chr(x) 将一个整数转换为一个字符 ord(x) 将一个字符转换为它的整数值 hex(x) 将一个整数转换为一个十六进制字符串 oct(x) 推导式Python 推导式是一种独特的数据处理方式，可以从一个数据序列构建另一个新的数据序列的结构体。 Python 支持各种数据结构的推导式： 列表(list)推导式 字典(dict)推导式 集合(set)推导式 元组(tuple)推导式 列表推导式 ​ 推导式格式： 123456789[表达式 for 变量 in 列表] [out_exp_res for out_exp in input_list]或者 [表达式 for 变量 in 列表 if 条件][out_exp_res for out_exp in input_list if condition]说明out_exp_res：列表生成元素表达式，可以是有返回值的函数。for out_exp in input_list：迭代 input_list 将 out_exp 传入到 out_exp_res 表达式中。if condition：条件语句，可以过滤列表中不符合条件的值。 实例1：过滤掉长度小于或等于3的字符串列表，并将剩下的转换成大写字母： 1234&gt;&gt;&gt; names = [&#x27;Bob&#x27;,&#x27;Tom&#x27;,&#x27;alice&#x27;,&#x27;Jerry&#x27;,&#x27;Wendy&#x27;,&#x27;Smith&#x27;]&gt;&gt;&gt; new_names = [name.upper()for name in names if len(name)&gt;3]&gt;&gt;&gt; print(new_names)[&#x27;ALICE&#x27;, &#x27;JERRY&#x27;, &#x27;WENDY&#x27;, &#x27;SMITH&#x27;] 实例2：计算 30 以内可以被 3 整除的整数 12multiples = [i for i in range(30) if i % 3 == 0]print(multiples) 字典推导式 ​ 格式： 123&#123; key_expr: value_expr for value in collection &#125;或&#123; key_expr: value_expr for value in collection if condition &#125; 实例1：使用字符串及其长度创建字典 12345list =[&#x27;beijing&#x27;, &#x27;shanghai&#x27;, &#x27;guangzhou&#x27;,&#x27;shenzhen&#x27;]dic = &#123;key:len(key) for key in list&#125;print(dic)输出：&#123;&#x27;beijing&#x27;: 7, &#x27;shanghai&#x27;: 8, &#x27;guangzhou&#x27;: 9, &#x27;shenzhen&#x27;: 8&#125; 实例2：将三个整数及其平方值作为键值对创建字典 1234dic = &#123;i : i**2 for i in (1,2,3)&#125;print(dic)输出：&#123;1: 1, 2: 4, 3: 9&#125; 集合推导式 ​ 格式： 123&#123; expression for item in Sequence &#125;或&#123; expression for item in Sequence if conditional &#125; 实例1：计算1，2，3平方 1set = &#123;x**2 for x in (1,2,3)&#125; 实例2：判断不是abc的字母并输出 1a = &#123;x for x in &#x27;abclsm&#x27; if x not in &#x27;abc&#x27;&#125; 元组推导式 ​ 元组推导式可以利用 range 区间、元组、列表、字典和集合等数据类型，快速生成一个满足指定需求的元组。 ​ 元组推导式和列表推导式的用法也完全相同，只是元组推导式是用 () 圆括号将各部分括起来，而列表推导式用的是中括号 **[]**，另外元组推导式返回的结果是一个生成器对象。 ​ 格式： 123(expression for item in Sequence )或(expression for item in Sequence if conditional ) 实例1：生成一个包含数字 1~9 的元组： 123456&gt;&gt;&gt; a = (x for x in range(1,10))&gt;&gt;&gt; a&lt;generator object &lt;genexpr&gt; at 0x7faf6ee20a50&gt; # 返回的是生成器对象&gt;&gt;&gt; tuple(a) # 使用 tuple() 函数，可以直接将生成器对象转换成元组(1, 2, 3, 4, 5, 6, 7, 8, 9) 解释器python 的二进制文件 交互式编程 脚本式编程 注释确保对模块, 函数, 方法和行内注释使用正确的风格。 Python 中的注释有单行注释和多行注释。 Python 中单行注释以 # 开头，例如： # 这是一个注释 print(“Hello, World!”) 多行注释用三个单引号 ‘’’ 或者三个双引号 “”” 将注释括起来，例如: 单引号（’’’） #!/usr/bin/python3 ‘’’ 这是多行注释，用三个单引号 这是多行注释，用三个单引号 这是多行注释，用三个单引号 ‘’’ print(“Hello, World!”) 双引号（”””） #!/usr/bin/python3 “”” 这是多行注释，用三个双引号 这是多行注释，用三个双引号 这是多行注释，用三个双引号 “”” print(“Hello, World!”) 运算符Python 语言支持以下类型的运算符: 算术运算符 比较（关系）运算符 赋值运算符 逻辑运算符 位运算符 成员运算符 身份运算符 运算符优先级 以下表格列出了从最高到最低优先级的所有运算符： 运算符 描述 ** 指数 (最高优先级) ~ + - 按位翻转, 一元加号和减号 (最后两个的方法名为 +@ 和 -@) * / % // 乘，除，求余数和取整除 + - 加法减法 &gt;&gt; &lt;&lt; 右移，左移运算符 &amp; 位 ‘AND’ ^ | 位运算符 &lt;= &lt; &gt; &gt;= 比较运算符 == != 等于运算符 = %= /= //= -= += *= **= 赋值运算符 is is not 身份运算符 in not in 成员运算符 not and or 逻辑运算符 数字查看 字符串注：只记录新的东西，使用与 C 中 sprintf 函数一样的语法，不同的是后面的变量前面有个% 字符串格式化： 如 print (“我叫 %s 今年 %d 岁!” % (‘小明’, 10)) 新的格式化方式 str.format() 通过 {} 和 **.**来代替以前的 % 。 123456789101112131415161718192021222324252627&gt;&gt;&gt;&quot;&#123;&#125; &#123;&#125;&quot;.format(&quot;hello&quot;, &quot;world&quot;) # 不设置指定位置，按默认顺序&#x27;hello world&#x27; &gt;&gt;&gt; &quot;&#123;0&#125; &#123;1&#125;&quot;.format(&quot;hello&quot;, &quot;world&quot;) # 设置指定位置&#x27;hello world&#x27; &gt;&gt;&gt; &quot;&#123;1&#125; &#123;0&#125; &#123;1&#125;&quot;.format(&quot;hello&quot;, &quot;world&quot;) # 设置指定位置&#x27;world hello world&#x27;也可设置参数#!/usr/bin/python# -*- coding: UTF-8 -*- print(&quot;网站名：&#123;name&#125;, 地址 &#123;url&#125;&quot;.format(name=&quot;菜鸟教程&quot;, url=&quot;www.runoob.com&quot;)) # 通过字典设置参数site = &#123;&quot;name&quot;: &quot;菜鸟教程&quot;, &quot;url&quot;: &quot;www.runoob.com&quot;&#125;print(&quot;网站名：&#123;name&#125;, 地址 &#123;url&#125;&quot;.format(**site)) # 通过列表索引设置参数my_list = [&#x27;菜鸟教程&#x27;, &#x27;www.runoob.com&#x27;]print(&quot;网站名：&#123;0[0]&#125;, 地址 &#123;0[1]&#125;&quot;.format(my_list)) # &quot;0&quot; 是必须的# 向str.format() 传入对象 不明白这里class AssignValue(object): def __init__(self, value): self.value = valuemy_value = AssignValue(6)print(&#x27;value 为: &#123;0.value&#125;&#x27;.format(my_value)) # &quot;0&quot; 是可选的 数字格式化 12&gt;&gt;&gt; print(&quot;&#123;:.2f&#125;&quot;.format(3.1415926))3.14 列表一些列表操作： 更新列表 12&gt;&gt;&gt; list = []&gt;&gt;&gt; list.append(&#x27;test&#x27;) 删除列表元素 123&gt;&gt;&gt; del list[0]&gt;&gt;&gt; print list[] 操作符 1234567891011121314#len(list)&gt;&gt;&gt; list.append(&#x27;test&#x27;)&gt;&gt;&gt; len(list)1# + 组合列表 -&gt; 新列表&gt;&gt;&gt; [1] + list[1, &#x27;test&#x27;]# * 重复列表 -&gt; 新列表&gt;&gt;&gt; list * 2[&#x27;test&#x27;, &#x27;test&#x27;]# in 检查成员&gt;&gt;&gt; &#x27;test&#x27; in listTrue# for x in [1,2,3]: print x 函数和方法 序号 函数 1 cmp(list1, list2) 比较两个列表的元素 2 len(list) 列表元素个数 3 max(list) 返回列表元素最大值 4 min(list) 返回列表元素最小值 5 list(seq) 将元组转换为列表 序号 方法 1 list.append(obj) 在列表末尾添加新的对象 2 list.count(obj) 统计某个元素在列表中出现的次数 3 list.extend(seq) 在列表末尾一次性追加另一个序列中的多个值（用新列表扩展原来的列表） 4 list.index(obj) 从列表中找出某个值第一个匹配项的索引位置 5 list.insert(index, obj) 将对象插入列表 6 [list.pop(index=-1]) 移除列表中的一个元素（默认最后一个元素），并且返回该元素的值 7 list.remove(obj) 移除列表中某个值的第一个匹配项 8 list.reverse() 反向列表中元素 9 list.sort(cmp=None, key=None, reverse=False) 对原列表进行排序 ​ 元组 创建 tup1 = (‘physics’, ‘chemistry’, 1997, 2000) tup2 = (1, 2, 3, 4, 5 ) tup3 = “a”, “b”, “c”, “d” 创建空元组 1tup1 = () 元组中只包含一个元素时，需要在元素后面添加逗号 1tup1 = (50,) 元组与字符串类似，下标索引从0开始，可以进行截取，组合等。 访问 索引或切片 修改 元组中的元素值是不允许修改的，但我们可以对元组进行连接组合 tup1 = (12, 34.56) tup2 = (‘abc’, ‘xyz’) # 以下修改元组元素操作是非法的。 # tup1[0] = 100 # 创建一个新的元组 tup3 = tup1 + tup2 print tup3 输出(12, 34.56, ‘abc’, ‘xyz’) 删除 del tup 运算符 Python 表达式 结果 描述 len((1, 2, 3)) 3 计算元素个数 (1, 2, 3) + (4, 5, 6) (1, 2, 3, 4, 5, 6) 连接 (‘Hi!’,) * 4 (‘Hi!’, ‘Hi!’, ‘Hi!’, ‘Hi!’) 复制 3 in (1, 2, 3) True 元素是否存在 for x in (1, 2, 3): print x, 1 2 3 迭代 任意无符号的对象，以逗号隔开，默认为元组 123456print &#x27;abc&#x27;, -4.24e93, 18+6.6j, &#x27;xyz&#x27;x, y = 1, 2print &quot;Value of x , y : &quot;, x,yabc -4.24e+93 (18+6.6j) xyzValue of x , y : 1 2 内置 函数 序号 方法及描述 1 cmp(tuple1, tuple2) 比较两个元组元素。 2 len(tuple) 计算元组元素个数。 3 max(tuple) 返回元组中元素最大值。 4 min(tuple) 返回元组中元素最小值。 5 tuple(seq) 将列表转换为元组。 字典 创建字典 1234567891011121314tinydict1 = &#123; &#x27;abc&#x27;: 456 &#125;tinydict2 = &#123; &#x27;abc&#x27;: 123, 98.6: 37 &#125;# 使用大括号 &#123;&#125; 来创建空字典emptyDict = &#123;&#125; # 打印字典print(emptyDict) # 查看字典的数量print(&quot;Length:&quot;, len(emptyDict)) # 查看类型print(type(emptyDict))# 使用dict() 创建emptyDict = dict() 访问 123tinydict = &#123;&#x27;Name&#x27;: &#x27;Runoob&#x27;, &#x27;Age&#x27;: 7, &#x27;Class&#x27;: &#x27;First&#x27;&#125;print (&quot;tinydict[&#x27;Name&#x27;]: &quot;, tinydict[&#x27;Name&#x27;])print (&quot;tinydict[&#x27;Age&#x27;]: &quot;, tinydict[&#x27;Age&#x27;]) 修改 12345tinydict = &#123;&#x27;Name&#x27;: &#x27;Runoob&#x27;, &#x27;Age&#x27;: 7, &#x27;Class&#x27;: &#x27;First&#x27;&#125;tinydict[&#x27;Age&#x27;] = 8 # 更新 Agetinydict[&#x27;School&#x27;] = &quot;菜鸟教程&quot; # 添加信息print (&quot;tinydict[&#x27;Age&#x27;]: &quot;, tinydict[&#x27;Age&#x27;])print (&quot;tinydict[&#x27;School&#x27;]: &quot;, tinydict[&#x27;School&#x27;]) 删除元素 12345del tinydict[&#x27;Name&#x27;] # 删除键 &#x27;Name&#x27;tinydict.clear() # 清空字典del tinydict # 删除字典print (&quot;tinydict[&#x27;Age&#x27;]: &quot;, tinydict[&#x27;Age&#x27;])print (&quot;tinydict[&#x27;School&#x27;]: &quot;, tinydict[&#x27;School&#x27;]) 键特性 两个重要的点需要记住： 1）不允许同一个键出现两次。创建时如果同一个键被赋值两次，后一个值会被记住 2）键必须不可变，所以可以用数字，字符串或元组充当，而用列表就不行 内置函数和方法 号 函数及描述 实例 1 len(dict) 计算字典元素个数，即键的总数。 &gt;&gt;&gt; tinydict = &#123;&#39;Name&#39;: &#39;Runoob&#39;, &#39;Age&#39;: 7, &#39;Class&#39;: &#39;First&#39;&#125; &gt;&gt;&gt; len(tinydict) 3 2 str(dict) 输出字典，可以打印的字符串表示。 &gt;&gt;&gt; tinydict = &#123;&#39;Name&#39;: &#39;Runoob&#39;, &#39;Age&#39;: 7, &#39;Class&#39;: &#39;First&#39;&#125; &gt;&gt;&gt; str(tinydict) &quot;&#123;&#39;Name&#39;: &#39;Runoob&#39;, &#39;Class&#39;: &#39;First&#39;, &#39;Age&#39;: 7&#125;&quot; 3 type(variable) 返回输入的变量类型，如果变量是字典就返回字典类型。 &gt;&gt;&gt; tinydict = &#123;&#39;Name&#39;: &#39;Runoob&#39;, &#39;Age&#39;: 7, &#39;Class&#39;: &#39;First&#39;&#125; &gt;&gt;&gt; type(tinydict) &lt;class &#39;dict&#39;&gt; 序号 函数及描述 1 dict.clear() 删除字典内所有元素 2 dict.copy() 返回一个字典的浅复制 3 dict.fromkeys() 创建一个新字典，以序列seq中元素做字典的键，val为字典所有键对应的初始值 4 dict.get(key, default=None) 返回指定键的值，如果键不在字典中返回 default 设置的默认值 5 key in dict 如果键在字典dict里返回true，否则返回false 6 dict.items() 以列表返回一个视图对象 7 dict.keys() 返回一个视图对象 8 dict.setdefault(key, default=None) 和get()类似, 但如果键不存在于字典中，将会添加键并将值设为default 9 dict.update(dict2) 把字典dict2的键/值对更新到dict里 10 dict.values() 返回一个视图对象 11 [pop(key,default]) 删除字典给定键 key 所对应的值，返回值为被删除的值。key值必须给出。 否则，返回default值。 12 popitem() 返回并删除字典中的最后一对键和值。 ​ 集合一个无序的不重复元素序列。 创建 12345678910parame = &#123;value01,value02,...&#125;或者set(value)&gt;&gt;&gt; basket = &#123;&#x27;apple&#x27;, &#x27;orange&#x27;, &#x27;apple&#x27;, &#x27;pear&#x27;, &#x27;orange&#x27;, &#x27;banana&#x27;&#125;&gt;&gt;&gt; print(basket) # 这里演示的是去重功能&#123;&#x27;orange&#x27;, &#x27;banana&#x27;, &#x27;pear&#x27;, &#x27;apple&#x27;&#125;&gt;&gt;&gt; &#x27;orange&#x27; in basket # 快速判断元素是否在集合内True&gt;&gt;&gt; &#x27;crabgrass&#x27; in basketFalse 添加元素 123456789s.add( x ) #将元素 x 添加到集合 s 中，如果元素已存在，则不进行任何操作s.update( x ) #参数可以是列表，元组，字典等&gt;&gt;&gt; thisset = set((&quot;Google&quot;, &quot;Runoob&quot;, &quot;Taobao&quot;))&gt;&gt;&gt; thisset.update(&#123;1,3&#125;)&gt;&gt;&gt; print(thisset)&#123;1, 3, &#x27;Google&#x27;, &#x27;Taobao&#x27;, &#x27;Runoob&#x27;&#125;&gt;&gt;&gt; thisset.update([1,4],[5,6]) &gt;&gt;&gt; print(thisset)&#123;1, 3, 4, 5, 6, &#x27;Google&#x27;, &#x27;Taobao&#x27;, &#x27;Runoob&#x27;&#125; 删除元素 123s.remove( x ) #将元素 x 从集合 s 中移除，如果元素不存在，则会发生错误s.discard( x ) #如果元素不存在，不会发生错误s.pop() #随机删除集合中的一个元素，set 集合的 pop 方法会对集合进行无序的排列，然后将这个无序排列集合的左面第一个元素进行删除 计算元素个数 1len(s) 清空集合 1s.clear() 判断元素是否存在 1x in s 内置方法 方法 描述 add() 为集合添加元素 clear() 移除集合中的所有元素 copy() 拷贝一个集合 difference() 返回多个集合的差集 difference_update() 移除集合中的元素，该元素在指定的集合也存在。 discard() 删除集合中指定的元素 intersection() 返回集合的交集 intersection_update() 返回集合的交集。 isdisjoint() 判断两个集合是否包含相同的元素，如果没有返回 True，否则返回 False。 issubset() 判断指定集合是否为该方法参数集合的子集。 issuperset() 判断该方法的参数集合是否为指定集合的子集 pop() 随机移除元素 remove() 移除指定元素 symmetric_difference() 返回两个集合中不重复的元素集合。 symmetric_difference_update() 移除当前集合中在另外一个指定集合相同的元素，并将另外一个指定集合中不同的元素插入到当前集合中。 union() 返回两个集合的并集 update() 给集合添加元素 条件控制 if 1、每个条件后面要使用冒号 **:**，表示接下来是满足条件后要执行的语句块。 2、使用缩进来划分语句块，相同缩进数的语句在一起组成一个语句块。 3、在Python中没有switch – case语句。 if-elif-else : python 中无else if 而使用elif if 嵌套 循环语句Python 中的循环语句有 for 和 while,同样需要注意冒号和缩进。另外，在 Python 中没有 do..while 循环 while 12while 判断条件(condition)： 执行语句(statements)…… while else 1234while &lt;expr&gt;: &lt;statement(s)&gt;else: &lt;additional_statement(s)&gt; 简单语句组 类似if语句的语法，如果你的while循环体中只有一条语句，你可以将该语句与while写在同一行中 1flag = 1 while (flag): print (&#x27;欢迎访问菜鸟教程!&#x27;) print (&quot;Good bye!&quot;) for for 循环可以遍历任何可迭代对象，如一个列表或者一个字符串 1234for &lt;variable&gt; in &lt;sequence&gt;: &lt;statements&gt; else: &lt;statements&gt; range() 遍历数字序列，可以使用内置range()函数。它会生成数列 结合range()和len()函数以遍历一个序列的索引 使用range()函数来创建一个列表 12345678910111213141516171819202122232425&gt;&gt;&gt;for i in range(5):... print(i)...01234&gt;&gt;&gt;for i in range(0, 10, 3) : print(i)0369&gt;&gt;&gt;a = [&#x27;Google&#x27;, &#x27;Baidu&#x27;, &#x27;Runoob&#x27;, &#x27;Taobao&#x27;, &#x27;QQ&#x27;]&gt;&gt;&gt; for i in range(len(a)):... print(i, a[i])... 0 Google1 Baidu2 Runoob3 Taobao4 QQ&gt;&gt;&gt;list(range(5))[0, 1, 2, 3, 4] pass pass是空语句，是为了保持程序结构的完整性,不做任何事情，一般用做占位语句 迭代器与生成器 迭代器 迭代是Python最强大的功能之一，是访问集合元素的一种方式。 迭代器是一个可以记住遍历的位置的对象。 迭代器对象从集合的第一个元素开始访问，直到所有的元素被访问完结束。迭代器只能往前不会后退。 迭代器有两个基本的方法：iter() 和 **next()**。 12345678910111213#字符串，列表或元组对象都可用于创建迭代器&gt;&gt;&gt; list=[1,2,3,4]&gt;&gt;&gt; it = iter(list) # 创建迭代器对象&gt;&gt;&gt; print (next(it)) # 输出迭代器的下一个元素1&gt;&gt;&gt; print (next(it))2#迭代器对象可以使用常规for语句进行遍历：list=[1,2,3,4]it = iter(list) # 创建迭代器对象for x in it: print (x, end=&quot; &quot;)1 2 3 4 创建 把一个类作为一个迭代器使用需要在类中实现两个方法__ iter() 与__ next() __ iter() 方法返回一个特殊的迭代器对象， 这个迭代器对象实现了 next() 方法并通过 StopIteration 异常标识迭代的完成。 __ next() 方法（Python 2 里是 next()）会返回下一个迭代器对象。 123456789101112131415161718192021222324252627282930313233343536373839404142class MyNumbers: def __iter__(self): self.a = 1 return self def __next__(self): x = self.a self.a += 1 return x myclass = MyNumbers()myiter = iter(myclass) print(next(myiter))print(next(myiter))print(next(myiter))print(next(myiter))print(next(myiter))12345#StopIteration 异常用于标识迭代的完成，防止出现无限循环的情况，在 __next__() 方法中我们可以设置在完成指定循环次数后触发 StopIteration 异常来结束迭代。class MyNumbers: def __iter__(self): self.a = 1 return self def __next__(self): if self.a &lt;= 20: x = self.a self.a += 1 return x else: raise StopIteration myclass = MyNumbers()myiter = iter(myclass) for x in myiter: print(x) 生成器 在 Python 中，使用了 yield 的函数被称为生成器（generator）。 跟普通函数不同的是，生成器是一个返回迭代器的函数，只能用于迭代操作，更简单点理解生成器就是一个迭代器。 在调用生成器运行的过程中，每次遇到 yield 时函数会暂停并保存当前所有的运行信息，返回 yield 的值, 并在下一次执行 next() 方法时从当前位置继续运行。 调用一个生成器函数，返回的是一个迭代器对象。 123456789101112131415161718import sys def fibonacci(n): # 生成器函数 - 斐波那契 a, b, counter = 0, 1, 0 while True: if (counter &gt; n): return yield a a, b = b, a + b counter += 1f = fibonacci(10) # f 是一个迭代器，由生成器返回生成 while True: try: print (next(f), end=&quot; &quot;) except StopIteration: sys.exit() 0 1 1 2 3 5 8 13 21 34 55 函数 函数代码块以 def 关键词开头，后接函数标识符名称和圆括号 **()**。 任何传入参数和自变量必须放在圆括号中间，圆括号之间可以用于定义参数。 函数的第一行语句可以选择性地使用文档字符串—用于存放函数说明。 函数内容以冒号 : 起始，并且缩进。 return [表达式] 结束函数，选择性地返回一个值给调用方，不带表达式的 return 相当于返回 None。 格式： 12def 函数名（参数列表）: 函数体 参数传递 在 python 中，类型属于对象，对象有不同类型的区分，变量是没有类型的 123a=[1,2,3]a=&quot;Runoob&quot; 以上代码中，**[1,2,3]** 是 List 类型，**”Runoob”** 是 String 类型，而变量 a 是没有类型，她仅仅是一个对象的引用（一个指针），可以是指向 List 类型对象，也可以是指向 String 类型对象。 可更改(mutable)与不可更改(immutable)对象 在 python 中，strings, tuples, 和 numbers 是不可更改的对象，而 list,dict 等则是可以修改的对象。 不可变类型：变量赋值 a=5 后再赋值 a=10，这里实际是新生成一个 int 值对象 10，再让 a 指向它，而 5 被丢弃，不是改变 a 的值，相当于新生成了 a。 可变类型：变量赋值 la=[1,2,3,4] 后再赋值 la[2]=5 则是将 list la 的第三个元素值更改，本身la没有动，只是其内部的一部分值被修改了。 python 函数的参数传递： 不可变类型：类似 C++ 的值传递，如整数、字符串、元组。如 fun(a)，传递的只是 a 的值，没有影响 a 对象本身。如果在 fun(a) 内部修改 a 的值，则是新生成一个 a 的对象。 可变类型：类似 C++ 的引用传递，如 列表，字典。如 fun(la)，则是将 la 真正的传过去，修改后 fun 外部的 la 也会受影响 python 中一切都是对象，严格意义我们不能说值传递还是引用传递，我们应该说传不可变对象和传可变对象。 1234567891011121314151617181920212223242526#传不可变对象 通过 id() 函数来查看内存地址变化：def change(a): print(id(a)) # 指向的是同一个对象 a=10 print(id(a)) # 一个新对象 a=1print(id(a))change(a)437936913643793691364379369424#传可变对象 通过 id() 函数来查看内存地址变化：# 可写函数说明def changeme( mylist ): &quot;修改传入的列表&quot; mylist.append([1,2,3,4]) print (&quot;函数内取值: &quot;, mylist) return # 调用changeme函数mylist = [10,20,30]changeme( mylist )print (&quot;函数外取值: &quot;, mylist)函数内取值: [10, 20, 30, [1, 2, 3, 4]]函数外取值: [10, 20, 30, [1, 2, 3, 4]] 参数 必需参数 必需参数须以正确的顺序传入函数。调用时的数量必须和声明时的一样。 关键字参数 关键字参数和函数调用关系紧密，函数调用使用关键字参数来确定传入的参数值。 使用关键字参数允许函数调用时参数的顺序与声明时不一致，因为 Python 解释器能够用参数名匹配参数值。 12345678910111213141516#可写函数说明def printme( str ): &quot;打印任何传入的字符串&quot; print (str) return#调用printme函数printme( str = &quot;菜鸟教程&quot;)#不需要使用指定顺序#可写函数说明def printinfo( name, age ): &quot;打印任何传入的字符串&quot; print (&quot;名字: &quot;, name) print (&quot;年龄: &quot;, age) return#调用printinfo函数printinfo( age=50, name=&quot;runoob&quot; ) 默认参数 调用函数时，如果没有传递参数，则会使用默认参数。以下实例中如果没有传入 age 参数，则使用默认值： 12345678910#可写函数说明def printinfo( name, age = 35 ): &quot;打印任何传入的字符串&quot; print (&quot;名字: &quot;, name) print (&quot;年龄: &quot;, age) return#调用printinfo函数printinfo( age=50, name=&quot;runoob&quot; )print (&quot;------------------------&quot;)printinfo( name=&quot;runoob&quot; ) 不定长参数 你可能需要一个函数能处理比当初声明时更多的参数。这些参数叫做不定长参数，和上述 2 种参数不同，声明时不会命名。基本语法如下： 12345def functionname([formal_args,] *var_args_tuple ): &quot;函数_文档字符串&quot; function_suite return [expression]加了星号 * 的参数会以元组(tuple)的形式导入，存放所有未命名的变量参数。 1234567891011# 可写函数说明def printinfo( arg1, *vartuple ): &quot;打印任何传入的参数&quot; print (&quot;输出: &quot;) print (arg1) print (vartuple)# 调用printinfo 函数printinfo( 70, 60, 50 )输出: 70(60, 50) 还有一种就是参数带两个星号 ******基本语法如下： 12345def functionname([formal_args,] **var_args_dict ): &quot;函数_文档字符串&quot; function_suite return [expression]加了两个星号 ** 的参数会以字典的形式导入 12345678910111213# 可写函数说明def printinfo( arg1, **vardict ): &quot;打印任何传入的参数&quot; print (&quot;输出: &quot;) print (arg1) print (vardict) # 调用printinfo 函数printinfo(1, a=2,b=3)输出: 1&#123;&#x27;a&#x27;: 2, &#x27;b&#x27;: 3&#125; 声明函数时，参数中星号 ***** 可以单独出现，例如: 1234567891011def f(a,b,*,c): return a+b+c&gt;&gt;&gt; def f(a,b,*,c):... return a+b+c... &gt;&gt;&gt; f(1,2,3) # 报错Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;TypeError: f() takes 2 positional arguments but 3 were given&gt;&gt;&gt; f(1,2,c=3) # 正常6 匿名函数 Python 使用 lambda 来创建匿名函数。 所谓匿名，意即不再使用 def 语句这样标准的形式定义一个函数。 lambda 只是一个表达式，函数体比 def 简单很多。 lambda 的主体是一个表达式，而不是一个代码块。仅仅能在 lambda 表达式中封装有限的逻辑进去。 lambda 函数拥有自己的命名空间，且不能访问自己参数列表之外或全局命名空间里的参数。 虽然 lambda 函数看起来只能写一行，却不等同于 C 或 C++ 的内联函数，后者的目的是调用小函数时不占用栈内存从而增加运行效率。 lambda 函数的语法只包含一个语句，如下： 1lambda [arg1 [,arg2,.....argn]]:expression 123456789#一个参数x = lambda a : a + 10print(x(5))#多个参数# 可写函数说明sum = lambda arg1, arg2: arg1 + arg2# 调用sum函数print (&quot;相加后的值为 : &quot;, sum( 10, 20 ))print (&quot;相加后的值为 : &quot;, sum( 20, 20 )) 可以将匿名函数封装在一个函数内，这样可以使用同样的代码来创建多个匿名函数。 12345678def myfunc(n): return lambda a : a * n mydoubler = myfunc(2)mytripler = myfunc(3) print(mydoubler(11))print(mytripler(11)) 数据结构参考菜鸟教程 模块Python 提供了一个办法，把这些定义存放在文件中，为一些脚本或者交互式的解释器实例使用，这个文件被称为模块。 模块是一个包含所有你定义的函数和变量的文件，其后缀名是.py。模块可以被别的程序引入，以使用该模块中的函数等功能。这也是使用 python 标准库的方法。 1、import sys 引入 python 标准库中的 sys.py 模块；这是引入某一模块的方法。 2、sys.argv 是一个包含命令行参数的列表。 3、sys.path 包含了一个 Python 解释器自动查找所需模块的路径的列表。 深入模块 输入输出 输出格式美化 Python两种输出值的方式: 表达式语句和 print() 函数。 第三种方式是使用文件对象的 write() 方法，标准输出文件可以用 sys.stdout 引用。 如果你希望输出的形式更加多样，可以使用 str.format() 函数来格式化输出值。 如果你希望将输出的值转成字符串，可以使用 repr() 或 str() 函数来实现。 str()： 函数返回一个用户易读的表达形式。 repr()： 产生一个解释器易读的表达形式。 1234567891011121314151617181920&gt;&gt;&gt; s = &#x27;Hello, Runoob&#x27;&gt;&gt;&gt; str(s)&#x27;Hello, Runoob&#x27;&gt;&gt;&gt; repr(s)&quot;&#x27;Hello, Runoob&#x27;&quot;&gt;&gt;&gt; str(1/7)&#x27;0.14285714285714285&#x27;&gt;&gt;&gt; x = 10 * 3.25&gt;&gt;&gt; y = 200 * 200&gt;&gt;&gt; s = &#x27;x 的值为： &#x27; + repr(x) + &#x27;, y 的值为：&#x27; + repr(y) + &#x27;...&#x27;&gt;&gt;&gt; print(s)x 的值为： 32.5, y 的值为：40000...&gt;&gt;&gt; # repr() 函数可以转义字符串中的特殊字符... hello = &#x27;hello, runoob\\n&#x27;&gt;&gt;&gt; hellos = repr(hello)&gt;&gt;&gt; print(hellos)&#x27;hello, runoob\\n&#x27;&gt;&gt;&gt; # repr() 的参数可以是 Python 的任何对象... repr((x, y, (&#x27;Google&#x27;, &#x27;Runoob&#x27;)))&quot;(32.5, 40000, (&#x27;Google&#x27;, &#x27;Runoob&#x27;))&quot; str.format() #括号及其里面的字符 (称作格式化字段) 将会被 format() 中的参数替换 &gt;&gt;&gt; print(‘{}网址： “{}!”‘.format(‘菜鸟教程’, ‘www.runoob.com&#39;))菜鸟教程网址： “www.runoob.com!&quot; #在括号中的数字用于指向传入对象在 format() 中的位置 &gt;&gt;&gt; print(‘{0} 和 {1}’.format(‘Google’, ‘Runoob’))Google 和 Runoob&gt;&gt;&gt; print(‘{1} 和 {0}’.format(‘Google’, ‘Runoob’))Runoob 和 Google #如果在 format() 中使用了关键字参数, 那么它们的值会指向使用该名字的参数 &gt;&gt;&gt; print(‘{name}网址： {site}’.format(name=’菜鸟教程’, site=’www.runoob.com&#39;))菜鸟教程网址： www.runoob.com #位置及关键字参数可以任意的结合 &gt;&gt;&gt; print(‘站点列表 {0}, {1}, 和 {other}。’.format(‘Google’, ‘Runoob’, other=’Taobao’))站点列表 Google, Runoob, 和 Taobao。 #!a (使用 ascii()), !s (使用 str()) 和 !r (使用 repr()) 可以用于在格式化某个值之前对其进行转化: 12345&gt;&gt;&gt; import math&gt;&gt;&gt; print(&#x27;常量 PI 的值近似为： &#123;&#125;。&#x27;.format(math.pi))常量 PI 的值近似为： 3.141592653589793。&gt;&gt;&gt; print(&#x27;常量 PI 的值近似为： &#123;!r&#125;。&#x27;.format(math.pi))常量 PI 的值近似为： 3.141592653589793。 #可选项 : 和格式标识符可以跟着字段名。 这就允许对值进行更好的格式化。 下面的例子将 Pi 保留到小数点后三位： 123&gt;&gt;&gt; import math&gt;&gt;&gt; print(&#x27;常量 PI 的值近似为 &#123;0:.3f&#125;。&#x27;.format(math.pi))常量 PI 的值近似为 3.142。 #在 : 后传入一个整数, 可以保证该域至少有这么多的宽度。 用于美化表格时很有用 1234567&gt;&gt;&gt; table = &#123;&#x27;Google&#x27;: 1, &#x27;Runoob&#x27;: 2, &#x27;Taobao&#x27;: 3&#125;&gt;&gt;&gt; for name, number in table.items():... print(&#x27;&#123;0:10&#125; ==&gt; &#123;1:10d&#125;&#x27;.format(name, number))...Google ==&gt; 1Runoob ==&gt; 2Taobao ==&gt; 3 旧式字符串格式化 % 操作符也可以实现字符串格式化。 它将左边的参数作为类似 sprintf() 式的格式化字符串, 而将右边的代入, 然后返回格式化后的字符串. 但是因为这种旧式的格式化最终会从该语言中移除, 应该更多的使用 str.format(). 123&gt;&gt;&gt; import math&gt;&gt;&gt; print(&#x27;常量 PI 的值近似为：%5.3f。&#x27; % math.pi)常量 PI 的值近似为：3.142。 读取键盘输入 使用input()内置函数从标准输入读入一行文本，默认的标准输入是键盘 123#!/usr/bin/python3str = input(&quot;请输入：&quot;);print (&quot;你输入的内容是: &quot;, str) 读写文件 open() 将会返回一个 file 对象： 123open(filename, mode)filename：包含了你要访问的文件名称的字符串值。mode：决定了打开文件的模式：只读，写入，追加等。所有可取值见如下的完全列表。这个参数是非强制的，默认文件访问模式为只读(r)。 实例 12345# 打开一个文件f = open(&quot;/tmp/foo.txt&quot;, &quot;w&quot;)f.write( &quot;Python 是一个非常好的语言。\\n是的，的确非常好!!\\n&quot; )# 关闭打开的文件f.close() 不同模式打开文件的完全列表： 模式 描述 r 以只读方式打开文件。文件的指针将会放在文件的开头。这是默认模式。 rb 以二进制格式打开一个文件用于只读。文件指针将会放在文件的开头。 r+ 打开一个文件用于读写。文件指针将会放在文件的开头。 rb+ 以二进制格式打开一个文件用于读写。文件指针将会放在文件的开头。 w 打开一个文件只用于写入。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。 wb 以二进制格式打开一个文件只用于写入。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。 w+ 打开一个文件用于读写。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。 wb+ 以二进制格式打开一个文件用于读写。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。 a 打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。 ab 以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。 a+ 打开一个文件用于读写。如果该文件已存在，文件指针将会放在文件的结尾。文件打开时会是追加模式。如果该文件不存在，创建新文件用于读写。 ab+ 以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。如果该文件不存在，创建新文件用于读写。 模式 r r+ w w+ a a+ 读 + + + + 写 + + + + + 创建 + + + + 覆盖 + + 指针在开始 + + + + 指针在结尾 + + 文件对象方法 f.read() #调用 f.read(size), 这将读取一定数目的数据, 然后作为字符串或字节对象返回。size 是一个可选的数字类型的参数。 当 size 被忽略了或者为负, 那么该文件的所有内容都将被读取并且返回。 实例 12345678910#!/usr/bin/python3# 打开一个文件f = open(&quot;/tmp/foo.txt&quot;, &quot;r&quot;)str = f.read()print(str)# 关闭打开的文件f.close()Python 是一个非常好的语言。是的，的确非常好!! f.readline() #f.readline() 会从文件中读取单独的一行。换行符为 ‘\\n’。f.readline() 如果返回一个空字符串, 说明已经已经读取到最后一行。 实例 12345678# 打开一个文件f = open(&quot;/tmp/foo.txt&quot;, &quot;r&quot;)str = f.readline()print(str)# 关闭打开的文件f.close()Python 是一个非常好的语言。 f.readlines() #返回该文件中包含的所有行。 #如果设置可选参数 sizehint, 则读取指定长度的字节, 并且将这些字节按行分割。 实例1 123456789#!/usr/bin/python3# 打开一个文件f = open(&quot;/tmp/foo.txt&quot;, &quot;r&quot;)str = f.readlines()print(str)# 关闭打开的文件f.close()输出[&#x27;Python 是一个非常好的语言。\\n&#x27;, &#x27;是的，的确非常好!!\\n&#x27;] 实例2 迭代一个文件对象然后读取每行: 123456789# 打开一个文件f = open(&quot;/tmp/foo.txt&quot;, &quot;r&quot;)for line in f: print(line, end=&#x27;&#x27;)# 关闭打开的文件f.close()执行以上程序，输出结果为：Python 是一个非常好的语言。是的，的确非常好!! f.write() f.write(string) 将 string 写入到文件中, 然后返回写入的字符数。 123456789#!/usr/bin/python3# 打开一个文件f = open(&quot;/tmp/foo.txt&quot;, &quot;w&quot;)num = f.write( &quot;Python 是一个非常好的语言。\\n是的，的确非常好!!\\n&quot; )print(num)# 关闭打开的文件f.close()执行以上程序，输出结果为：29 如果要写入一些不是字符串的东西, 那么将需要先进行转换: 1234567891011#!/usr/bin/python3# 打开一个文件f = open(&quot;/tmp/foo1.txt&quot;, &quot;w&quot;)value = (&#x27;www.runoob.com&#x27;, 14)s = str(value)f.write(s)# 关闭打开的文件f.close()执行以上程序，打开 foo1.txt 文件：$ cat /tmp/foo1.txt (&#x27;www.runoob.com&#x27;, 14) f.tell() f.tell() 返回文件对象当前所处的位置, 它是从文件开头开始算起的字节数。 f.seek() 如果要改变文件当前的位置, 可以使用 f.seek(offset, from_what) 函数。 from_what 的值, 如果是 0 表示开头, 如果是 1 表示当前位置, 2 表示文件的结尾，例如： seek(x,0) ： 从起始位置即文件首行首字符开始移动 x 个字符 seek(x,1) ： 表示从当前位置往后移动x个字符 seek(-x,2)：表示从文件的结尾往前移动x个字符 from_what 值为默认为0，即文件开头。下面给出一个完整的例子： 1234567891011&gt;&gt;&gt; f = open(&#x27;/tmp/foo.txt&#x27;, &#x27;rb+&#x27;)&gt;&gt;&gt; f.write(b&#x27;0123456789abcdef&#x27;)16&gt;&gt;&gt; f.seek(5) # 移动到文件的第六个字节5&gt;&gt;&gt; f.read(1)b&#x27;5&#x27;&gt;&gt;&gt; f.seek(-3, 2) # 移动到文件的倒数第三字节13&gt;&gt;&gt; f.read(1)b&#x27;d&#x27; f.close() 当你处理完一个文件后, 调用 f.close() 来关闭文件并释放系统的资源，如果尝试再调用该文件，则会抛出异常。 12345&gt;&gt;&gt; f.close()&gt;&gt;&gt; f.read()Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in ?ValueError: I/O operation on closed file 当处理一个文件对象时, 使用 with 关键字是非常好的方式。在结束后, 它会帮你正确的关闭文件。 而且写起来也比 try - finally 语句块要简短: 1234&gt;&gt;&gt; with open(&#x27;/tmp/foo.txt&#x27;, &#x27;r&#x27;) as f:... read_data = f.read()&gt;&gt;&gt; f.closedTrue pickle 模块 python的pickle模块实现了基本的数据序列和反序列化。 通过pickle模块的序列化操作我们能够将程序中运行的对象信息保存到文件中去，永久存储。 通过pickle模块的反序列化操作，我们能够从文件中创建上一次程序保存的对象。 基本接口： 1pickle.dump(obj, file, [,protocol]) 有了 pickle 这个对象, 就能对 file 以读取的形式打开: 1x = pickle.load(file) 注解：从 file 中读取一个字符串，并将它重构为原来的python对象。 file: 类文件对象，有read()和readline()接口。 12345678910111213141516171819import pickle# 使用pickle模块将数据对象保存到文件data1 = &#123;&#x27;a&#x27;: [1, 2.0, 3, 4+6j], &#x27;b&#x27;: (&#x27;string&#x27;, u&#x27;Unicode string&#x27;), &#x27;c&#x27;: None&#125;selfref_list = [1, 2, 3]selfref_list.append(selfref_list)output = open(&#x27;data.pkl&#x27;, &#x27;wb&#x27;)# Pickle dictionary using protocol 0.pickle.dump(data1, output)# Pickle the list using the highest protocol available.pickle.dump(selfref_list, output, -1)output.close() 123456789101112import pprint, pickle#使用pickle模块从文件中重构python对象pkl_file = open(&#x27;data.pkl&#x27;, &#x27;rb&#x27;)data1 = pickle.load(pkl_file)pprint.pprint(data1)data2 = pickle.load(pkl_file)pprint.pprint(data2)pkl_file.close() File open()方法 Python open() 方法用于打开一个文件，并返回文件对象，在对文件进行处理过程都需要使用到这个函数，如果该文件无法被打开，会抛出 OSError。 注意：使用 open() 方法一定要保证关闭文件对象，即调用 close() 方法。 open() 函数常用形式是接收两个参数：文件名(file)和模式(mode)。 1open(file, mode=&#x27;r&#x27;) 完整的语法格式为： 1open(file, mode=&#x27;r&#x27;, buffering=-1, encoding=None, errors=None, newline=None, closefd=True, opener=None) 参数说明: file: 必需，文件路径（相对或者绝对路径）。 mode: 可选，文件打开模式 buffering: 设置缓冲 encoding: 一般使用utf8 errors: 报错级别 newline: 区分换行符 closefd: 传入的file参数类型 opener: 设置自定义开启器，开启器的返回值必须是一个打开的文件描述符。 mode 参数有： 模式 描述 t 文本模式 (默认)。 x 写模式，新建一个文件，如果该文件已存在则会报错。 b 二进制模式。 + 打开一个文件进行更新(可读可写)。 U 通用换行模式（Python 3 不支持）。 r 以只读方式打开文件。文件的指针将会放在文件的开头。这是默认模式。 rb 以二进制格式打开一个文件用于只读。文件指针将会放在文件的开头。这是默认模式。一般用于非文本文件如图片等。 r+ 打开一个文件用于读写。文件指针将会放在文件的开头。 rb+ 以二进制格式打开一个文件用于读写。文件指针将会放在文件的开头。一般用于非文本文件如图片等。 w 打开一个文件只用于写入。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。 wb 以二进制格式打开一个文件只用于写入。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。一般用于非文本文件如图片等。 w+ 打开一个文件用于读写。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。 wb+ 以二进制格式打开一个文件用于读写。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。一般用于非文本文件如图片等。 a 打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。 ab 以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。 a+ 打开一个文件用于读写。如果该文件已存在，文件指针将会放在文件的结尾。文件打开时会是追加模式。如果该文件不存在，创建新文件用于读写。 ab+ 以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。如果该文件不存在，创建新文件用于读写。 默认为文本模式，如果要以二进制模式打开，加上 b 。 file 对象 file 对象使用 open 函数来创建，下表列出了 file 对象常用的函数： 序号 方法及描述 1 file.close()关闭文件。关闭后文件不能再进行读写操作。 2 file.flush()刷新文件内部缓冲，直接把内部缓冲区的数据立刻写入文件, 而不是被动的等待输出缓冲区写入。 3 file.fileno()返回一个整型的文件描述符(file descriptor FD 整型), 可以用在如os模块的read方法等一些底层操作上。 4 file.isatty()如果文件连接到一个终端设备返回 True，否则返回 False。 5 file.next()Python 3 中的 File 对象不支持 next() 方法。返回文件下一行。 6 [file.read(size])从文件读取指定的字节数，如果未给定或为负则读取所有。 7 [file.readline(size])读取整行，包括 “\\n” 字符。 8 [file.readlines(sizeint])读取所有行并返回列表，若给定sizeint&gt;0，返回总和大约为sizeint字节的行, 实际读取值可能比 sizeint 较大, 因为需要填充缓冲区。 9 [file.seek(offset, whence])移动文件读取指针到指定位置 10 file.tell()返回文件当前位置。 11 [file.truncate(size])从文件的首行首字符开始截断，截断文件为 size 个字符，无 size 表示从当前位置截断；截断之后后面的所有字符被删除，其中 windows 系统下的换行代表2个字符大小。 12 file.write(str)将字符串写入文件，返回的是写入的字符长度。 13 file.writelines(sequence)向文件写入一个序列字符串列表，如果需要换行则要自己加入每行的换行符。 OSos 模块提供了非常丰富的方法用来处理文件和目录。常用的方法如下表所示： 序号 方法及描述 1 os.access(path, mode) 检验权限模式 2 os.chdir(path) 改变当前工作目录 3 os.chflags(path, flags) 设置路径的标记为数字标记。 4 os.chmod(path, mode) 更改权限 5 os.chown(path, uid, gid) 更改文件所有者 6 os.chroot(path) 改变当前进程的根目录 7 os.close(fd) 关闭文件描述符 fd 8 os.closerange(fd_low, fd_high) 关闭所有文件描述符，从 fd_low (包含) 到 fd_high (不包含), 错误会忽略 9 os.dup(fd) 复制文件描述符 fd 10 os.dup2(fd, fd2) 将一个文件描述符 fd 复制到另一个 fd2 11 os.fchdir(fd) 通过文件描述符改变当前工作目录 12 os.fchmod(fd, mode) 改变一个文件的访问权限，该文件由参数fd指定，参数mode是Unix下的文件访问权限。 13 os.fchown(fd, uid, gid) 修改一个文件的所有权，这个函数修改一个文件的用户ID和用户组ID，该文件由文件描述符fd指定。 14 os.fdatasync(fd) 强制将文件写入磁盘，该文件由文件描述符fd指定，但是不强制更新文件的状态信息。 15 [os.fdopen(fd, mode[, bufsize]]) 通过文件描述符 fd 创建一个文件对象，并返回这个文件对象 16 os.fpathconf(fd, name) 返回一个打开的文件的系统配置信息。name为检索的系统配置的值，它也许是一个定义系统值的字符串，这些名字在很多标准中指定（POSIX.1, Unix 95, Unix 98, 和其它）。 17 os.fstat(fd) 返回文件描述符fd的状态，像stat()。 18 os.fstatvfs(fd) 返回包含文件描述符fd的文件的文件系统的信息，Python 3.3 相等于 statvfs()。 19 os.fsync(fd) 强制将文件描述符为fd的文件写入硬盘。 20 os.ftruncate(fd, length) 裁剪文件描述符fd对应的文件, 所以它最大不能超过文件大小。 21 os.getcwd() 返回当前工作目录 22 os.getcwdb() 返回一个当前工作目录的Unicode对象 23 os.isatty(fd) 如果文件描述符fd是打开的，同时与tty(-like)设备相连，则返回true, 否则False。 24 os.lchflags(path, flags) 设置路径的标记为数字标记，类似 chflags()，但是没有软链接 25 os.lchmod(path, mode) 修改连接文件权限 26 os.lchown(path, uid, gid) 更改文件所有者，类似 chown，但是不追踪链接。 27 os.link(src, dst) 创建硬链接，名为参数 dst，指向参数 src 28 os.listdir(path) 返回path指定的文件夹包含的文件或文件夹的名字的列表。 29 os.lseek(fd, pos, how) 设置文件描述符 fd当前位置为pos, how方式修改: SEEK_SET 或者 0 设置从文件开始的计算的pos; SEEK_CUR或者 1 则从当前位置计算; os.SEEK_END或者2则从文件尾部开始. 在unix，Windows中有效 30 os.lstat(path) 像stat(),但是没有软链接 31 os.major(device) 从原始的设备号中提取设备major号码 (使用stat中的st_dev或者st_rdev field)。 32 os.makedev(major, minor) 以major和minor设备号组成一个原始设备号 33 [os.makedirs(path, mode]) 递归文件夹创建函数。像mkdir(), 但创建的所有intermediate-level文件夹需要包含子文件夹。 34 os.minor(device) 从原始的设备号中提取设备minor号码 (使用stat中的st_dev或者st_rdev field )。 35 [os.mkdir(path, mode]) 以数字mode的mode创建一个名为path的文件夹.默认的 mode 是 0777 (八进制)。 36 [os.mkfifo(path, mode]) 创建命名管道，mode 为数字，默认为 0666 (八进制) 37 [os.mknod(filename, mode=0600, device]) 创建一个名为filename文件系统节点（文件，设备特别文件或者命名pipe）。 38 [os.open(file, flags, mode]) 打开一个文件，并且设置需要的打开选项，mode参数是可选的 39 os.openpty() 打开一个新的伪终端对。返回 pty 和 tty的文件描述符。 40 os.pathconf(path, name) 返回相关文件的系统配置信息。 41 os.pipe() 创建一个管道. 返回一对文件描述符(r, w) 分别为读和写 42 [os.popen(command, mode[, bufsize]]) 从一个 command 打开一个管道 43 os.read(fd, n) 从文件描述符 fd 中读取最多 n 个字节，返回包含读取字节的字符串，文件描述符 fd对应文件已达到结尾, 返回一个空字符串。 44 os.readlink(path) 返回软链接所指向的文件 45 os.remove(path) 删除路径为path的文件。如果path 是一个文件夹，将抛出OSError; 查看下面的rmdir()删除一个 directory。 46 os.removedirs(path) 递归删除目录。 47 os.rename(src, dst) 重命名文件或目录，从 src 到 dst 48 os.renames(old, new) 递归地对目录进行更名，也可以对文件进行更名。 49 os.rmdir(path) 删除path指定的空目录，如果目录非空，则抛出一个OSError异常。 50 os.stat(path) 获取path指定的路径的信息，功能等同于C API中的stat()系统调用。 51 [os.stat_float_times(newvalue]) 决定stat_result是否以float对象显示时间戳 52 os.statvfs(path) 获取指定路径的文件系统统计信息 53 os.symlink(src, dst) 创建一个软链接 54 os.tcgetpgrp(fd) 返回与终端fd（一个由os.open()返回的打开的文件描述符）关联的进程组 55 os.tcsetpgrp(fd, pg) 设置与终端fd（一个由os.open()返回的打开的文件描述符）关联的进程组为pg。 56 os.tempnam([dir[, prefix]]) Python3 中已删除。返回唯一的路径名用于创建临时文件。 57 os.tmpfile() Python3 中已删除。返回一个打开的模式为(w+b)的文件对象 .这文件对象没有文件夹入口，没有文件描述符，将会自动删除。 58 os.tmpnam() Python3 中已删除。为创建一个临时文件返回一个唯一的路径 59 os.ttyname(fd) 返回一个字符串，它表示与文件描述符fd 关联的终端设备。如果fd 没有与终端设备关联，则引发一个异常。 60 os.unlink(path) 删除文件路径 61 os.utime(path, times) 返回指定的path文件的访问和修改的时间。 62 [os.walk(top[, topdown=True[, onerror=None[, followlinks=False]]])](https://www.runoob.com/python3/python3-os-walk.html) 输出在文件夹中的文件名通过在树中游走，向上或者向下。 63 os.write(fd, str) 写入字符串到文件描述符 fd中. 返回实际写入的字符串长度 64 os.path 模块 获取文件的属性信息。 65 os.pardir() 获取当前目录的父目录，以字符串形式显示目录名。 错误与异常处理 语法错误 - 语法分析器检测到错误 异常 -运行期检测到的错误 异常处理 try/except 以下例子中，让用户输入一个合法的整数，但是允许用户中断这个程序（使用 Control-C 或者操作系统提供的方法）。用户中断的信息会引发一个 KeyboardInterrupt 异常。 123456while True: try: x = int(input(&quot;请输入一个数字: &quot;)) break except ValueError: print(&quot;您输入的不是数字，请再次尝试输入！&quot;) try 语句按照如下方式工作； 首先，执行 try 子句（在关键字 try 和关键字 except 之间的语句）。 如果没有异常发生，忽略 except 子句，try 子句执行后结束。 如果在执行 try 子句的过程中发生了异常，那么 try 子句余下的部分将被忽略。如果异常的类型和 except 之后的名称相符，那么对应的 except 子句将被执行。 如果一个异常没有与任何的 except 匹配，那么这个异常将会传递给上层的 try 中。 一个 try 语句可能包含多个except子句，分别来处理不同的特定的异常。最多只有一个分支会被执行。 处理程序将只针对对应的 try 子句中的异常进行处理，而不是其他的 try 的处理程序中的异常。 一个except子句可以同时处理多个异常，这些异常将被放在一个括号里成为一个元组，例如: 12except (RuntimeError, TypeError, NameError): pass 最后一个except子句可以忽略异常的名称，它将被当作通配符使用。你可以使用这种方法打印一个错误信息，然后再次把异常抛出。 12345678910111213import systry: f = open(&#x27;myfile.txt&#x27;) s = f.readline() i = int(s.strip())except OSError as err: print(&quot;OS error: &#123;0&#125;&quot;.format(err))except ValueError: print(&quot;Could not convert data to an integer.&quot;)except: print(&quot;Unexpected error:&quot;, sys.exc_info()[0]) raise try/except…else try/except 语句还有一个可选的 else 子句，如果使用这个子句，那么必须放在所有的 except 子句之后。 else 子句将在 try 子句没有发生任何异常的时候执行。 12345678for arg in sys.argv[1:]: try: f = open(arg, &#x27;r&#x27;) except IOError: print(&#x27;cannot open&#x27;, arg) else: print(arg, &#x27;has&#x27;, len(f.readlines()), &#x27;lines&#x27;) f.close() 使用 else 子句比把所有的语句都放在 try 子句里面要好，这样可以避免一些意想不到，而 except 又无法捕获的异常。 异常处理并不仅仅处理那些直接发生在 try 子句中的异常，而且还能处理子句中调用的函数（甚至间接调用的函数）里抛出的异常。例如: 12345678&gt;&gt;&gt; def this_fails(): x = 1/0&gt;&gt;&gt; try: this_fails() except ZeroDivisionError as err: print(&#x27;Handling run-time error:&#x27;, err) Handling run-time error: int division or modulo by zero try-finally try-finally 语句无论是否发生异常都将执行最后的代码。 123456789101112try: runoob()except AssertionError as error: print(error)else: try: with open(&#x27;file.log&#x27;) as file: read_data = file.read() except FileNotFoundError as fnf_error: print(fnf_error)finally: print(&#x27;这句话，无论异常是否发生都会执行。&#x27;) ​ 抛出异常 Python 使用 raise 语句抛出一个指定的异常。 raise语法格式如下： 1raise [Exception [, args [, traceback]]] 123456789x = 10if x &gt; 5: raise Exception(&#x27;x 不能大于 5。x 的值为: &#123;&#125;&#x27;.format(x))执行以上代码会触发异常：Traceback (most recent call last): File &quot;test.py&quot;, line 3, in &lt;module&gt; raise Exception(&#x27;x 不能大于 5。x 的值为: &#123;&#125;&#x27;.format(x))Exception: x 不能大于 5。x 的值为: 10 raise 唯一的一个参数指定了要被抛出的异常。它必须是一个异常的实例或者是异常的类（也就是 Exception 的子类）。 如果你只想知道这是否抛出了一个异常，并不想去处理它，那么一个简单的 raise 语句就可以再次把它抛出。 1234567891011&gt;&gt;&gt; try: raise NameError(&#x27;HiThere&#x27;) except NameError: print(&#x27;An exception flew by!&#x27;) raise An exception flew by!Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 2, in ?NameError: HiThere 理解： 用户自定义异常 创建一个新的异常类来拥有自己的异常。异常类继承自 Exception 类，可以直接继承，或者间接继承，例如: 12345678910111213141516&gt;&gt;&gt; class MyError(Exception): def __init__(self, value): self.value = value def __str__(self): return repr(self.value) &gt;&gt;&gt; try: raise MyError(2*2) except MyError as e: print(&#x27;My exception occurred, value:&#x27;, e.value) My exception occurred, value: 4&gt;&gt;&gt; raise MyError(&#x27;oops!&#x27;)Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in ?__main__.MyError: &#x27;oops!&#x27; 当创建一个模块有可能抛出多种不同的异常时，一种通常的做法是为这个包建立一个基础异常类，然后基于这个基础类为不同的错误情况创建不同的子类: 123456789101112131415161718192021222324252627282930class Error(Exception): &quot;&quot;&quot;Base class for exceptions in this module.&quot;&quot;&quot; passclass InputError(Error): &quot;&quot;&quot;Exception raised for errors in the input. Attributes: expression -- input expression in which the error occurred message -- explanation of the error &quot;&quot;&quot; def __init__(self, expression, message): self.expression = expression self.message = messageclass TransitionError(Error): &quot;&quot;&quot;Raised when an operation attempts a state transition that&#x27;s not allowed. Attributes: previous -- state at beginning of transition next -- attempted new state message -- explanation of why the specific transition is not allowed &quot;&quot;&quot; def __init__(self, previous, next, message): self.previous = previous self.next = next self.message = message 定义清理行为 try 语句还有另外一个可选的子句，它定义了无论在任何情况下都会执行的清理行为。 例如: 123456789&gt;&gt;&gt; try:... raise KeyboardInterrupt... finally:... print(&#x27;Goodbye, world!&#x27;)...Goodbye, world!Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 2, in &lt;module&gt;KeyboardInterrupt 以上例子不管 try 子句里面有没有发生异常，finally 子句都会执行。 如果一个异常在 try 子句里（或者在 except 和 else 子句里）被抛出，而又没有任何的 except 把它截住，那么这个异常会在 finally 子句执行后被抛出。 12345678910111213141516171819202122&gt;&gt;&gt; def divide(x, y): try: result = x / y except ZeroDivisionError: print(&quot;division by zero!&quot;) else: print(&quot;result is&quot;, result) finally: print(&quot;executing finally clause&quot;) &gt;&gt;&gt; divide(2, 1)result is 2.0executing finally clause&gt;&gt;&gt; divide(2, 0)division by zero!executing finally clause&gt;&gt;&gt; divide(&quot;2&quot;, &quot;1&quot;)executing finally clauseTraceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in ? File &quot;&lt;stdin&gt;&quot;, line 3, in divideTypeError: unsupported operand type(s) for /: &#x27;str&#x27; and &#x27;str&#x27; 预定义的清理行为 一些对象定义了标准的清理行为，无论系统是否成功的使用了它，一旦不需要它了，那么这个标准的清理行为就会执行。 这面这个例子展示了尝试打开一个文件，然后把内容打印到屏幕上: 12for line in open(&quot;myfile.txt&quot;): print(line, end=&quot;&quot;) 以上这段代码的问题是，当执行完毕后，文件会保持打开状态，并没有被关闭。 关键词 with 语句就可以保证诸如文件之类的对象在使用完之后一定会正确的执行他的清理方法: 123with open(&quot;myfile.txt&quot;) as f: for line in f: print(line, end=&quot;&quot;) 以上这段代码执行完毕后，就算在处理过程中出问题了，文件 f 总是会关闭。 面向对象 类(Class): 用来描述具有相同的属性和方法的对象的集合。它定义了该集合中每个对象所共有的属性和方法。对象是类的实例。 方法：类中定义的函数。 类变量：类变量在整个实例化的对象中是公用的。类变量定义在类中且在函数体之外。类变量通常不作为实例变量使用。 数据成员：类变量或者实例变量用于处理类及其实例对象的相关的数据。 方法重写：如果从父类继承的方法不能满足子类的需求，可以对其进行改写，这个过程叫方法的覆盖（override），也称为方法的重写。 局部变量：定义在方法中的变量，只作用于当前实例的类。 实例变量：在类的声明中，属性是用变量来表示的，这种变量就称为实例变量，实例变量就是一个用 self 修饰的变量。 继承：即一个派生类（derived class）继承基类（base class）的字段和方法。继承也允许把一个派生类的对象作为一个基类对象对待。例如，有这样一个设计：一个Dog类型的对象派生自Animal类，这是模拟”是一个（is-a）”关系（例图，Dog是一个Animal）。 实例化：创建一个类的实例，类的具体对象。 对象：通过类定义的数据结构实例。对象包括两个数据成员（类变量和实例变量）和方法。 和其它编程语言相比，Python 在尽可能不增加新的语法和语义的情况下加入了类机制。 Python中的类提供了面向对象编程的所有基本功能：类的继承机制允许多个基类，派生类可以覆盖基类中的任何方法，方法中可以调用基类中的同名方法。 对象可以包含任意数量和类型的数据。 类定义 123456class ClassName: &lt;statement-1&gt; . . . &lt;statement-N&gt; 类实例化后，可以使用其属性，实际上，创建一个类之后，可以通过类名访问其属性。 类对象 类对象支持两种操作：属性引用和实例化。 属性引用使用和 Python 中所有的属性引用一样的标准语法：obj.name。 类对象创建后，类命名空间中所有的命名都是有效属性名。所以如果类定义是这样: 1234567891011121314#!/usr/bin/python3 class MyClass: &quot;&quot;&quot;一个简单的类实例&quot;&quot;&quot; i = 12345 def f(self): return &#x27;hello world&#x27; # 实例化类x = MyClass() # 访问类的属性和方法print(&quot;MyClass 类的属性 i 为：&quot;, x.i)print(&quot;MyClass 类的方法 f 输出为：&quot;, x.f()) 类有一个名为 init() 的特殊方法（构造方法），该方法在类实例化时会自动调用，像下面这样： 12def __init__(self): self.data = [] self是类的一个实例，而非类 类的方法与普通的函数只有一个特别的区别——它们必须有一个额外的第一个参数名称, 按照惯例它的名称是 self。 1234567891011class Test: def prt(self): print(self) print(self.__class__) t = Test()t.prt()以上实例执行结果为：&lt;__main__.Test instance at 0x100771878&gt;__main__.Test 从执行结果可以很明显的看出，self 代表的是类的实例，代表当前对象的地址，而 self.class 则指向类。 self 不是 python 关键字，我们把他换成 runoob 也是可以正常执行的: 123456class Test: def prt(runoob): print(runoob) print(runoob.__class__) t = Test() t.prt() 以上实例执行结果为： 12&lt;__main__.Test instance at 0x100771878&gt;__main__.Test 类方法 在类的内部，使用 def 关键字来定义一个方法，与一般函数定义不同，类方法必须包含参数 self, 且为第一个参数，self 代表的是类的实例。 123456789101112131415161718192021#类定义class people: #定义基本属性 name = &#x27;&#x27; age = 0 #定义私有属性,私有属性在类外部无法直接进行访问 __weight = 0 #定义构造方法 def __init__(self,n,a,w): self.name = n self.age = a self.__weight = w def speak(self): print(&quot;%s 说: 我 %d 岁。&quot; %(self.name,self.age)) # 实例化类p = people(&#x27;runoob&#x27;,10,30)p.speak()执行以上程序输出结果为：runoob 说: 我 10 岁。 继承 Python 同样支持类的继承，如果一种语言不支持继承，类就没有什么意义。派生类的定义如下所示: 123456class DerivedClassName(BaseClassName): &lt;statement-1&gt; . . . &lt;statement-N&gt; 子类（派生类 DerivedClassName）会继承父类（基类 BaseClassName）的属性和方法。 BaseClassName（实例中的基类名）必须与派生类定义在一个作用域内。除了类，还可以用表达式，基类定义在另一个模块中时这一点非常有用: 1class DerivedClassName(modname.BaseClassName): 1234567891011121314151617181920212223242526272829303132333435#!/usr/bin/python3 #类定义class people: #定义基本属性 name = &#x27;&#x27; age = 0 #定义私有属性,私有属性在类外部无法直接进行访问 __weight = 0 #定义构造方法 def __init__(self,n,a,w): self.name = n self.age = a self.__weight = w def speak(self): print(&quot;%s 说: 我 %d 岁。&quot; %(self.name,self.age)) #单继承示例class student(people): grade = &#x27;&#x27; def __init__(self,n,a,w,g): #调用父类的构函 people.__init__(self,n,a,w) self.grade = g #覆写父类的方法 def speak(self): print(&quot;%s 说: 我 %d 岁了，我在读 %d 年级&quot;%(self.name,self.age,self.grade)) s = student(&#x27;ken&#x27;,10,60,3)s.speak()执行以上程序输出结果为：ken 说: 我 10 岁了，我在读 3 年级 多继承 Python同样有限的支持多继承形式。多继承的类定义形如下例: 123456class DerivedClassName(Base1, Base2, Base3): &lt;statement-1&gt; . . . &lt;statement-N&gt; 需要注意圆括号中父类的顺序，若是父类中有相同的方法名，而在子类使用时未指定，python从左至右搜索 即方法在子类中未找到时，从左到右查找父类中是否包含方法。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#类定义class people: #定义基本属性 name = &#x27;&#x27; age = 0 #定义私有属性,私有属性在类外部无法直接进行访问 __weight = 0 #定义构造方法 def __init__(self,n,a,w): self.name = n self.age = a self.__weight = w def speak(self): print(&quot;%s 说: 我 %d 岁。&quot; %(self.name,self.age)) #单继承示例class student(people): grade = &#x27;&#x27; def __init__(self,n,a,w,g): #调用父类的构函 people.__init__(self,n,a,w) self.grade = g #覆写父类的方法 def speak(self): print(&quot;%s 说: 我 %d 岁了，我在读 %d 年级&quot;%(self.name,self.age,self.grade)) #另一个类，多重继承之前的准备class speaker(): topic = &#x27;&#x27; name = &#x27;&#x27; def __init__(self,n,t): self.name = n self.topic = t def speak(self): print(&quot;我叫 %s，我是一个演说家，我演讲的主题是 %s&quot;%(self.name,self.topic)) #多重继承class sample(speaker,student): a =&#x27;&#x27; def __init__(self,n,a,w,g,t): student.__init__(self,n,a,w,g) speaker.__init__(self,n,t) test = sample(&quot;Tim&quot;,25,80,4,&quot;Python&quot;)test.speak() #方法名同，默认调用的是在括号中参数位置排前父类的方法执行以上程序输出结果为：我叫 Tim，我是一个演说家，我演讲的主题是 Python 方法重写 如果你的父类方法的功能不能满足你的需求，你可以在子类重写你父类的方法，实例如下： 12345678910111213141516#!/usr/bin/python3 class Parent: # 定义父类 def myMethod(self): print (&#x27;调用父类方法&#x27;) class Child(Parent): # 定义子类 def myMethod(self): print (&#x27;调用子类方法&#x27;) c = Child() # 子类实例c.myMethod() # 子类调用重写方法super(Child,c).myMethod() #用子类对象调用父类已被覆盖的方法执行以上程序输出结果为：调用子类方法调用父类方法 类属性与方法 私有属性 __private_attrs：两个下划线开头，声明该属性为私有，不能在类的外部被使用或直接访问。在类内部的方法中使用时 self.__private_attrs。 12345678910111213141516171819202122232425#!/usr/bin/python3 class JustCounter: __secretCount = 0 # 私有变量 publicCount = 0 # 公开变量 def count(self): self.__secretCount += 1 self.publicCount += 1 print (self.__secretCount) counter = JustCounter()counter.count()counter.count()print (counter.publicCount)print (counter.__secretCount) # 报错，实例不能访问私有变量执行以上程序输出结果为：122Traceback (most recent call last): File &quot;test.py&quot;, line 16, in &lt;module&gt; print (counter.__secretCount) # 报错，实例不能访问私有变量AttributeError: &#x27;JustCounter&#x27; object has no attribute &#x27;__secretCount&#x27; 类的方法 在类的内部，使用 def 关键字来定义一个方法，与一般函数定义不同，类方法必须包含参数 self，且为第一个参数，self 代表的是类的实例。 self 的名字并不是规定死的，也可以使用 this，但是最好还是按照约定使用 self。 私有方法 __private_method：两个下划线开头，声明该方法为私有方法，只能在类的内部调用 ，不能在类的外部调用。self.__private_methods。 123456789101112131415161718192021class Site: def __init__(self, name, url): self.name = name # public self.__url = url # private def who(self): print(&#x27;name : &#x27;, self.name) print(&#x27;url : &#x27;, self.__url) def __foo(self): # 私有方法 print(&#x27;这是私有方法&#x27;) def foo(self): # 公共方法 print(&#x27;这是公共方法&#x27;) self.__foo() x = Site(&#x27;菜鸟教程&#x27;, &#x27;www.runoob.com&#x27;)x.who() # 正常输出x.foo() # 正常输出x.__foo() # 报错 专有方法 1234567891011121314__init__ : 构造函数，在生成对象时调用__del__ : 析构函数，释放对象时使用__repr__ : 打印，转换__setitem__ : 按照索引赋值__getitem__: 按照索引获取值__len__: 获得长度__cmp__: 比较运算__call__: 函数调用__add__: 加运算__sub__: 减运算__mul__: 乘运算__truediv__: 除运算__mod__: 求余运算__pow__: 乘方 运算符重载 1234567891011121314151617class Vector: def __init__(self, a, b): self.a = a self.b = b def __str__(self): return &#x27;Vector (%d, %d)&#x27; % (self.a, self.b) def __add__(self,other): return Vector(self.a + other.a, self.b + other.b) v1 = Vector(2,10)v2 = Vector(5,-2)print (v1 + v2)以上代码执行结果如下所示:Vector(7,8) 命名空间/作用域命名空间(Namespace)是从名称到对象的映射，大部分的命名空间都是通过 Python 字典来实现的。 命名空间提供了在项目中避免名字冲突的一种方法。各个命名空间是独立的，没有任何关系的，所以一个命名空间中不能有重名，但不同的命名空间是可以重名而没有任何影响。 一般有三种命名空间： 内置名称（built-in names）， Python 语言内置的名称，比如函数名 abs、char 和异常名称 BaseException、Exception 等等。 全局名称（global names），模块中定义的名称，记录了模块的变量，包括函数、类、其它导入的模块、模块级的变量和常量。 局部名称（local names），函数中定义的名称，记录了函数的变量，包括函数的参数和局部定义的变量。（类中定义的也是） 命名空间查找顺序: 假设我们要使用变量 runoob，则 Python 的查找顺序为：局部的命名空间去 -&gt; 全局命名空间 -&gt; 内置命名空间。 如果找不到变量 runoob，它将放弃查找并引发一个 NameError 异常: 1NameError: name &#x27;runoob&#x27; is not defined。 命名空间的生命周期： 命名空间的生命周期取决于对象的作用域，如果对象执行完成，则该命名空间的生命周期就结束。 因此，我们无法从外部命名空间访问内部命名空间的对象。 作用域 作用域就是一个 Python 程序可以直接访问命名空间的正文区域。 在一个 python 程序中，直接访问一个变量，会从内到外依次访问所有的作用域直到找到，否则会报未定义的错误。 Python 中，程序的变量并不是在哪个位置都可以访问的，访问权限决定于这个变量是在哪里赋值的。 变量的作用域决定了在哪一部分程序可以访问哪个特定的变量名称。Python 的作用域一共有4种，分别是： 有四种作用域： L（Local）：最内层，包含局部变量，比如一个函数/方法内部。 E（Enclosing）：包含了非局部(non-local)也非全局(non-global)的变量。比如两个嵌套函数，一个函数（或类） A 里面又包含了一个函数 B ，那么对于 B 中的名称来说 A 中的作用域就为 nonlocal。 G（Global）：当前脚本的最外层，比如当前模块的全局变量。 B（Built-in）： 包含了内建的变量/关键字等，最后被搜索。 规则顺序： L –&gt; E –&gt; G –&gt; B。 在局部找不到，便会去局部外的局部找（例如闭包），再找不到就会去全局找，再者去内置中找。 全局和局部变量 定义在函数内部的变量拥有一个局部作用域，定义在函数外的拥有全局作用域。 局部变量只能在其被声明的函数内部访问，而全局变量可以在整个程序范围内访问。调用函数时，所有在函数内声明的变量名称都将被加入到作用域中。 global 和nolocal 关键字 当内部作用域想修改外部作用域的变量时，就要用到 global 和 nonlocal 关键字了 12345678910111213num = 1def fun1(): global num # 需要使用 global 关键字声明 print(num) num = 123 print(num)fun1()print(num)以上实例输出结果：1123123 如果要修改嵌套作用域（enclosing 作用域，外层非全局作用域）中的变量则需要 nonlocal 关键字了 12345678910111213def outer(): num = 10 def inner(): nonlocal num # nonlocal关键字声明 num = 100 print(num) inner() print(num)outer()以上实例输出结果：100100 标准库 二、高级 正则表达式 正则表达式是一个特殊的字符序列，它能帮助你方便的检查一个字符串是否与某种模式匹配。 Python 自1.5版本起增加了re 模块，它提供 Perl 风格的正则表达式模式。 re 模块使 Python 语言拥有全部的正则表达式功能。 compile 函数根据一个模式字符串和可选的标志参数生成一个正则表达式对象。该对象拥有一系列方法用于正则表达式匹配和替换。 re 模块也提供了与这些方法功能完全一致的函数，这些函数使用一个模式字符串做为它们的第一个参数。 匹配字符串 re.match() 函数 re.match 尝试从字符串的起始位置匹配一个模式，匹配成功re.match方法返回一个匹配的对象，否则返回None。 1re.match(pattern, string, flags=0) 参数 描述 pattern 匹配的正则表达式 string 要匹配的字符串。 flags 标志位，用于控制正则表达式的匹配方式，如：是否区分大小写，多行匹配等等。参见：正则表达式修饰符 - 可选标志 re.search() re.search 扫描整个字符串并返回第一个成功的匹配。匹配成功re.search方法返回一个匹配的对象，否则返回None。 re.match 只匹配字符串的开始，如果字符串开始不符合正则表达式，则匹配失败，函数返回 None，而 re.search 匹配整个字符串，直到找到一个匹配。 检索替换 re.sub() Python 的re模块提供了re.sub用于替换字符串中的匹配项。 语法： 1re.sub(pattern, repl, string, count=0, flags=0) pattern : 正则中的模式字符串。 repl : 替换的字符串，也可为一个函数。 string : 要被查找替换的原始字符串。 count : 模式匹配后替换的最大次数，默认 0 表示替换所有的匹配。 flags : 编译时用的匹配模式，数字形式。 CGI编程 MySql(mysql-connector) MySql(pymysql) 网络编程 Python 提供了两个级别访问的网络服务。： 低级别的网络服务支持基本的 Socket，它提供了标准的 BSD Sockets API，可以访问底层操作系统Socket接口的全部方法。 高级别的网络服务模块 SocketServer， 它提供了服务器中心类，可以简化网络服务器的开发。 什么是socket? Socket又称”套接字”，应用程序通常通过”套接字”向网络发出请求或者应答网络请求，使主机间或者一台计算机上的进程间可以通讯。 socket()函数 123我们用 socket() 函数来创建套接字，语法格式如下：socket.socket([family[, type[, proto]]]) family: 套接字家族可以是 AF_UNIX 或者 AF_INET type: 套接字类型可以根据是面向连接的还是非连接分为SOCK_STREAM或SOCK_DGRAM protocol: 一般不填默认为0. 函数 描述 服务器端套接字 s.bind() 绑定地址（host,port）到套接字， 在AF_INET下,以元组（host,port）的形式表示地址。 s.listen() 开始TCP监听。backlog指定在拒绝连接之前，操作系统可以挂起的最大连接数量。该值至少为1，大部分应用程序设为5就可以了。 s.accept() 被动接受TCP客户端连接,(阻塞式)等待连接的到来 客户端套接字 s.connect() 主动初始化TCP服务器连接，。一般address的格式为元组（hostname,port），如果连接出错，返回socket.error错误。 s.connect_ex() connect()函数的扩展版本,出错时返回出错码,而不是抛出异常 公共用途的套接字函数 s.recv() 接收TCP数据，数据以字符串形式返回，bufsize指定要接收的最大数据量。flag提供有关消息的其他信息，通常可以忽略。 s.send() 发送TCP数据，将string中的数据发送到连接的套接字。返回值是要发送的字节数量，该数量可能小于string的字节大小。 s.sendall() 完整发送TCP数据，完整发送TCP数据。将string中的数据发送到连接的套接字，但在返回之前会尝试发送所有数据。成功返回None，失败则抛出异常。 s.recvfrom() 接收UDP数据，与recv()类似，但返回值是（data,address）。其中data是包含接收数据的字符串，address是发送数据的套接字地址。 s.sendto() 发送UDP数据，将数据发送到套接字，address是形式为（ipaddr，port）的元组，指定远程地址。返回值是发送的字节数。 s.close() 关闭套接字 s.getpeername() 返回连接套接字的远程地址。返回值通常是元组（ipaddr,port）。 s.getsockname() 返回套接字自己的地址。通常是一个元组(ipaddr,port) s.setsockopt(level,optname,value) 设置给定套接字选项的值。 s.getsockopt(level,optname[.buflen]) 返回套接字选项的值。 s.settimeout(timeout) 设置套接字操作的超时期，timeout是一个浮点数，单位是秒。值为None表示没有超时期。一般，超时期应该在刚创建套接字时设置，因为它们可能用于连接的操作（如connect()） s.gettimeout() 返回当前超时期的值，单位是秒，如果没有设置超时期，则返回None。 s.fileno() 返回套接字的文件描述符。 s.setblocking(flag) 如果 flag 为 False，则将套接字设为非阻塞模式，否则将套接字设为阻塞模式（默认值）。非阻塞模式下，如果调用 recv() 没有发现任何数据，或 send() 调用无法立即发送数据，那么将引起 socket.error 异常。 s.makefile() 创建一个与该套接字相关连的文件 实例 服务端 我们使用 socket 模块的 socket 函数来创建一个 socket 对象。socket 对象可以通过调用其他函数来设置一个 socket 服务。 现在我们可以通过调用 bind(hostname, port) 函数来指定服务的 *port(端口)*。 接着，我们调用 socket 对象的 accept 方法。该方法等待客户端的连接，并返回 connection 对象，表示已连接到客户端 12345678910111213141516171819202122232425262728293031#!/usr/bin/python3# 文件名：server.py# 导入 socket、sys 模块import socketimport sys# 创建 socket 对象serversocket = socket.socket( socket.AF_INET, socket.SOCK_STREAM)# 获取本地主机名host = socket.gethostname()port = 9999# 绑定端口号serversocket.bind((host, port))# 设置最大连接数，超过后排队serversocket.listen(5)while True: # 建立客户端连接 clientsocket,addr = serversocket.accept() print(&quot;连接地址: %s&quot; % str(addr)) msg=&#x27;欢迎访问菜鸟教程！&#x27;+ &quot;\\r\\n&quot; clientsocket.send(msg.encode(&#x27;utf-8&#x27;)) clientsocket.close() 客户端 接下来我们写一个简单的客户端实例连接到以上创建的服务。端口号为 9999。 socket.connect(hostname, port ) 方法打开一个 TCP 连接到主机为 hostname 端口为 port 的服务商。连接后我们就可以从服务端获取数据，记住，操作完成后需要关闭连接。 12345678910111213141516171819202122232425#!/usr/bin/python3# 文件名：client.py# 导入 socket、sys 模块import socketimport sys# 创建 socket 对象s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)# 获取本地主机名host = socket.gethostname()# 设置端口号port = 9999# 连接服务，指定主机和端口s.connect((host, port))# 接收小于 1024 字节的数据msg = s.recv(1024)s.close()print (msg.decode(&#x27;utf-8&#x27;)) 现在我们打开两个终端，第一个终端执行 server.py 文件： 1$ python3 server.py 第二个终端执行 client.py 文件： 12$ python3 client.py 欢迎访问菜鸟教程！ 这时我们再打开第一个终端，就会看到有以下信息输出： 1连接地址： (&#x27;192.168.0.118&#x27;, 33397) python Internet模块 以下列出了 Python 网络编程的一些重要模块： 协议 功能用处 端口号 Python 模块 HTTP 网页访问 80 httplib, urllib, xmlrpclib NNTP 阅读和张贴新闻文章，俗称为”帖子” 119 nntplib FTP 文件传输 20 ftplib, urllib SMTP 发送邮件 25 smtplib POP3 接收邮件 110 poplib IMAP4 获取邮件 143 imaplib Telnet 命令行 23 telnetlib Gopher 信息查找 70 gopherlib, urllib SMTP发送发送邮件 多线程 多线程类似于同时执行多个不同程序，多线程运行有如下优点： 使用线程可以把占据长时间的程序中的任务放到后台去处理。 用户界面可以更加吸引人，比如用户点击了一个按钮去触发某些事件的处理，可以弹出一个进度条来显示处理的进度。 程序的运行速度可能加快。 在一些等待的任务实现上如用户输入、文件读写和网络收发数据等，线程就比较有用了。在这种情况下我们可以释放一些珍贵的资源如内存占用等等。 每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口。但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。 每个线程都有他自己的一组CPU寄存器，称为线程的上下文，该上下文反映了线程上次运行该线程的CPU寄存器的状态。 指令指针和堆栈指针寄存器是线程上下文中两个最重要的寄存器，线程总是在进程得到上下文中运行的，这些地址都用于标志拥有线程的进程地址空间中的内存。 线程可以被抢占（中断）。 在其他线程正在运行时，线程可以暂时搁置（也称为睡眠） – 这就是线程的退让。 线程可以分为: 内核线程：由操作系统内核创建和撤销。 用户线程：不需要内核支持而在用户程序中实现的线程。 Python3 线程中常用的两个模块为： _thread threading(推荐使用) thread 模块已被废弃。用户可以使用 threading 模块代替。所以，在 Python3 中不能再使用”thread” 模块。为了兼容性，Python3 将 thread 重命名为 “_thread”。 Python中使用线程有两种方式：函数或者用类来包装线程对象。 函数式：调用 _thread 模块中的start_new_thread()函数来产生新线程。语法如下: 1_thread.start_new_thread ( function, args[, kwargs] ) 参数说明: function - 线程函数。 args - 传递给线程函数的参数,他必须是个tuple类型。 kwargs - 可选参数。 实例 1234567891011121314151617181920212223242526272829303132333435#!/usr/bin/python3import _threadimport time# 为线程定义一个函数def print_time( threadName, delay): count = 0 while count &lt; 5: time.sleep(delay) count += 1 print (&quot;%s: %s&quot; % ( threadName, time.ctime(time.time()) ))# 创建两个线程try: _thread.start_new_thread( print_time, (&quot;Thread-1&quot;, 2, ) ) _thread.start_new_thread( print_time, (&quot;Thread-2&quot;, 4, ) )except: print (&quot;Error: 无法启动线程&quot;)while 1: pass执行以上程序输出结果如下：Thread-1: Wed Jan 5 17:38:08 2022Thread-2: Wed Jan 5 17:38:10 2022Thread-1: Wed Jan 5 17:38:10 2022Thread-1: Wed Jan 5 17:38:12 2022Thread-2: Wed Jan 5 17:38:14 2022Thread-1: Wed Jan 5 17:38:14 2022Thread-1: Wed Jan 5 17:38:16 2022Thread-2: Wed Jan 5 17:38:18 2022Thread-2: Wed Jan 5 17:38:22 2022Thread-2: Wed Jan 5 17:38:26 2022执行以上程后可以按下 ctrl-c 退出。 线程模块 Python3 通过两个标准库 _thread 和 threading 提供对线程的支持。 _thread 提供了低级别的、原始的线程以及一个简单的锁，它相比于 threading 模块的功能还是比较有限的。 threading 模块除了包含 _thread 模块中的所有方法外，还提供的其他方法： threading.currentThread(): 返回当前的线程变量。 threading.enumerate(): 返回一个包含正在运行的线程的list。正在运行指线程启动后、结束前，不包括启动前和终止后的线程。 threading.activeCount(): 返回正在运行的线程数量，与len(threading.enumerate())有相同的结果。 除了使用方法外，线程模块同样提供了Thread类来处理线程，Thread类提供了以下方法: run(): 用以表示线程活动的方法。 start(): 启动线程活动。 join([time]): 等待至线程中止。这阻塞调用线程直至线程的join() 方法被调用中止-正常退出或者抛出未处理的异常-或者是可选的超时发生。 isAlive(): 返回线程是否活动的。 getName(): 返回线程名。 setName(): 设置线程名。 使用threading 模块创建线程 直接从 threading.Thread 继承创建一个新的子类，并实例化后调用 start() 方法启动新线程，即它调用了线程的 run() 方法： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051import threadingimport timeexitFlag = 0class myThread (threading.Thread): def __init__(self, threadID, name, delay): threading.Thread.__init__(self) self.threadID = threadID self.name = name self.delay = delay def run(self): print (&quot;开始线程：&quot; + self.name) print_time(self.name, self.delay, 5) print (&quot;退出线程：&quot; + self.name)def print_time(threadName, delay, counter): while counter: if exitFlag: threadName.exit() time.sleep(delay) print (&quot;%s: %s&quot; % (threadName, time.ctime(time.time()))) counter -= 1# 创建新线程thread1 = myThread(1, &quot;Thread-1&quot;, 1)thread2 = myThread(2, &quot;Thread-2&quot;, 2)# 开启新线程thread1.start()thread2.start()thread1.join()thread2.join()print (&quot;退出主线程&quot;)以上程序执行结果如下；开始线程：Thread-1开始线程：Thread-2Thread-1: Wed Jan 5 17:34:54 2022Thread-2: Wed Jan 5 17:34:55 2022Thread-1: Wed Jan 5 17:34:55 2022Thread-1: Wed Jan 5 17:34:56 2022Thread-2: Wed Jan 5 17:34:57 2022Thread-1: Wed Jan 5 17:34:57 2022Thread-1: Wed Jan 5 17:34:58 2022退出线程：Thread-1Thread-2: Wed Jan 5 17:34:59 2022Thread-2: Wed Jan 5 17:35:01 2022Thread-2: Wed Jan 5 17:35:03 2022退出线程：Thread-2退出主线程 线程同步 如果多个线程共同对某个数据修改，则可能出现不可预料的结果，为了保证数据的正确性，需要对多个线程进行同步。 使用 Thread 对象的 Lock 和 Rlock 可以实现简单的线程同步，这两个对象都有 acquire 方法和 release 方法，对于那些需要每次只允许一个线程操作的数据，可以将其操作放到 acquire 和 release 方法之间。如下： 多线程的优势在于可以同时运行多个任务（至少感觉起来是这样）。但是当线程需要共享数据时，可能存在数据不同步的问题。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253import threadingimport timeclass myThread (threading.Thread): def __init__(self, threadID, name, delay): threading.Thread.__init__(self) self.threadID = threadID self.name = name self.delay = delay def run(self): print (&quot;开启线程： &quot; + self.name) # 获取锁，用于线程同步 threadLock.acquire() print_time(self.name, self.delay, 3) # 释放锁，开启下一个线程 threadLock.release()def print_time(threadName, delay, counter): while counter: time.sleep(delay) print (&quot;%s: %s&quot; % (threadName, time.ctime(time.time()))) counter -= 1threadLock = threading.Lock()threads = []# 创建新线程thread1 = myThread(1, &quot;Thread-1&quot;, 1)thread2 = myThread(2, &quot;Thread-2&quot;, 2)# 开启新线程thread1.start()thread2.start()# 添加线程到线程列表threads.append(thread1)threads.append(thread2)# 等待所有线程完成for t in threads: t.join()print (&quot;退出主线程&quot;)执行以上程序，输出结果为：开启线程： Thread-1开启线程： Thread-2Thread-1: Wed Jan 5 17:36:50 2022Thread-1: Wed Jan 5 17:36:51 2022Thread-1: Wed Jan 5 17:36:52 2022Thread-2: Wed Jan 5 17:36:54 2022Thread-2: Wed Jan 5 17:36:56 2022Thread-2: Wed Jan 5 17:36:58 2022退出主线程W 线程优先级队列（Queue） XML解析 JSON 日期时间 内置函数 MongoDB urllib uWSGI 安装配置 pip","categories":[{"name":"Python","slug":"Python","permalink":"https://hxlpub.github.io/categories/Python/"}],"tags":[{"name":"python","slug":"python","permalink":"https://hxlpub.github.io/tags/python/"}]},{"title":"cv","slug":"cv","date":"2021-09-14T09:26:07.000Z","updated":"2022-03-26T09:01:13.127Z","comments":true,"path":"2021/09/14/cv/","link":"","permalink":"https://hxlpub.github.io/2021/09/14/cv/","excerpt":"","text":"","categories":[{"name":"计算机视觉CV","slug":"计算机视觉CV","permalink":"https://hxlpub.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89CV/"}],"tags":[{"name":"cv","slug":"cv","permalink":"https://hxlpub.github.io/tags/cv/"}]},{"title":"PostgreSQL数据库","slug":"database_redis","date":"2021-09-14T09:26:07.000Z","updated":"2022-03-26T09:01:46.873Z","comments":true,"path":"2021/09/14/database_redis/","link":"","permalink":"https://hxlpub.github.io/2021/09/14/database_redis/","excerpt":"","text":"","categories":[{"name":"数据库","slug":"数据库","permalink":"https://hxlpub.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"pg","slug":"pg","permalink":"https://hxlpub.github.io/tags/pg/"}]},{"title":"postgres数据库之基本操作","slug":"database_pg","date":"2021-09-14T09:26:07.000Z","updated":"2022-03-26T08:20:25.511Z","comments":true,"path":"2021/09/14/database_pg/","link":"","permalink":"https://hxlpub.github.io/2021/09/14/database_pg/","excerpt":"","text":"1.pgadmin工具 2.增删改查 ​ 插入批量记录： ​ 1）生成insertDeviceChannels 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139create or replace function insertDeviceChannels(num_limit integer) returns booleanAS$$declare id integer default 1; devName varchar; channelName varchar; devIndexCode varchar; devIp varchar; devIpEnd1 integer default 1; devIpEnd2 integer default 1; devPort integer default 1001; devExternalCode varchar; channelExternalCode varchar; regionCount integer; regionResourceLimit integer; regionResourceNum integer default 0; regionIndexCode varchar; offsetNum integer default 0;begin select count(o.region_index_code) into regionCount from tb_region o where region_status = &#x27;0&#x27;; raise notice &#x27;regionCount %&#x27; , regionCount; if num_limit % regionCount = 0 then regionResourceLimit := num_limit / regionCount; end if; if num_limit % regionCount &gt; 0 then regionResourceLimit := num_limit / regionCount + 1; end if; while devIpEnd1 &lt;= 100 loop devIpEnd2 := 1; while devIpEnd2 &lt;= 100 loop devip := &#x27;10.33.&#x27; || devIpEnd1 || &#x27;.&#x27; || devIpEnd2; devPort := 1000; while devPort &lt;= 1099 loop devName := devip; devIndexCode := uuid_generate_v4(); if regionIndexCode is null then select region_index_code into regionIndexCode from tb_region where region_status = &#x27;0&#x27; limit 1 offset offsetNum; end if; INSERT INTO public.tb_device (dev_id, dev_index_code, dev_name, dev_addr, dev_port, dev_model, active_device_code, dev_username, dev_password, pwd_strength, dev_type, dev_serial_num, dis_order, dev_capability, manufacturer, treaty_type, driver, sync_iac, remote_status, region_index_code, domain_id, ezviz_user_id, ezviz_dev_code, dev_restype, business_class, description, version, is_cascade, extended_attribute, com_id, data_no, status, create_time, update_time, creator, modifier ) VALUES (uuid_generate_v4(), devIndexCode, devName, devIp, devPort, &#x27;Simulator&#x27;, null, &#x27;admin&#x27;, &#x27;Dg/I6if34PWRn093VjyPqg==&#x27;, 3, null, &#x27;SimulatorDevice&#x27;, 1, &#x27;&#123;&#125;&#x27;, &#x27;hikvision&#x27;, &#x27;hiksdk_net&#x27;, &#x27;drv_vss_hiksdk_general_1.13.100&#x27;, 0, 1, regionIndexCode, 0, null, null, &#x27;&#123;encodeDevice&#125;&#x27;, &#x27;vms_encodeDevice_model&#x27;, null, 0, 0, &#x27;&#123; &quot;zeroChanCount&quot;: &quot;0&quot;, &quot;analogIoInCount&quot;: &quot;0&quot;, &quot;analogIoOutCount&quot;: &quot;0&quot;, &quot;digitalIoInCount&quot;: &quot;0&quot;, &quot;dataCollectStatus&quot;: &quot;1&quot;, &quot;digitalIoOutCount&quot;: &quot;0&quot;, &quot;analogChannelCount&quot;: &quot;0&quot;, &quot;digitalChannelCount&quot;: &quot;1&quot; &#125;&#x27;, &#x27;sdmc&#x27;, 1, 0, now(), now(), &#x27;admin&#x27;, &#x27;admin&#x27; ); channelName := devName || &#x27;_1&#x27;; INSERT INTO public.tb_channel (channel_id, channel_index_code, channel_name, channel_num, channel_main_type, channel_sub_type, channel_capability, dev_index_code, region_index_code, description, com_id, ezviz_safe_watch_key, treaty_type, is_cascade, cascade_platform_code, dis_order, sync_iac, data_no, status, extended_attribute, business_class, create_time, update_time, channel_restype, creator, modifier) VALUES (uuid_generate_v4(), uuid_generate_v4(), channelName, &#x27;1&#x27;, &#x27;camera&#x27;, &#x27;digital&#x27;, &#x27;&#123;&#125;&#x27;, devIndexCode, regionIndexCode, null, &#x27;sdmc&#x27;, null, null, &#x27;0&#x27;, &#x27;0&#x27;, id, null, id, 0, &#x27;&#123; &quot;osdStatus&quot;: &quot;0&quot; &#125;&#x27;, &#x27;vss_encodeDevice_camera&#x27;, now(), now(), &#x27;&#123;camera&#125;&#x27;, &#x27;admin&#x27;, &#x27;admin&#x27;); devPort := devPort + 1; regionResourceNum := regionResourceNum + 1; if regionResourceNum = regionResourceLimit then offsetNum := offsetNum + 1; regionIndexCode := null; regionResourceNum := 0; end if; if id = num_limit then return null; end if; id := id + 1; end loop; devIpEnd2 := devIpEnd2 + 1; end loop; devIpEnd1 := devIpEnd1 + 1; end loop; return null;end$$ LANGUAGE plpgsql; 2）插入10w记录 1select insertDeviceChannels(100000); 3)删除指定记录 1delete from tb_device where region_index_code = &#x27;219f98dd-a83a-468f-a2c0-3a30cd2e6082&#x27;;","categories":[{"name":"数据库","slug":"数据库","permalink":"https://hxlpub.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"postgres","slug":"postgres","permalink":"https://hxlpub.github.io/tags/postgres/"}]},{"title":"学习思路","slug":"deep-learning","date":"2021-09-14T09:26:07.000Z","updated":"2022-03-26T09:02:10.564Z","comments":true,"path":"2021/09/14/deep-learning/","link":"","permalink":"https://hxlpub.github.io/2021/09/14/deep-learning/","excerpt":"","text":"","categories":[{"name":"深度学习","slug":"深度学习","permalink":"https://hxlpub.github.io/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"DL","slug":"DL","permalink":"https://hxlpub.github.io/tags/DL/"}]},{"title":"git版本管理工具","slug":"git_tools","date":"2021-09-14T09:26:07.000Z","updated":"2022-05-10T14:21:09.623Z","comments":true,"path":"2021/09/14/git_tools/","link":"","permalink":"https://hxlpub.github.io/2021/09/14/git_tools/","excerpt":"","text":"1.把github上面的仓库克隆到本地 1git clone 仓库 2.上传本地的项目到github仓库 1234567git add * #可将当前目录下文件添加到暂存区git add [file1] [file2] ...#添加一个或多个文件到暂存区git add [dir]#添加指定目录到暂存区，包括子目录git add .#添加当前目录下的所有文件到暂存区git commit -m &quot;提交信息&quot; （注：“提交信息”里面换成你需要，如“first commit”）git push -u origin master （注：此操作目的是把本地仓库push到github上面，此步骤需要你输入帐号和密码，这里的账号和密码是你的github的账号和密码，你第一次上传的话可能会需要你输密码）","categories":[{"name":"git","slug":"git","permalink":"https://hxlpub.github.io/categories/git/"}],"tags":[{"name":"版本管理","slug":"版本管理","permalink":"https://hxlpub.github.io/tags/%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86/"}]},{"title":"实现从Linux服务器获取windows文件","slug":"linux","date":"2021-09-14T09:26:07.000Z","updated":"2022-03-26T09:06:44.984Z","comments":true,"path":"2021/09/14/linux/","link":"","permalink":"https://hxlpub.github.io/2021/09/14/linux/","excerpt":"","text":"问题描述​ 工作中需要从Linux服务器端去拿windows端的文件，linux服务器之间底层互传文件可以用scp很容易实现，但是 不同的操作系统之间实现文件传输,如，windows 和linux之间，又如何实现呢？ 子问题1 描述：ftp ip 需要手动输入win ftpserver所在的win用户名密码后才可以执行抓取等操作，怎么能跳过手动的验证？ 12345678910[root@localhost AuthServer]# ftp 10.192.44.183Connected to 10.192.44.183 (10.192.44.183).220 Microsoft FTP ServiceName (10.192.44.183:root): linhongxun331 Password requiredPassword:230 User logged in.Remote system type is Windows_NT.ftp&gt; 解决方案： 1234567891011121314#!/bin/shftp -n &lt;&lt;- EOF#win 端IPopen ip#win 端用户名密码user username password#传输格式ascii(or bin)#操作put *(or get)#退出byeEOF 子问题2： 解决方案 ftp：需要在windows端搭建ftpserver服务，在linux端安装ftp工具 scp 工作中使用了ftp的方案，本文着重讲解ftp实现从Linux服务器获取windows文件 实现windows 端搭建ftpserver​ 问一下度娘，很简单，在这不耽误时间，推荐 Linux 端安装ftp工具 rpm包方式安装 yum 安装 yum list |grep ftp #查看可安装版本ftp yum install ftp… ftp实现抓取windows端的文件到指定路径​ example:实现将win端的路径下文件cp 到linux端同一路径下：downloadjson.sh 1234567891011121314151617#!/bin/sh# $1 是第一个参数，即路径，执行的脚本为: ./downloadjson.sh /nas/test/test/DocumentVoucher.jsonparam1=`echo $1 |awk -F &quot;DocumentVoucher&quot; &#x27;&#123;printf $1&#125;&#x27;`#echo $&#123;param1&#125;ftp -n &lt;&lt;- EOFopen ftpserveripuser username passwordasciicd $&#123;param1&#125;get DocumentVoucher.jsonbyeEOFmkdir -p $&#123;param1&#125;cp DocumentVoucher.json $&#123;param1&#125; go语言执行脚本​ 项目中，上层应用是http 协议，目的是请求到含有文件路径报文的同时，将文件下载到Linux服务器端，故在http协议绑定的接口函数里面实现了执行该脚本,逻辑如下 123456789command := &quot;./downloadjson.sh &quot; + documentPathfmt.Println(command)cmd := exec.Command(&quot;/bin/sh&quot;, &quot;-c&quot;, command)bytes, err := cmd.Output()if err != nil &#123; fmt.Println(err) &#125;resp := string(bytes) fmt.Println(resp) 常见问题FAQ ​ ftp ip 时连接超时 1234[root@localhost AuthServer]# ftp 10.192.44.183ftp: connect: Connection timed outftp&gt; 解决方案：关闭win端的防火墙 ftp常用指令 连接ftp服务器 格式： 1ftp [hostname| ip-address] a)在linux命令行下输入： 1ftp 192.168.26.66 b)服务器询问你用户名和口令，分别输入用户名和相应密码，待认证通过即可。 2. 下载文件 下载文件通常用get和mget这两条命令。 a) get 格式： 1get [remote-file] [local-file] 将文件从远端主机中传送至本地主机中. 如要获取服务器上e:\\rose\\1.bmp,则 1ftp&gt; get /rose/1.bmp 1.bmp (回车) b) mget 格式： 1mget [remote-files] 从远端主机接收一批文件至本地主机. 如要获取服务器上e:\\rose\\下的所有文件,则 12ftp&gt; cd /roseftp&gt; mget *.* (回车) 注意：文件都下载到了linux主机的当前目录下。比如，在 /root/yint下运行的ftp命令，则文件都下载到了/root/yint 下。 3.上传文件 a) put 1格式：put local-file [remote-file] 将本地一个文件传送至远端主机中. 如要把本地的1.bmp传送到远端主机e:\\rose,并改名为333.bmp 1 ftp&gt; put 1.bmp /rose/333.bmp (回车) b) mput 1格式：mput local-files 将本地主机中一批文件传送至远端主机. 如要把本地当前目录下所有bmp文件上传到服务器e:\\rose 下 12ftp&gt; cd /rose （回车）ftp&gt; mput *.bmp （回车） 注意：上传文件都来自于主机的当前目录下。比如，在 /root/test下运行的ftp命令，则只有在/root/test下的文件linux才会 上传到服务器e:\\rose 下。 4. 断开连接 bye：中断与服务器的连接。 1 ftp&gt; bye (回车) scp常用​ scp是安全的文件拷贝，基于ssh的登录 ​ 假定你想把本地计算机/home下的一个名为a.tar.tz的文件拷贝到远程服务器192.168.0.2上的/home/tmp。而且你在远程服务器 上的帐号名为root。可以用这个命令： 1scp /home/a.tar.tz root@192.168.0.2:/home/tmp/ ​ 如果把文件从远程机器拷贝到本机当前目录用这个命令： 1scp root@192.168.0.2:/home/a.tar.tz ​ 拷贝远程机器的整个目录下的文件 1scp -r root@192.168.0.2：/home/* ./","categories":[{"name":"Linux","slug":"Linux","permalink":"https://hxlpub.github.io/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://hxlpub.github.io/tags/Linux/"}]},{"title":"Linux工具","slug":"linux_command_tools","date":"2021-09-14T09:26:07.000Z","updated":"2022-03-26T09:07:00.388Z","comments":true,"path":"2021/09/14/linux_command_tools/","link":"","permalink":"https://hxlpub.github.io/2021/09/14/linux_command_tools/","excerpt":"","text":"目录文件管理目录管理123456789101112131415161718192021222324252627282930313233343536373839404142434445464748491.列出目录文件名 ls/ll 1、ls -al ~:将家目录下的所有文件列出来（含属性与隐藏文件） 2、ls -alF --color=never:不显示颜色，文件名末尾显示文件名代表的类型 3、ls -al --full-time ~ ：完整呈现文件的修改时间 权限说明drwxr-xr-x 2 root root 4096 Jul 20 2017 Documents第一栏drwxr-xr-x:类型与权限 第一个字符表示文件是目录或文件或链接等等 [d]:目录 [-]:文件 [l]:链接 [b]:装置文件里可供存储的接口设备（可随机存取装置） [c]:装置文件里串行端口设备，如键盘鼠标（一次性读取装 置） 剩余字符以三个为一组：均为rwx三个参数组合 r可读：4 w可写:2 x可执行:1 没有权限则-:0 drwxr-xr-x: rwx=4+2+1=7 r-x:4+0+1=5 r-x:4+0+1=5 则该文件的权限数字是755 第一组：文件拥有者权限 第二组：加入此群组账号的权限 第三组：非本人且未加入本群组的其他账号的权限 第二栏 表示有多少档名连接到此节点（i_node） 第三栏 表示文件或者目录的拥有者账号 第四栏 表示文件所属群组 第五栏 表示文件容量大小，默认单位bytes 第六栏 表示文件的件当日期或最近修改日期 第七栏 表示文档的名字2.切换目录 cd 1、cd /usr/bin: 绝对路径，以根目录/开头 2、cd bin:在usr下，相对路径，相对于当前目录 3、cd ～：切换到目前用户所在家目录 4、cd . :目前所在目录 5、cd .. :切换至目前目录的上一层目录 6、cd ../.. :切换至上上层目录 7、cd ~account :切换到目前用户account所在家目录/home/account 8、cd ../dir:切换到与本目录并列的另一个目录 9、cd -:回到之前的目录3.显示当前目录 pwd4.创建一个新目录 mkdir5.删除一个空目录 rmdir 传输文件1234567891011121314151.wget 从URL获取文件 wget URL #下载URL指定的文件 ex: wget www.baidu.com #下载百度网页 wget -O filename URL #从URL获取文件并重命名filename,filename包含路径 ex：wget http://mirrors.hikvision.com.cn/help/centos/7/CentOS-Base.repo -O /etc/yum.repos.d/CenOS-Base.repo #配置hik yum源 wget -o log URL#注意o与O区别，o为写日志log（怎么获取文件的过程，包括解析、建立连接、传文件等），O为文件名2.ftp 子主题 1 子主题 23.scp 用于 Linux 之间复制文件和目录 scp [可选参数] file_source file_target 1、scp /home/space/music/1.mp3 IP:/home/root/others/music （本地到远程） 2、scp -P 55555 IP:/usr/local/sin.sh /home/administrator（远程到本地） 创建文件、文件链接12341.touch filename#从无到有创建文件2.cp file file.bak #备份3.ln -sf /dev/dm-30 /dev/cvr_vg/lun1 (ln -sf 目的地 链接) 删除文件​ 1rm -rf filename #r：递归，f：强制删除，不提示 更改文件12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455561.重命名​ mv filename newfilename#将文件filename重命名为newfilename2.更改文件属性​ chattr​ 语法​ chattr [-RV][-v&lt;版本编号&gt;][+/-/=&lt;属性&gt;][文件或目录...]​ 参数​ -R 递归处理，将指定目录下的所有文件及子目录一并处理。 -v&lt;版本编号&gt; 设置文件或目录版本。 -V 显示指令执行过程。 +&lt;属性&gt; 开启文件或目录的该项属性。 -&lt;属性&gt; 关闭文件或目录的该项属性。 =&lt;属性&gt; 指定文件或目录的该项属性。 属性 a：让文件或目录仅供附加用途。 b：不更新文件或目录的最后存取时间。 c：将文件或目录压缩后存放。 d：将文件或目录排除在倾倒操作之外。 i：不得任意更动文件或目录。 s：保密性删除文件或目录。 S：即时更新文件或目录。 u：预防意外删除。 示例 chattr +i /etc/resolv.conf#用chattr命令防止系统中某个关键文件被修改 chattr +a /var/log/messages#让某个文件只能往里面追加数据，但不能删除，适用于各种日志文件3.更改文件权限 chmod 格式 chmod [-cfvR] [--help] [--version] mode file... 参数 mode : 权限设定字串 [ugoa...][[+-=][rwxX]...][,...]#格式 其中： u 表示该文件的拥有者，g 表示与该文件的拥有者属于同一个群体(group)者，o 表示其他以外的人，a 表示这三者皆是。 + 表示增加权限、- 表示取消权限、= 表示唯一设定权限。 r 表示可读取，w 表示可写入，x 表示可执行，X 表示只有当该文件是个子目录或者该文件已经被设定过为可执行。 其他参数说明： -c : 若该文件权限确实已经更改，才显示其更改动作 -f : 若该文件权限无法被更改也不要显示错误讯息 -v : 显示权限变更的详细资料 -R : 对目前目录下的所有文件与子目录进行相同的权限变更(即以递归的方式逐个变更) --help : 显示辅助说明 --version : 显示版本 示例 chmod ugo+r file1.txt#将文件 file1.txt 设为所有人皆可读取 chmod ug+w,o-w file1.txt file2.txt#将文件 file1.txt 与 file2.txt 设为该文件拥有者，与其所属同一个群体者可写入，但其他以外的人则不可写入 chmod -R a+r *#将目前目录下的所有文件与子目录皆设为任何人可读取 chmod a=rwx file == chmod 777 file 查看文件1234567891011121314151617181920212223242526272829301.cat 从头到尾显示文件内容 cat 文件 #从头到尾显示整个文件内容，当文件很大时，终端无法完全显示其所有内容 cat -n 文件 #查看文件内容的同时添加行号 三大功能 1.cat 文件 #一次显示整个文件 2.cat &gt; 文件 #从键盘创建一个文件,只能创建新文件，不能编辑已有文件，执行命令后会进入文件编辑，每次都会覆盖旧的内容 3.cat file1 file2 &gt; file#将几个文件合并为一个文件 2.more 分屏显示文件 more 文件 #分屏显示文件内容，空格：向下翻页，b：向上翻页，q：退出3.less 分屏显示文件，同more4.head 从头开始查看文件内容 head 文件 #显示文件头部，默认10行 head -n 行数 文件#查看文件的前10行5.tail 与head相反6.file 观察文件类型,某个文件的基本数据 file file 文件类型诸如,ASCII，data文件，binary文件等 file file7.查看文件格式:set ff #进入到文件，vi/vim 文件后执行:set ff 搜索文件​ 1234567891011121314151617181920212223241.find find path -option ... find . -type f#将当前目录及其子目录中的所有文件列出 find . -name &quot;*.c&quot;#将当前目录及其子目录下所有文件后缀为 .c 的文件列出来 常用：find / -name filename2.which 寻找执行档 which command -a :将所有由PATH目录中可以找到的指令均列出，而不止第一份被找到的指令名称 1、which ifconfig :找出ifconfig命令的执行文件位置3.whereis 文件档名的查找，由一些特定的目录中 寻找文件文件名 whereis [-bmsu] 文件或目录名 -l：列出whereis 会去查询的几个主要目录而已 -b:只找binary文件 -m:只找在说明文件manual路径下的文件 -s:只找source 来源文件 -u:搜寻不在上述三个项目 中的其他特殊文件 1、whereis ifconfig4.根据文件中字符串搜索文件 grep -rn &quot;字符串&quot; 比较文件​ 121.diff diff 选项 文件一 文件二 分割文件1234split 命令用于将一个文件分割成数个 -b:指定每多少字节切成一个小文件 1、split -b 1024m txst.txt -d -a 2 test.txt_ 编辑文件vim ​ 常用快捷方式： ​ 输入输出1231.&gt;&gt; 输出重定向 example: vmstat 3 &gt;&gt; test#vmstat输出重定向到文件test 系统管理1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798991001011021031041051061071081091101111121131141151161171.top 实时显示 process 的动态 top [-d 数字] |top [-bnp] -d:后接秒数，更新的秒数 -b:以批次的方式执行 -n:与-b搭配表示需要进行几次top的输出结果 -p 指定某些个PID观察 1、top -d 2 说明: 第一行：目前的时间，经过的时间，登录用户数，在1,5,15分钟的平均负载 第二行：显示目前进程总数和个别进程状态 第三行： 显示CPU的整体负载 第四行第五行：物理内存和虚拟内存使用情况（虚拟内存来源？？) 第六：输入指令时显示状态的地方 2、top -b -n 2 &gt;/tmp/top.txt#2次输出结果到文件 3、top -d 2 -p PID #持续观察该PID2.ps 显示某个时间点的进程运作情况 ps [options] -A:显示所有process,同-e -a:不与terminal相关的process -u：有效使用者相关的pro x:通常与a一起用列出较完整信息 l :详细讲该PID信息列出 j:工作的格式 -f：更完整的输出 1、ps -l 仅仅观察自己bash相关的进程 说明： F：进程旗标，总结权限，常见号码4:表示进程权限root 1:表示仅复制而没有实际执行 S：表示状态 R：运行中 S：睡眠 D：不可唤醒，可能在等待IO的情况 T：停止 Z:僵尸状态，已经终止但无法移除到内存外 UID/PID/PPID:代表此进程被该UID所拥有，进程的PID号码，此进程的PID号码 C：Cpu 使用率 PRI/NI :priority/nice优先级，越小越优先 ADDR/SZ/WCHAN：内存相关,内存部分，用掉多少内存，是否在运作 TTY：终端机位置，远程则pts/n TIME:使用掉的CPU时间 CMD：造成此进程的程序的指令 2、ps aux#观察系统所有进程 USR;使用者账号 MEM：物理内存占比 VSZ：耗掉的虚拟内存 RSS：占用的固定内存3、ps -lA#显示所有进程 4.free 用于显示内存状态5.查看cpu cat /proc/cpuinfo6.查看内核uname -r7.查看系统cat /etc/redhat-release （redhat）8.进程管理 Kill -s 9 进程号#杀掉进程9.查看目录占用者并解除占用 stat /root/hu10.systemctl 一、systemd 系统初始化程序，系统开始的第一个进程，pid为1 二、systemctl命令 systemctl list-units ##列出当前系统服务的状态 systemctl list-unit-files ##列出服务的开机状态 systemctl status sshd ##查看指定服务的状态 systemctl stop sshd ##关闭指定服务 systemctl start sshd ##开启指定服务 systemctl restart sshd ##从新启动服务 systemctl enable sshd ##设定指定服务开机开启 systemctl disable sshd ##设定指定服务开机关闭 systemctl reload sshd ##使指定服务从新加载配置 systemctl list-dependencies sshd ##查看指定服务的倚赖关系 systemctl mask sshd ##冻结指定服务 systemctl unmask sshd ##启用服务 systemctl set-default multi-user.target ##开机不开启图形 systemctl set-default graphical.target ##开机启动图形 setterm ##文本界面设定color 三、服务状态 systemctl status 服务名称 loaded ##系统服务已经初始化完成，加载过配置 active（running） ##正有一个或多个程序正在系统中执行， vsftpd就是这种模式 atcive（exited） ##僅執行一次就正常結束的服務， 目前並沒有任何程序在系統中執行 atcive（waiting） ##正在執行當中，不過還再等待其他的事件才能继续处理 inactive ##服务关闭 enbaled ##服务开机启动 disabled ##服务开机不自启 static ##服务开机启动项不可被管理 failed ##系统配置错误 11.pstree查看Linux下systemd启动了哪些服务 pstree [options]-a #包含命令行参数-c #展开相同的子树-H [PID] #突出特定过程-g #显示进程组ID-n #使用PID排序pstree 用户 #显示特定用户的进程树-s [PID ] #限制显示一个特定的过程12.查看内存型号dmidecode -t memory13. 排名前10的内存CPU消耗ps auxw|head -1;ps auxw|sort -rn -k3|head -1014.释放内存如果内存太少， 可以把占用内存多的程序停掉， 然后执行这个命令释放： echo 3 &gt;/proc/sys/vm/drop_caches 释放完后再改回去： echo 1 &gt;/proc/sys/vm/drop_caches 系统设置123子主题 1子主题 2子主题 3 磁盘、设备管理1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162631.df 列出文件系统的整体磁盘使用量 df [-ahikHTm][目录或文件名] -a:列出所有文件系统，包括系统特有的/proc等文件系统 -k:以KBytes的容量显示文件系统 -m:以MBytes的容量显示文件系统 -h：以人们交易阅读的的GB、MB、KB等格式自行显示 -H：以M=1000K取代M=1024K 的进位方式 -T：连同该partition的filesystem名称列出 -i:不用磁盘容量而以inode数量表示 1、df:列出系统内所有filesystem列出来 filesystem:表示文件系统是哪个partition 1k-blocks:表示单位1KB，可用-h或-m改变容量 Used:使用掉的磁盘空间 Available:剩下的磁盘空间 Use%:磁盘的使用率 Mounted on :磁盘挂载的目录（挂载点） 2、df -h:易读显示 3、df -aT:将系统内所有特殊文件格式以及名称列出来 4、df -h /etc：将/etc下可用的磁盘以易读的容量格式显示出来 5、df -ih：将目前的各个partition当中可用的inode数量列出2.lsblklist block device观察磁盘分区状态lsblk [-dfimpt] device-d:仅列出磁盘本身,无分区-f:含文件系统名称-i：使用ASCII的线段输出-m：输出权限数据-p:列出完整文件名 -t:列出详细数据。包括磁盘队列机制与读写的数据量大小1、lsblk -ip /dev/sdb3.blkid对系统的块设备（包括交换分区）所使用的文件系统类型、LABEL、UUID等信息进行查询4.挂载镜像 1、sudo losetup /dev/loop0 iVMS-HG-H16_CN_STD_9.2.0_V2.3.8_iSC_V1.5.100_201026_platformactive_base.img 2、 kpartx -av /dev/loop0 3、 kpartx -d /dev/loop0 4、losetup -d /dev/loop05.调整分区fdisk 1.fdisk /dev/hda p：打印分区 d：删除分区 n:新增分区 2.格式化分区 mkfs.ext4 /dev/.. 3.挂载分区 mount /dev/... 挂载点6.激活网卡 ifup eth0 磁盘维护1234567891011121314151.dd 备份(直接读取扇区sector)制作文件 dd if=&quot;input_file&quot; of=&quot;output_file&quot; bs=&quot;blocksize&quot; count=blocknum if：输入文件名，默认为标准输入。即指定源文件或设备。 of：输出文件名，默认为标准输出。即指定目的文件或设备。 count：多少的bs bs：一个block大小 1、dd if=/etc/passwd of=/etc/passwd.back #备份文件 2、dd if=/dev/sdb of=/tmp/system.iso#将光驱内容备份下来 3、dd if=/tmp/system.iso of=/dev/sdb#将镜像备份到设备 4、将/boot整个文件系统透过dd备份下来 df -h /boot#获取设备/dev/... dd if=/dev/… of=/tmp/….img 子主题 2子主题 3 网络通讯、系统性能1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798991001011021031041051061071081091101111121131141151161171181191201211221231241251261271281291301311321331341351361371381391401411.iostat I/O statistics（输入/输出统计）输出CPU和磁盘I/O相关的统计信息监控系统的IO状态 iostat [ options ] [ &lt;interval&gt; [ &lt;count&gt; ] ]-c：查看CPU部分状态信息-k:某些使用block为单位的列强制使用Kilobytes为单位-d 参数，显示设备（磁盘）使用状态-x 参数，输出更多详细信息1、iostat -c2、iostat -k 1 103、iostat -d 1 34、iostat -x 1 2说明：磁盘属性tps：该设备每秒的传输次数“一次传输”意思是“一次I/O请求”。多个逻辑请求可能会被合并为“一次I/O请求”。“一次传输”请求的大小是未知的。kB_read/s：每秒从设备（drive expressed）读取的数据量；kB_wrtn/s：每秒向设备（drive expressed）写入的数据量；kB_read：读取的总数据量；kB_wrtn：写入的总数量数据量；这些单位都为Kilobytes。CPU属性%user cpu处在用户模式下的时间百分比%nice cpu处在带NICE值的用户模式下的时间百分比%system cpu处在系统模式下的时间百分比%iowait cpu等待输入输出完成时间的百分比%steal 管理程序维护另一个虚拟处理器时，虚拟CPU的无意识等待时间百分比%idle cpu空闲时间百分比注意:如果%iowait的值过高，表示硬盘存在I/O瓶颈，%idle值高，表示CPU较空闲，如果%idle值高但系统响应慢时，有可能是CPU等待分配内存，此时应加大内存容量。%idle值如果持续低于10，那么系统的CPU处理能力相对较低，表明系统中最需要解决的资源是CPU。2.ifstat网络接口监测工具ifstat options-l 监测环路网络接口。缺省情况下ifstat监测活动的所有非环路网络接口-a 监测能检测到的所有网络接口的状态信息。-z 隐藏流量是无的接口，如接口启动了但是未使用的。-i &lt;interface&gt; 指定要监测的接口。-s 通过SNMP查询一个远程主机。-h 显示帮助信息-n 关闭周期性显示头部信息。-t 在每一行的开头加一个时间戳-T 报告所有检测接口的全部带宽-w 指定间隔时间（与官方的文档说明并不同，不知道是不是写文档的人写错，反正我测试后是间隔时间）-W 如果显示内容超出终端窗口的宽度，就换行-S 在同一行更新显示内容 -b 用kbits/s显示带宽-q 按键模式-v 显示版本信息-d 指定一个驱动来收集状态信息 3.netstatNetstat是控制台命令,是一个监控TCP/IP网络的非常有用的工具，它可以显示路由表、实际的网络连接以及每一个网络接口设备的状态信息。Netstat用于显示与IP、TCP、UDP和ICMP协议相关的统计数据，一般用于检验本机各端口的网络连接情况。netstat options-a (all) 显示所有选项，默认不显示LISTEN相关。-t (tcp) 仅显示tcp相关选项。-u (udp) 仅显示udp相关选项。-n 拒绝显示别名，能显示数字的全部转化成数字。-l 仅列出有在 Listen (监听) 的服务状态。-p 显示建立相关链接的程序名-r 显示路由信息，路由表-e 显示扩展信息，例如uid等-s 按各个协议进行统计-c 每隔一个固定时间，执行该netstat命令。LISTEN和LISTENING的状态只有用-a或者-l才能看到。1、列出所有端口 #netstat -a2、列出所有 tcp 端口 #netstat -at3、列出所有 udp 端口 #netstat -au4、只显示监听端口 #netstat -l5、只列出所有监听 tcp 端口 #netstat -lt6、只列出所有监听 udp 端口 #netstat -lu7、列出所有监听 UNIX 端口 #netstat -lx8、显示所有端口的统计信息 #netstat -s9、显示 TCP 或 UDP 端口的统计信息 #netstat -st 或 -su10、 输出中显示 PID 和进程名称 #netstat -p4.vmstat展现给定时间间隔的服务器的状态值,包括服务器的CPU使用率，内存使用，虚拟内存交换情况,IO读写情况 vmstat [options] [delay [count]]参数说明Procs（进程） r等待执行的任务数展示了正在执行和等待cpu资源的任务个数当这个值超过了cpu个数，就会出现cpu瓶颈。B等待IO的进程数量Memory(内存)swpd正在使用虚拟的内存大小，单位kfree空闲内存大小buff已用的buff大小，对块设备的读写进行缓冲cache已用的cache大小，文件系统的cacheinact非活跃内存大小，即被标明可回收的内存，区别于free和active active活跃的内存大小Swapsi每秒从交换区写入内存的大小（单位：kb/s）so每秒从内存写到交换区的大小IObi每秒读取的块数（读磁盘） 块设备每秒接收的块数量，单位是block，这里的块设备是指系统上所有的磁盘和其他块设备，现在的Linux版本块的大小为1024bytesbo每秒写入的块数（写磁盘）块设备每秒发送的块数量，单位是block system in ：中断数cs:每秒上下文切换数CPUus用户进程执行消耗cpu时间(user time) us的值比较高时，说明用户进程消耗的cpu时间多，但是如果长期超过50%的使用，那么我们就该考虑优化程序算法或其他措施了sy系统进程消耗cpu时间(system time)sys的值过高时，说明系统内核消耗的cpu资源多，这个不是良性的表现，我们应该检查原因。这里us + sy的参考值为80%，如果us+sy 大于 80%说明可能存在CPU不足Id空闲时间(包括IO等待时间) 一般来说 us+sy+id=100wa等待IO时间wa过高时，说明io等待比较严重，这可能是由于磁盘大量随机访问造成的，也有可能是磁盘的带宽出现瓶颈。5.tcpdump 虚拟机内抓一下网卡上某个ip的流量 tcpdump -i ens3 |grep 10.192.54.2206.ethtool 查看网卡信息 ethtool eth0 备份压缩12345678910111213141516171819202122232425262728293031321.zip zip -r myfile.zip ./* unzip -o -d /home/sunny myfile.zip #解压myfile.zip 到/home/sunny2.tar 用于备份文件、压缩、解压 -c：建立打包文件，可搭配-v查看过程中被打包的文件名 -t:查看打包文件的内容含有哪些档名，重点在查看档名就是了 -x:解打包或解压缩的功能，可以搭配-C在特定的目录解开，特别留意的是-c,-t，-x不可同时出现在一串指令中 -z：透过gzip的支持进行压缩解压缩，文件最好是*.tar.gz -j：透过bzip2的支持进行压缩解压缩，文件最好是*.tar.bz2 -J：透过xz的支持进行压缩解压缩，文件最好是*.tar.xz -v:在压缩解压缩的过程中，将正在处理的文件名显示出来 -f filename：-f 后面要立刻接要被处理的文档名 -C目录：这个选项用在解压缩，若要在特定目录解压缩，可以使用这个选项 -p：保留备份数据的原本权限与属性，常用于备份-c重要的配置文件 -P：保留绝对路径，即允许备份数据中含有根目录存在 --exclude=FILE：在压缩过程中，不要将FILE 打包 1、# tar -czvf test.tar.gz a.c //压缩（compress） a.c文件为test.tar.gz 2、tar -tzvf test.tar.gz （列出压缩文件内容）(list) 3、tar -xzvf test.tar.gz（解压）(extract) 4、tar -zpcv -f /root/etc.tar.gz /etc#备份/etc（先su -切换到root） tar -jpcv -f /root/etc.tar.bz2 /etc tar -Jpcv -f /root/etc.tar.xz /etc3.xz创建tar.xz文件：只要先 tar cvf xxx.tar xxx/ 这样创建xxx.tar文件先，然后使用 xz -z xxx.tar 来将 xxx.tar压缩成为 xxx.tar.xz解压tar.xz文件：先 xz -d xxx.tar.xz 将 xxx.tar.xz解压成 xxx.tar 然后，再用 tar xvf xxx.tar来解包。4.子主题 4 软件维护 Ubuntu 12345678910111213更新软件源 1.更改源sudo vim /etc/apt/sources.list 2.sudo apt-get update安装软件 3.sudo apt-get install 软件 Centos 1234567891011121314151617181920212223242526271.更改yum源wget 官方源/aliyun 等 -O /etc/yum.repos.d/CenOS-Base.repoyum clean all &amp;&amp; yum makecache #生成缓存2.安装EPEL 源EPEL (Extra Packages for Enterprise Linux)是基于Fedora的一个项目，为“红帽系”的操作系统提供额外的软件包，适用于RHEL、CentOS和Scientific Linux.我们在Centos下使用yum安装时往往找不到rpm的情况，官方的rpm repository提供的rpm包也不够丰富，很多时候需要自己编译很痛苦，而EPEL恰恰可以解决这两方面的问题。EPEL的全称叫 Extra Packages for Enterprise Linux 。EPEL是由 Fedora 社区打造，为 RHEL 及衍生发行版如 CentOS、Scientific Linux 等提供高质量软件包的项目。装上了 EPEL之后，就相当于添加了一个第三方源。————————————————版权声明：本文为CSDN博主「不忘初心fight」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。原文链接：https://blog.csdn.net/weixin_41831919/article/details/1090359361）yum install -y epel-release [root@192 daos]# ll /etc/yum.repos.d/total 52-rw-r--r--. 1 root root 1664 Oct 23 2020 CentOS-Base.repo-rw-r--r--. 1 root root 2523 Dec 26 2020 CentOS-Base.repo.aliyun-rw-r--r--. 1 root root 1309 Nov 23 2020 CentOS-CR.repo-rw-r--r--. 1 root root 649 Nov 23 2020 CentOS-Debuginfo.repo-rw-r--r--. 1 root root 314 Nov 23 2020 CentOS-fasttrack.repo-rw-r--r--. 1 root root 630 Nov 23 2020 CentOS-Media.repo-rw-r--r--. 1 root root 1331 Nov 23 2020 CentOS-Sources.repo-rw-r--r--. 1 root root 8515 Nov 23 2020 CentOS-Vault.repo-rw-r--r--. 1 root root 616 Nov 23 2020 CentOS-x86_64-kernel.repo-rw-r--r--. 1 root root 951 Oct 2 2017 epel.repo-rw-r--r--. 1 root root 1050 Oct 2 2017 epel-testing.repo2）yum repolist3) yum clean all &amp;&amp; yum makecache 其他 11.set -e # shell文件开头加上set -e,这句语句告诉bash如果任何语句的执行结果不是true则应该退出 自定义安装软件环境变量设置 1 Linux环境变量配置方法一：export PATH使用export命令直接修改PATH的值，配置MySQL进入环境变量的方法: 1234export PATH=/home/uusama/mysql/bin:$PATH# 或者把PATH放在前面export PATH=$PATH:/home/uusama/mysql/bin 注意事项： 生效时间：立即生效 生效期限：当前终端有效，窗口关闭后无效 生效范围：仅对当前用户有效 配置的环境变量中不要忘了加上原来的配置，即$PATH部分，避免覆盖原来配置 Linux环境变量配置方法二：vim ~/.bashrc通过修改用户目录下的~/.bashrc文件进行配置： 1234vim ~/.bashrc# 在最后一行加上export PATH=$PATH:/home/uusama/mysql/bin 注意事项： 生效时间：使用相同的用户打开新的终端时生效，或者手动source ~/.bashrc生效 生效期限：永久有效 生效范围：仅对当前用户有效 如果有后续的环境变量加载文件覆盖了PATH定义，则可能不生效 Linux环境变量配置方法三：vim ~/.bash_profile和修改~/.bashrc文件类似，也是要在文件最后加上新的路径即可： 1234vim ~/.bash_profile# 在最后一行加上export PATH=$PATH:/home/uusama/mysql/bin 注意事项： 生效时间：使用相同的用户打开新的终端时生效，或者手动source ~/.bash_profile生效 生效期限：永久有效 生效范围：仅对当前用户有效 如果没有~/.bash_profile文件，则可以编辑~/.profile文件或者新建一个 Linux环境变量配置方法四：vim /etc/bashrc该方法是修改系统配置，需要管理员权限（如root）或者对该文件的写入权限： 1234567# 如果/etc/bashrc文件不可编辑，需要修改为可编辑chmod -v u+w /etc/bashrcvim /etc/bashrc# 在最后一行加上export PATH=$PATH:/home/uusama/mysql/bin 注意事项： 生效时间：新开终端生效，或者手动source /etc/bashrc生效 生效期限：永久有效 生效范围：对所有用户有效 Linux环境变量配置方法五：vim /etc/profile该方法修改系统配置，需要管理员权限或者对该文件的写入权限，和vim /etc/bashrc类似： 1234567# 如果/etc/profile文件不可编辑，需要修改为可编辑chmod -v u+w /etc/profilevim /etc/profile# 在最后一行加上export PATH=$PATH:/home/uusama/mysql/bin 注意事项： 生效时间：新开终端生效，或者手动source /etc/profile生效 生效期限：永久有效 生效范围：对所有用户有效 Linux环境变量配置方法六：vim /etc/environment该方法是修改系统环境配置文件，需要管理员权限或者对该文件的写入权限： 1234567# 如果/etc/bashrc文件不可编辑，需要修改为可编辑chmod -v u+w /etc/environmentvim /etc/profile# 在最后一行加上export PATH=$PATH:/home/uusama/mysql/bin 注意事项： 生效时间：新开终端生效，或者手动source /etc/environment生效 生效期限：永久有效 生效范围：对所有用户有效 Linux环境变量加载原理解析上面列出了环境变量的各种配置方法，那么Linux是如何加载这些配置的呢？是以什么样的顺序加载的呢？ 特定的加载顺序会导致相同名称的环境变量定义被覆盖或者不生效。 环境变量的分类环境变量可以简单的分成用户自定义的环境变量以及系统级别的环境变量。 用户级别环境变量定义文件：~/.bashrc、~/.profile（部分系统为：~/.bash_profile） 系统级别环境变量定义文件：/etc/bashrc、/etc/profile(部分系统为：/etc/bash_profile）、/etc/environment 另外在用户环境变量中，系统会首先读取~/.bash_profile（或者~/.profile）文件，如果没有该文件则读取~/.bash_login，根据这些文件中内容再去读取~/.bashrc。 测试Linux环境变量加载顺序的方法为了测试各个不同文件的环境变量加载顺序，我们在每个环境变量定义文件中的第一行都定义相同的环境变量UU_ORDER，该变量的值为本身的值连接上当前文件名称。 需要修改的文件如下： /etc/environment /etc/profile /etc/profile.d/test.sh，新建文件，没有文件夹可略过 /etc/bashrc，或者/etc/bash.bashrc ~/.bash_profile，或者~/.profile ~/.bashrc 在每个文件中的第一行都加上下面这句代码，并相应的把冒号后的内容修改为当前文件的绝对文件名。 1export UU_ORDER=&quot;$UU_ORDER:~/.bash_profile&quot; 修改完之后保存，新开一个窗口，然后echo $UU_ORDER观察变量的值： 12uusama@ubuntu:~$ echo $UU_ORDER$UU_ORDER:/etc/environment:/etc/profile:/etc/bash.bashrc:/etc/profile.d/test.sh:~/.profile:~/.bashrc 可以推测出Linux加载环境变量的顺序如下： /etc/environment /etc/profile /etc/bash.bashrc /etc/profile.d/test.sh ~/.profile ~/.bashrc Linux环境变量文件加载详解由上面的测试可容易得出Linux加载环境变量的顺序如下，： 系统环境变量 -&gt; 用户自定义环境变量/etc/environment -&gt; /etc/profile -&gt; ~/.profile 打开/etc/profile文件你会发现，该文件的代码中会加载/etc/bash.bashrc文件，然后检查/etc/profile.d/目录下的.sh文件并加载。 123456789101112131415161718192021222324252627# /etc/profile: system-wide .profile file for the Bourne shell (sh(1))# and Bourne compatible shells (bash(1), ksh(1), ash(1), ...).if [ &quot;$PS1&quot; ]; then if [ &quot;$BASH&quot; ] &amp;&amp; [ &quot;$BASH&quot; != &quot;/bin/sh&quot; ]; then # The file bash.bashrc already sets the default PS1. # PS1=&#x27;\\h:\\w\\$ &#x27; if [ -f /etc/bash.bashrc ]; then . /etc/bash.bashrc fi else if [ &quot;`id -u`&quot; -eq 0 ]; then PS1=&#x27;# &#x27; else PS1=&#x27;$ &#x27; fi fifiif [ -d /etc/profile.d ]; then for i in /etc/profile.d/*.sh; do if [ -r $i ]; then . $i fi done unset ifi 其次再打开~/.profile文件，会发现该文件中加载了~/.bashrc文件。 12345678910# if running bashif [ -n &quot;$BASH_VERSION&quot; ]; then # include .bashrc if it exists if [ -f &quot;$HOME/.bashrc&quot; ]; then . &quot;$HOME/.bashrc&quot; fifi# set PATH so it includes user&#x27;s private bin directoriesPATH=&quot;$HOME/bin:$HOME/.local/bin:$PATH&quot; 从~/.profile文件中代码不难发现，/.profile文件只在用户登录的时候读取一次，而/.bashrc会在每次运行Shell脚本的时候读取一次。 一些小技巧可以自定义一个环境变量文件，比如在某个项目下定义uusama.profile，在这个文件中使用export定义一系列变量，然后在~/.profile文件后面加上：sourc uusama.profile，这样你每次登陆都可以在Shell脚本中使用自己定义的一系列变量。 也可以使用alias命令定义一些命令的别名，比如alias rm=&quot;rm -i&quot;（双引号必须），并把这个代码加入到~/.profile中，这样你每次使用rm命令的时候，都相当于使用rm -i命令，非常方便。","categories":[{"name":"Linux","slug":"Linux","permalink":"https://hxlpub.github.io/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://hxlpub.github.io/tags/Linux/"}]},{"title":"Linux内核kernel","slug":"linux_kernel","date":"2021-09-14T09:26:07.000Z","updated":"2022-03-26T09:07:22.616Z","comments":true,"path":"2021/09/14/linux_kernel/","link":"","permalink":"https://hxlpub.github.io/2021/09/14/linux_kernel/","excerpt":"","text":"","categories":[{"name":"Linux","slug":"Linux","permalink":"https://hxlpub.github.io/categories/Linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://hxlpub.github.io/tags/linux/"}]},{"title":"Linux驱动.ko文件编写加载","slug":"linux_ko","date":"2021-09-14T09:26:07.000Z","updated":"2022-03-26T08:45:12.487Z","comments":true,"path":"2021/09/14/linux_ko/","link":"","permalink":"https://hxlpub.github.io/2021/09/14/linux_ko/","excerpt":"","text":"参考 一、.ko 文件介绍.ko文件是kernel object文件（内核模块），该文件的意义就是把内核的一些功能移动到内核外边， 需要的时候插入内核，不需要时卸载。 二、优点（1）这样可以缩小内核体积； （2）使用方便。 三、.ko文件一般的用处（1）作为一个功能模块，需要使用时，直接插入运行就行。如在imx6上连接模拟摄像头，先运行模拟摄像头对应的驱动模块 camera.ko文件，然后对应的工程执行文件运行就行。 四、使用.ko 文件1、加载驱动模块test.ko（1）方法一进入test.ko驱动模块文件所在的目录，然后直接 insmod test.ko （2）方法二将test.ko文件拷贝到/lib/module/#uname-r#/目录下，这里，#uname -r#意思是，在终端中输入uname -r后显示的内核版本及名称，例如我的环境centos 7系统下#uname-r#就是3.10.0-957.12.2.el7.x86_64然后 depmod（会在/lib/modules/#uname -r#/目录下生成modules.dep和modules.dep.bb文件，表明模块的依赖关系）最后 modprobe test（注意这里无需输入.ko后缀） 即可 注：两种方法的区别 modprobe和insmod类似，都是用来动态加载驱动模块的，区别在于modprobe可以解决load module时的依赖关系，它是通过/lib/modules/#uname -r/modules.dep(.bb)文件来查找依赖关系的；而insmod不能解决依赖问题。也就是说，如果你确定你要加载的驱动模块不依赖其他驱动模块的话，既可以insmod也可以modprobe，当然insmod可以在任何目录下执行，更方便一些。而如果你要加载的驱动模块还依赖其他ko驱动模块的话，就只能将模块拷贝到上述的特定目录，depmod后再modprobe。 2、查看已加载的驱动模块列表在任何目录下输入命令lsmod 12345678910111213141516171819202122232425`[root@HikvisionOS ~]# lsmod` `Module Size Used by``ip6t_rpfilter 12595 1` `ipt_REJECT 12541 2` `nf_reject_ipv4 13373 1 ipt_REJECT``ip6t_REJECT 12625 2` `nf_reject_ipv6 13717 1 ip6t_REJECT``xt_conntrack 12760 19` `ip_set 45644 0` `nfnetlink 14490 1 ip_set``ebtable_nat 12807 1` `ebtable_broute 12731 1` `bridge 151336 1 ebtable_broute``stp 12976 1 bridge``llc 14552 2 stp,bridge``ip6table_nat 12864 1` `nf_conntrack_ipv6 18935 11` `nf_defrag_ipv6 35104 1 nf_conntrack_ipv6``nf_nat_ipv6 14131 1 ip6table_nat``ip6table_mangle 12700 1` `ip6table_security 12710 1` `ip6table_raw 12683 1` `iptable_nat 12875 1` `nf_conntrack_ipv4 15053 10` `nf_defrag_ipv4 12729 1 nf_conntrack_ipv4` 3、卸载驱动模块在任何目录下， 输入命令 rmmod 注：“module_name”是lsmod显示的模块名称，而不是对应的ko文件名 五、编写生成.ko 文件Linux下hello.ko内核模块制作的全过程 1.linux系统用的是Redflag 6.0 SP1 下载地址：ftp://ftp.redflag-linux.com/pub/redflag/dt6sp1/SP1/redflag-6-sp1.iso， 系统安装很容易，安提示做就好。所用的内核源码目录树下载地址：ftp://ftp.redflag-linux.com/pub/redflag/dt6sp1/SP1/redflag-6-tool-sp1-src1.iso，将此iso文件挂载到/mnt下，安装其中的内核rpm包。挂载方法：mount -t iso9660 redflag-6-tool-sp1-src1.iso /mnt/ -o loop内核目录树安装方法：cd /mnt/RedFlag/SRMPS/ rpm -i kernel-2.6.23.1-4.src.rpm 2.编写hello模块代码，源码如下： hello.c 12345678910111213141516#include &lt;linux/init.h&gt; #include &lt;linux/module.h&gt; MODULE_LICENSE(&quot;GPL&quot;); static int hello_init(void) &#123; printk(KERN_ALERT &quot;Hello, world\\n&quot;); return 0; &#125; static void hello_exit(void) &#123; printk(KERN_ALERT &quot;Goodbye, cruel world\\n&quot;); &#125; module_init(hello_init); module_exit(hello_exit); 3.编写hello模块的Makefile文件，Makefile内容如下： 123456789101112Makefile#Makefile 2.6 obj-m :=hello.o KERNEL :=/usr/src/kernels/$(uname -r)/ PWD :=$(shell pwd) modules : $(MAKE) -C $(KERNEL) M=$(PWD) modules .PHONEY:clean clean : rm -f *.o *.ko 4.编译模块在命令行进入hello.c所在的文件夹下执行make命令即可完成hello模块的编译。用ls命令可以查看到hello.ko文件，此文件就是我们自定义的内核模块。 5.安装hello模块 命令行下执行命令：insmod hello.ko 。通过命令:cat /var/log/messages 可以看到下面这样的信息：“Aug 6 13:37:59 localhost kernel: Hello, world”，说明模块加载成功了。 6.另外一种模块Makefile的编写方法 Makefile 1234567891011121314151617181920# If KERNELRELEASE is defined, we&#x27;ve been invoked from the # kernel build system and can use its language. ifneq ($(KERNELRELEASE),) obj-m := hello.o # Otherwise we were called directly from the command # line; invoke the kernel build system. else KERNELDIR ?= /lib/modules/$(shell uname -r)/build PWD := $(shell pwd) default: $(MAKE) -C $(KERNELDIR) M=$(PWD) modules endif 卸载hello模块 命令行下执行命令：rmmod hello.ko即可。通过命令：cat /var/log/messages.可以看到下面这样的信息：“Aug 6 13:40:36 localhost kernel: Goodbye, cruel world”，说明模块卸载成功。 查看模块信息 命令行下执行命令：modinfo hello————————————————版权声明：本文为CSDN博主「worthsen」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。原文链接：https://blog.csdn.net/qq_38880380/article/details/79227760","categories":[{"name":"Linux","slug":"Linux","permalink":"https://hxlpub.github.io/categories/Linux/"}],"tags":[]},{"title":"服务器搭建之基于最小化系统centos7搭建服务器","slug":"linux_mini_system_config","date":"2021-09-14T09:26:07.000Z","updated":"2022-03-26T08:45:51.242Z","comments":true,"path":"2021/09/14/linux_mini_system_config/","link":"","permalink":"https://hxlpub.github.io/2021/09/14/linux_mini_system_config/","excerpt":"","text":"将自己的一台旧笔记本装成centos 7 配置服务器 网络配置 配置无线网卡（有网线的可以配置有线网卡）,一开始， 1.nmcli 查看网卡，我的无线网卡是wlp1s0,显示unmanaged， plugin missing，需要托管下并且安装NetworkManager-wifi模块 2.nmcli dev set wlp1s0 autoconnect yes managed yes 加入托管 3.在官网下载相应版本的rpm 包，我的是centos 7 版本NetworkManager-wifi-1.18.8-1.el7.x86_64.rpm ,拷贝到U盘 4.安装，yum install -y NetworkManager-wifi-1.18.8-1.el7.x86_64.rpm 5.安装完，重启下NetworkManager.service ,systemctl restart NetworkManager.service nmcli 查看 显示disconnected 6.连接无线 nmcli d wifi list：列出当前扫描出的热点 nmcli dev wifi connect “wifi名称” password “WiFi密码” 查看 nmcli dev show wlp1s0 已经connected 7.ping 一下自己另外的设备A，不通的，但是能ping 通网关还能ping www.baidu.com,而且在另外的设备A上ping 服务器B是通的：关闭A 防火墙 其他配置参考 [参考]: https://blog.csdn.net/chenkaifang/article/details/82531696 “CentOS7.5最小化安装之后的配置”","categories":[{"name":"Linux","slug":"Linux","permalink":"https://hxlpub.github.io/categories/Linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://hxlpub.github.io/tags/linux/"}]},{"title":"linux性能分析","slug":"linux_server_performance_analysis","date":"2021-09-14T09:26:07.000Z","updated":"2022-03-26T08:46:12.343Z","comments":true,"path":"2021/09/14/linux_server_performance_analysis/","link":"","permalink":"https://hxlpub.github.io/2021/09/14/linux_server_performance_analysis/","excerpt":"","text":"","categories":[{"name":"Linux","slug":"Linux","permalink":"https://hxlpub.github.io/categories/Linux/"}],"tags":[]},{"title":"常用的开源资源","slug":"linux_sites","date":"2021-09-14T09:26:07.000Z","updated":"2022-03-26T09:10:59.432Z","comments":true,"path":"2021/09/14/linux_sites/","link":"","permalink":"https://hxlpub.github.io/2021/09/14/linux_sites/","excerpt":"","text":"ubuntu: Ubuntu 命令技巧","categories":[{"name":"Linux","slug":"Linux","permalink":"https://hxlpub.github.io/categories/Linux/"}],"tags":[{"name":"open_sites","slug":"open-sites","permalink":"https://hxlpub.github.io/tags/open-sites/"}]},{"title":"shell","slug":"linux_shell","date":"2021-09-14T09:26:07.000Z","updated":"2022-03-26T09:09:40.092Z","comments":true,"path":"2021/09/14/linux_shell/","link":"","permalink":"https://hxlpub.github.io/2021/09/14/linux_shell/","excerpt":"","text":"1.符号 2.读文件方法 https://blog.csdn.net/feixiaohuijava/article/details/53129413","categories":[{"name":"Linux","slug":"Linux","permalink":"https://hxlpub.github.io/categories/Linux/"}],"tags":[{"name":"shell","slug":"shell","permalink":"https://hxlpub.github.io/tags/shell/"}]},{"title":"编译常见问题FAQ","slug":"linux_soft_manage_FAq","date":"2021-09-14T09:26:07.000Z","updated":"2022-03-26T09:11:23.177Z","comments":true,"path":"2021/09/14/linux_soft_manage_FAq/","link":"","permalink":"https://hxlpub.github.io/2021/09/14/linux_soft_manage_FAq/","excerpt":"","text":"1.执行dnf install python3 ：bash: /usr/bin/dnf: /usr/bin/python3: bad interpreter: No such file or directory 12345678#原因，安装其他软件导致python 版本同dnf 配置文件里的python 版本不一致[root@192 /]# whereis dnf dnf: /usr/bin/dnf /etc/dnf /usr/share/man/man8/dnf.8.gz[root@192 /]# vim /usr/bin/dnf#!/usr/bin/python3.9# The dnf executable script.# error while loading shared libraries: librte_telemetry.so.21: cannot open shared object file: No such file or directory 1234vim /etc/ld.so.conf#加入so lib path如/usr/local/daos/prereq/release/spdk/libldconfig 更新一下配置 3.ldd 查看 库 no found 123vim /etc/ld.so.conf 加相应的库路径，如/usr/local/daos/prereq/release/spdk/lib 后ldconfig","categories":[{"name":"Linux","slug":"Linux","permalink":"https://hxlpub.github.io/categories/Linux/"}],"tags":[{"name":"编译FAQ","slug":"编译FAQ","permalink":"https://hxlpub.github.io/tags/%E7%BC%96%E8%AF%91FAQ/"}]},{"title":"学习思路","slug":"machine-learning","date":"2021-09-14T09:26:07.000Z","updated":"2022-03-26T09:11:36.082Z","comments":true,"path":"2021/09/14/machine-learning/","link":"","permalink":"https://hxlpub.github.io/2021/09/14/machine-learning/","excerpt":"","text":"","categories":[{"name":"机器学习","slug":"机器学习","permalink":"https://hxlpub.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"ML","slug":"ML","permalink":"https://hxlpub.github.io/tags/ML/"}]},{"title":"vscode extensions离线下载安装","slug":"vscode_extensions","date":"2021-09-14T09:26:07.000Z","updated":"2022-03-26T09:12:24.690Z","comments":true,"path":"2021/09/14/vscode_extensions/","link":"","permalink":"https://hxlpub.github.io/2021/09/14/vscode_extensions/","excerpt":"","text":"1.windows step1 ：下载扩展包，https://marketplace.visualstudio.com/search?term=go&amp;target=VSCode&amp;category=All%20categories&amp;sortBy=Relevance ,并放到vscode bin 下 step2：安装，bin下右键打开命令行工具，执行 1code --install-extension *.vsix step3: 显示安装完成 Extension ‘yzhang.markdown-all-in-one-1.4.0.vsix’ was successfully installed!","categories":[{"name":"开发工具","slug":"开发工具","permalink":"https://hxlpub.github.io/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"vscode_extensions","slug":"vscode-extensions","permalink":"https://hxlpub.github.io/tags/vscode-extensions/"}]},{"title":"go_linux编译运行环境搭建","slug":"go_compile","date":"2021-09-13T14:29:54.000Z","updated":"2022-03-26T08:25:20.274Z","comments":true,"path":"2021/09/13/go_compile/","link":"","permalink":"https://hxlpub.github.io/2021/09/13/go_compile/","excerpt":"","text":"1.最直接的方式​ 官网提供了第一手资料，十分全面，可以根据自己的系统（windows、linux、mac）选择自己的下载和安装方式 点击进入官网 2.源码编译方式2.1 准备 交叉编译工具链： 交叉编译：是A机器上编译生成，运行在B机器上。两个机子有不同的机器指令。 工具链：一般由编译器、连接器、解释器和调试器组成。 构建交叉工具链方法： 方法一：分步编译和安装交叉编译工具链所需要的库和源代码，最终生成交叉编译工具链。该方法相对比较困难，适合想深入学习构建交叉工具链的读者。如果只是想使用交叉工具链，建议使用下列的方法二构建交叉工具链。 方法二 通过Crosstool脚本工具来实现一次编译，生成交叉编译工具链，该方法相对于方法一要简单许多，并且出错的机会也非常少，建议大多数情况下使用该方法构建交叉编译工具链。 方法三 直接通过网上下载已经制作好的交叉编译工具链。该方法的优点不用多说，当然是简单省事，但该方法有一定的弊端就是局限性太大，因为毕竟是别人构建好的，也就是固定的，没有灵活性，所以构建所用的库以及编译器的版本也许并不适合你要编译的程序，同时也许会在使用时出现许多莫名其妙的错误，建议读者慎用此方法。 2.2 安装编译工具链3.编译参数","categories":[{"name":"golang","slug":"golang","permalink":"https://hxlpub.github.io/categories/golang/"}],"tags":[{"name":"golang","slug":"golang","permalink":"https://hxlpub.github.io/tags/golang/"}]},{"title":"golang之fan-out模式","slug":"go_fan-out","date":"2021-09-13T14:29:54.000Z","updated":"2022-03-26T08:25:14.339Z","comments":true,"path":"2021/09/13/go_fan-out/","link":"","permalink":"https://hxlpub.github.io/2021/09/13/go_fan-out/","excerpt":"","text":"Go 语言在构建微服务、特别是有使用 gRPC 的应用中，非常地流行，其实在构建命令行程序时也是特别地好用。为了学习扇出模式，我会基于我们公司使用 ETL 的例子，来介绍这个模式。 ## ETL ETL（提取（Extract），转换（Transform），加载（Load））通常都需要处理大量的数据。在这样的场景下，有一个好的并发策略对于 ETL 来说，能够带来巨大的性能提升。 ETL 中有两个最重要的部分是提取（extracting）和加载（Load），通常它们都跟数据库有关，瓶颈通常也属于老生常谈的话题：网络带宽，查询性能等等。基于我们要处理的数据以及瓶颈所在，两种模式对于处理数据或者处理输入流的编码和解码过程中，非常有用。 ## 扇入扇出模式（Fan-in, fan-out pattern） 扇入和扇出模式在并发场景中能得到较大的好处。这里将对它们逐个做专门的介绍（review）： 扇出，在 GO 博客中这样定义： 多个函数能够同时从相同的 channel 中读数据，直到 channel 关闭。 这种模式在快速输入流到分布式数据处理中，有一定的优势： 扇入，在 Google 这样定义： 一个函数可以从多个输入中读取，并继续操作，直到所有 channel 所关联的输入端，都已经关闭。 这种模式，在有多个输入源，且需要快速地数据处理中，有一定的优势： ## 在实际中使用扇出模式（Fan-out in action） 在我们的项目中，我们需要处理存储在 CSV 文件的大量数据，它们加载后，将在 elastic 中被检索。输入的处理必须快，否则（阻塞加载）加载就会变得很慢。因此，我们需要比输入生成器更多的数据处理器。扇出模式在这个例子中，看起来非常适合： 下面是我们的伪代码： bash Variables: data chan Start: // a goroutine will parse the CSV and will send it to the channel ParseCSV(data&lt;-) // a goroutine is started for each workers, defined as command line arguments For each worker in workers Start goroutine For each value in &lt;-data Insert the value in database by chunk of 50 Wait for the workers Stop 输入和加载程序是并发执行的，我们不需要等到解析完成后再开始启动数据处理程序。 这种模式让我们可以单独考虑业务逻辑的同时，还可以使用（Go)并发的特性。几个工作器之间原生的分布式负载能力，有助于我们解决此类过程中的峰值负载问题。","categories":[{"name":"golang","slug":"golang","permalink":"https://hxlpub.github.io/categories/golang/"}],"tags":[{"name":"golang","slug":"golang","permalink":"https://hxlpub.github.io/tags/golang/"}]},{"title":"import rules","slug":"go_import_rules","date":"2021-09-13T14:29:54.000Z","updated":"2022-03-26T08:26:16.178Z","comments":true,"path":"2021/09/13/go_import_rules/","link":"","permalink":"https://hxlpub.github.io/2021/09/13/go_import_rules/","excerpt":"","text":"https://www.cnblogs.com/f-ck-need-u/p/9847554.html","categories":[{"name":"golang","slug":"golang","permalink":"https://hxlpub.github.io/categories/golang/"}],"tags":[{"name":"golang","slug":"golang","permalink":"https://hxlpub.github.io/tags/golang/"}]},{"title":"golang之内建函数","slug":"go_func_builtin","date":"2021-09-13T14:29:54.000Z","updated":"2022-03-26T08:25:43.812Z","comments":true,"path":"2021/09/13/go_func_builtin/","link":"","permalink":"https://hxlpub.github.io/2021/09/13/go_func_builtin/","excerpt":"","text":"1、new and make :https://www.jb51.net/article/126703.htm","categories":[{"name":"golang","slug":"golang","permalink":"https://hxlpub.github.io/categories/golang/"}],"tags":[{"name":"golang","slug":"golang","permalink":"https://hxlpub.github.io/tags/golang/"}]},{"title":"golang标准包packages","slug":"go_packages","date":"2021-09-13T14:29:54.000Z","updated":"2022-03-26T08:27:50.697Z","comments":true,"path":"2021/09/13/go_packages/","link":"","permalink":"https://hxlpub.github.io/2021/09/13/go_packages/","excerpt":"","text":"","categories":[{"name":"golang","slug":"golang","permalink":"https://hxlpub.github.io/categories/golang/"}],"tags":[{"name":"golang","slug":"golang","permalink":"https://hxlpub.github.io/tags/golang/"}]},{"title":"notes","slug":"love","date":"2021-09-12T09:05:23.000Z","updated":"2022-03-26T08:48:12.204Z","comments":true,"path":"2021/09/12/love/","link":"","permalink":"https://hxlpub.github.io/2021/09/12/love/","excerpt":"","text":"ps:宝宝，爱你！！！","categories":[{"name":"startup","slug":"startup","permalink":"https://hxlpub.github.io/categories/startup/"}],"tags":[{"name":"love","slug":"love","permalink":"https://hxlpub.github.io/tags/love/"}]}],"categories":[{"name":"git","slug":"git","permalink":"https://hxlpub.github.io/categories/git/"},{"name":"开发工具","slug":"开发工具","permalink":"https://hxlpub.github.io/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"},{"name":"数据结构&算法分析","slug":"数据结构-算法分析","permalink":"https://hxlpub.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/"},{"name":"c","slug":"c","permalink":"https://hxlpub.github.io/categories/c/"},{"name":"分布式-对象存储-daos","slug":"分布式-对象存储-daos","permalink":"https://hxlpub.github.io/categories/%E5%88%86%E5%B8%83%E5%BC%8F-%E5%AF%B9%E8%B1%A1%E5%AD%98%E5%82%A8-daos/"},{"name":"codes","slug":"codes","permalink":"https://hxlpub.github.io/categories/codes/"},{"name":"Python","slug":"Python","permalink":"https://hxlpub.github.io/categories/Python/"},{"name":"Linux","slug":"Linux","permalink":"https://hxlpub.github.io/categories/Linux/"},{"name":"startup","slug":"startup","permalink":"https://hxlpub.github.io/categories/startup/"},{"name":"设计模式","slug":"设计模式","permalink":"https://hxlpub.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"golang","slug":"golang","permalink":"https://hxlpub.github.io/categories/golang/"},{"name":"编译","slug":"编译","permalink":"https://hxlpub.github.io/categories/%E7%BC%96%E8%AF%91/"},{"name":"cplusplus","slug":"cplusplus","permalink":"https://hxlpub.github.io/categories/cplusplus/"},{"name":"Hexo","slug":"Hexo","permalink":"https://hxlpub.github.io/categories/Hexo/"},{"name":"算法","slug":"算法","permalink":"https://hxlpub.github.io/categories/%E7%AE%97%E6%B3%95/"},{"name":"计算机视觉CV","slug":"计算机视觉CV","permalink":"https://hxlpub.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89CV/"},{"name":"数据库","slug":"数据库","permalink":"https://hxlpub.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"深度学习","slug":"深度学习","permalink":"https://hxlpub.github.io/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"},{"name":"机器学习","slug":"机器学习","permalink":"https://hxlpub.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"版本管理","slug":"版本管理","permalink":"https://hxlpub.github.io/tags/%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86/"},{"name":"Typora","slug":"Typora","permalink":"https://hxlpub.github.io/tags/Typora/"},{"name":"Structures&Algorithm","slug":"Structures-Algorithm","permalink":"https://hxlpub.github.io/tags/Structures-Algorithm/"},{"name":"c","slug":"c","permalink":"https://hxlpub.github.io/tags/c/"},{"name":"对象存储","slug":"对象存储","permalink":"https://hxlpub.github.io/tags/%E5%AF%B9%E8%B1%A1%E5%AD%98%E5%82%A8/"},{"name":"codes","slug":"codes","permalink":"https://hxlpub.github.io/tags/codes/"},{"name":"Python","slug":"Python","permalink":"https://hxlpub.github.io/tags/Python/"},{"name":"python","slug":"python","permalink":"https://hxlpub.github.io/tags/python/"},{"name":"Linux","slug":"Linux","permalink":"https://hxlpub.github.io/tags/Linux/"},{"name":"systemd","slug":"systemd","permalink":"https://hxlpub.github.io/tags/systemd/"},{"name":"love more","slug":"love-more","permalink":"https://hxlpub.github.io/tags/love-more/"},{"name":"设计模式","slug":"设计模式","permalink":"https://hxlpub.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"golang","slug":"golang","permalink":"https://hxlpub.github.io/tags/golang/"},{"name":"Makefile","slug":"Makefile","permalink":"https://hxlpub.github.io/tags/Makefile/"},{"name":"cplusplus","slug":"cplusplus","permalink":"https://hxlpub.github.io/tags/cplusplus/"},{"name":"Hexo","slug":"Hexo","permalink":"https://hxlpub.github.io/tags/Hexo/"},{"name":"排序算法","slug":"排序算法","permalink":"https://hxlpub.github.io/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"},{"name":"编译","slug":"编译","permalink":"https://hxlpub.github.io/tags/%E7%BC%96%E8%AF%91/"},{"name":"cv","slug":"cv","permalink":"https://hxlpub.github.io/tags/cv/"},{"name":"pg","slug":"pg","permalink":"https://hxlpub.github.io/tags/pg/"},{"name":"postgres","slug":"postgres","permalink":"https://hxlpub.github.io/tags/postgres/"},{"name":"DL","slug":"DL","permalink":"https://hxlpub.github.io/tags/DL/"},{"name":"linux","slug":"linux","permalink":"https://hxlpub.github.io/tags/linux/"},{"name":"open_sites","slug":"open-sites","permalink":"https://hxlpub.github.io/tags/open-sites/"},{"name":"shell","slug":"shell","permalink":"https://hxlpub.github.io/tags/shell/"},{"name":"编译FAQ","slug":"编译FAQ","permalink":"https://hxlpub.github.io/tags/%E7%BC%96%E8%AF%91FAQ/"},{"name":"ML","slug":"ML","permalink":"https://hxlpub.github.io/tags/ML/"},{"name":"vscode_extensions","slug":"vscode-extensions","permalink":"https://hxlpub.github.io/tags/vscode-extensions/"},{"name":"love","slug":"love","permalink":"https://hxlpub.github.io/tags/love/"}]}