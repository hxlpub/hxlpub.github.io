{"meta":{"title":"linhongxun's blog","subtitle":"","description":"沉淀技术","author":"linhongxun","url":"https://hxlpub.github.io","root":"/"},"pages":[{"title":"","date":"2022-01-23T13:22:32.794Z","updated":"2022-01-23T13:22:32.794Z","comments":true,"path":"baidu_verify_code-cy3v7EZjHQ.html","permalink":"https://hxlpub.github.io/baidu_verify_code-cy3v7EZjHQ.html","excerpt":"","text":"af8c45052f3f71cf99a43cc291aaf1c8"},{"title":"about me","date":"2021-09-12T12:48:58.000Z","updated":"2021-09-22T12:59:16.000Z","comments":true,"path":"about/index.html","permalink":"https://hxlpub.github.io/about/index.html","excerpt":"","text":"E-mail: &#104;&#x6f;&#110;&#103;&#120;&#117;&#110;&#x6c;&#105;&#110;&#x70;&#117;&#98;&#x40;&#49;&#54;&#51;&#46;&#99;&#x6f;&#x6d; &#104;&#x6f;&#110;&#x67;&#120;&#x75;&#x6e;&#x6c;&#105;&#x6e;&#64;&#115;&#x69;&#x6e;&#x61;&#x2e;&#x63;&#x6f;&#x6d;my blog: https://hxlpub.github.io my github: https://github.com/hxlpub"},{"title":"categories","date":"2021-09-12T12:40:56.000Z","updated":"2021-09-12T12:42:06.000Z","comments":true,"path":"categories/index.html","permalink":"https://hxlpub.github.io/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2021-09-12T12:49:10.000Z","updated":"2021-09-12T12:53:08.000Z","comments":true,"path":"tags/index.html","permalink":"https://hxlpub.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"daos学习","slug":"daos_2.0","date":"2022-01-24T07:57:07.000Z","updated":"2022-01-24T08:00:10.472Z","comments":true,"path":"2022/01/24/daos_2.0/","link":"","permalink":"https://hxlpub.github.io/2022/01/24/daos_2.0/","excerpt":"","text":"1.","categories":[{"name":"存储","slug":"存储","permalink":"https://hxlpub.github.io/categories/%E5%AD%98%E5%82%A8/"},{"name":"分布式异步存储系统","slug":"存储/分布式异步存储系统","permalink":"https://hxlpub.github.io/categories/%E5%AD%98%E5%82%A8/%E5%88%86%E5%B8%83%E5%BC%8F%E5%BC%82%E6%AD%A5%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F/"},{"name":"daos","slug":"存储/分布式异步存储系统/daos","permalink":"https://hxlpub.github.io/categories/%E5%AD%98%E5%82%A8/%E5%88%86%E5%B8%83%E5%BC%8F%E5%BC%82%E6%AD%A5%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F/daos/"}],"tags":[]},{"title":"notes2022","slug":"newpc","date":"2022-01-15T09:05:23.000Z","updated":"2022-01-15T05:46:45.630Z","comments":true,"path":"2022/01/15/newpc/","link":"","permalink":"https://hxlpub.github.io/2022/01/15/newpc/","excerpt":"","text":"ps:new year love more ！！！","categories":[{"name":"startup","slug":"startup","permalink":"https://hxlpub.github.io/categories/startup/"}],"tags":[{"name":"love more","slug":"love-more","permalink":"https://hxlpub.github.io/tags/love-more/"}]},{"title":"基础概念","slug":"system_design_thinking","date":"2022-01-13T02:16:07.000Z","updated":"2022-01-13T02:29:24.000Z","comments":true,"path":"2022/01/13/system_design_thinking/","link":"","permalink":"https://hxlpub.github.io/2022/01/13/system_design_thinking/","excerpt":"","text":"1、异步同步阻塞非阻塞（以下知乎十分有趣） https://www.zhihu.com/question/26393784 老张爱喝茶，废话不说，煮开水。 出场人物：老张，水壶两把（普通水壶，简称水壶；会响的水壶，简称响水壶）。 1)老张把水壶放到火上，立等水开。（同步阻塞） 老张觉得自己有点傻 2)老张把水壶放到火上，去客厅看电视，时不时去厨房看看水开没有。（同步非阻塞） 老张还是觉得自己有点傻，于是变高端了，买了把会响笛的那种水壶。水开之后，能大声发出嘀~~~~的噪音。 3)老张把响水壶放到火上，立等水开。（异步阻塞） 老张觉得这样傻等意义不大 4)老张把响水壶放到火上，去客厅看电视，水壶响之前不再去看它了，响了再去拿壶。（异步非阻塞） 老张觉得自己聪明了。 所谓同步异步，只是对于水壶而言。 普通水壶，同步；响水壶，异步。 虽然都能干活，但响水壶可以在自己完工之后，提示老张水开了。这是普通水壶所不能及的。 同步只能让调用者去轮询自己（情况2中），造成老张效率的低下。所谓阻塞非阻塞，仅仅对于老张而言。 立等的老张，阻塞；看电视的老张，非阻塞。 情况1和情况3中老张就是阻塞的，媳妇喊他都不知道。虽然3中响水壶是异步的，可对于立等的老张没有太大的意义。所以一般异步是配合非阻塞使用的，这样才能发挥异步的效用。 作者：知乎用户链接：https://www.zhihu.com/question/26393784/answer/513257548来源：知乎著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。","categories":[{"name":"设计之道","slug":"设计之道","permalink":"https://hxlpub.github.io/categories/%E8%AE%BE%E8%AE%A1%E4%B9%8B%E9%81%93/"},{"name":"概念","slug":"设计之道/概念","permalink":"https://hxlpub.github.io/categories/%E8%AE%BE%E8%AE%A1%E4%B9%8B%E9%81%93/%E6%A6%82%E5%BF%B5/"}],"tags":[{"name":"设计","slug":"设计","permalink":"https://hxlpub.github.io/tags/%E8%AE%BE%E8%AE%A1/"}]},{"title":"go基础+原理修养","slug":"go_base","date":"2022-01-09T04:47:30.000Z","updated":"2022-02-10T11:19:19.344Z","comments":true,"path":"2022/01/09/go_base/","link":"","permalink":"https://hxlpub.github.io/2022/01/09/go_base/","excerpt":"","text":"","categories":[{"name":"服务端","slug":"服务端","permalink":"https://hxlpub.github.io/categories/%E6%9C%8D%E5%8A%A1%E7%AB%AF/"},{"name":"go","slug":"服务端/go","permalink":"https://hxlpub.github.io/categories/%E6%9C%8D%E5%8A%A1%E7%AB%AF/go/"},{"name":"语言基础+原理","slug":"服务端/go/语言基础-原理","permalink":"https://hxlpub.github.io/categories/%E6%9C%8D%E5%8A%A1%E7%AB%AF/go/%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80-%E5%8E%9F%E7%90%86/"}],"tags":[{"name":"服务端","slug":"服务端","permalink":"https://hxlpub.github.io/tags/%E6%9C%8D%E5%8A%A1%E7%AB%AF/"}]},{"title":"go基础+原理修养","slug":"go_base_coding_rule","date":"2022-01-09T04:47:30.000Z","updated":"2022-01-12T10:55:34.000Z","comments":true,"path":"2022/01/09/go_base_coding_rule/","link":"","permalink":"https://hxlpub.github.io/2022/01/09/go_base_coding_rule/","excerpt":"","text":"​ ​","categories":[{"name":"服务端","slug":"服务端","permalink":"https://hxlpub.github.io/categories/%E6%9C%8D%E5%8A%A1%E7%AB%AF/"},{"name":"go","slug":"服务端/go","permalink":"https://hxlpub.github.io/categories/%E6%9C%8D%E5%8A%A1%E7%AB%AF/go/"},{"name":"编码规范","slug":"服务端/go/编码规范","permalink":"https://hxlpub.github.io/categories/%E6%9C%8D%E5%8A%A1%E7%AB%AF/go/%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83/"}],"tags":[{"name":"服务端","slug":"服务端","permalink":"https://hxlpub.github.io/tags/%E6%9C%8D%E5%8A%A1%E7%AB%AF/"}]},{"title":"Makefile","slug":"Makefile","date":"2021-11-09T11:56:07.000Z","updated":"2021-11-09T11:56:48.000Z","comments":true,"path":"2021/11/09/Makefile/","link":"","permalink":"https://hxlpub.github.io/2021/11/09/Makefile/","excerpt":"","text":"​","categories":[{"name":"服务端","slug":"服务端","permalink":"https://hxlpub.github.io/categories/%E6%9C%8D%E5%8A%A1%E7%AB%AF/"},{"name":"编译","slug":"服务端/编译","permalink":"https://hxlpub.github.io/categories/%E6%9C%8D%E5%8A%A1%E7%AB%AF/%E7%BC%96%E8%AF%91/"},{"name":"Makefile","slug":"服务端/编译/Makefile","permalink":"https://hxlpub.github.io/categories/%E6%9C%8D%E5%8A%A1%E7%AB%AF/%E7%BC%96%E8%AF%91/Makefile/"}],"tags":[]},{"title":"C 的几个重要特性","slug":"c_c++","date":"2021-11-06T03:55:07.000Z","updated":"2022-01-02T05:12:22.000Z","comments":true,"path":"2021/11/06/c_c++/","link":"","permalink":"https://hxlpub.github.io/2021/11/06/c_c++/","excerpt":"","text":"1.本篇目的：着重介绍C的几个重要特性一级底层原理 2.本篇的结构 第一部分：几个重要的特性与底层原理 第二部分：结合开源项目特性应用 第三部分：良好的编码风格（附录） 第一部分：几个重要的特性与底层原理 预处理器几个特性 #include指令：文件包含，该指令所在的行都将被替换为由文件名指定的文件的内容，一种将所有声明捆绑在一起的较好的办法，保证所有的源文件有相同的定义与变量声明 ​ #include “文件” ：先在源文件所在位置查找该文件，如果在该位置未找到，再根据相应规则查找 ​ #include &lt;文件&gt; ：根据相应规则查找 #define指令：宏替换，#define 名字 替换文本 宏：将函数定义为宏可避免调用函数时所需的运行时开销 变量 类型 作用域 存储位置 生命周期 特点 static 所在文件（static 外部变量）、 所在函数（static 局部变量） 定义后一直占据存储空间 只被初始化一次（程序执行前），初始化表达式是常量表达式，没有初始化表达式的元素被初始化为0 register 局部变量 、函数形参 寄存器 程序更小，执行速度更快 外部变量external 只被初始化一次（程序执行前），初始化表达式必须是常量表达式，没有初始化表达式的元素被初始化为0; 局部变量 函数内部 函数被调用期间 每次进入函数或程序块都初始化，没有初始化表达式的元素被初始化为0 指针 ​ 运算符&amp;：取地址，只能应用于内存中对象，即变量与数组元素，不能作用与表达式、常量、或register变量​ 运算符：间接寻址或间接引用运算符，作用于指针时，将访问指针所指向的对象。​ &amp;、优先级高于算术运算符​ 指针变量可以相互赋值，指向相同的对象 1）指针与数组 ： ​ 一般，指针编写的程序比用数组下标编写的程序执行速度快​ 一个通过数组和下标实现的表达式可等价地通过指针和偏移量实现 ​ char s[] == char *s 、&amp;a[2] == a+2 （a数组） 2）特性 某些情况下对指针进行比较运算（如指针p、q指向同一个数组的成员） 指针可以和整数相加或相减 指针的算术运算具有一致性：所有的指针运算都会自动考虑它所指向的对象的长度 有效的指针运算： 相同类型指针之间赋值运算 指针同整数之间的加法减法 指向相同数组中元素的两个指针间的减法和比较运算 指针赋值为0或指针与0之间的比较运算 3）指针数组、指针的指针 如char *lineptr[10] 初始化：如，static char *name[] = {“xiaoming”,”xiaoqiang”} 指针数组优点：数组的每一个元素的长度可以不同 4)函数指针 K&amp;R P99 运算符优先级 1）优先级1：数组下标[]，圆括号( )，成员选择（对象）.，成员选择（指针）-&gt; 结合方向为左到右 2）优先级2：负号运算符-，强制类型转换，自增运算符++，自减运算符–，取值运算符，取地址运算符&amp;，逻辑非运算符！，按位取反运算符~，长度运算sizeof符，结合方向为右到左 3）优先级3：除/，乘*，余数%，结合方向为左到右 4）优先级4：加+，减-，结合方向为左到右 5）优先级5：左移&lt;&lt;，右移&gt;&gt;，结合方向为左到右 6）优先级6：大于&gt;，大于等于&gt;=，小于&lt;，小于等于&lt;=，结合方向为左到右 7）优先级7：等于==，不等于!=，结合方向为左到右 8）优先级8：级别先后为，按位与&amp;，按位异或^，按位或| ，逻辑与&amp;&amp;，逻辑或|| 条件运算符?:，注意得是条件运算结合方向为右到左 9）优先级9：赋值运算符=，除后赋值/=，乘后赋值*=，取模后赋值%=，加后赋值+=，减后赋值-=，左移后赋值&lt;&lt;=，右移后赋值&gt;&gt;=，按位与后赋值&amp;=，按位异或后赋值^=，按位或后赋值|=，结合方向为右到左 结构 struct point { ​ int x; ​ int y; }; 声明：struct {int x,int y} x,y,z; #分配存储空间 ​ struct point pt; 初始化： ​ struct point maxpt = {320, 200}; 成员：maxpt.x ​ maxpt.y 嵌套： ​ struct rect { ​ struct point pt1; ​ struct point pt2; ​ }; ​ struct rect screen; ​ 成员： screen.pt1.x 合法操作： ​ 1.作为一个整体赋值和赋值 ​ 2.通过&amp;取地址 ​ 3.访问其成员 结构指针： ​ struct point *ptrstr; ​ ptrstr -&gt; x 结构数组 ​ struct key {​ char *word;​ int count; &#125; keytab[] = &#123; &#123; &quot;auto&quot;, 0 &#125;, &#123; &quot;break&quot;, 0 &#125;, &#123; &quot;case&quot;, 0 &#125; ​ } 结构指针 ​ 关键字统计 自引用结构 ​ K$R P116 ex:统计输入所有单词出现频次（二叉树） 表查找 类型定义（typedef） 联合 位字段 ​ 命令行参数 123456789101112131415#include &lt;stdio.h&gt;#include &lt;string.h&gt;int main(int argc, char *argv[] )&#123; #./test -x 注意优先级顺序 printf(&quot;%s\\n&quot;,argv[0]);#./test printf(&quot;%c\\n&quot;,(*++argv)[0]);#- argv指向argv[1] printf(&quot;%c\\n&quot;,*++argv[0]);#x,先与[]结合,所以依然指向argv[1] printf(&quot;%d\\n&quot;,argc);#2&#125;~ 运算符集合 控制流语句 标准库 ​ 输入输出：printf (“%d”,i)、scanf(“%d”,&amp;i) ​ 文件访问： ​ 1.打开文件，返回文件指针 ​ 123FILE *fp;FILE *fopen(char *name,char *mode) fp = fopen(name,mode) ​ 2.文件读写 ​ int getc(FILE *fp) ​ int putc(FILE *fp) ​ #define getchar() getc(stdin)​ #define putchar(c) putc((c), stdout) ​ int fscanf(FILE *fp, char *format, …)​ int fprintf(FILE *fp, char *format, …) ​ 3.关闭文件 ​ int fclose (FILE *fp) ​ 错误处理 ​ stderr 和exit ​ fprintf(stderr, “%s: can’t open %s\\n”,prog, *argv); ​ int ferror（FILE *fp）#若流fp中出错，则函数返回一个非0值 ​ int feof(FILE *fp) #如果指定的文件到达文件结尾，返回一个非0值 ​ 行输入行输出 ​ char *fgets(char *line, int maxline, FILE *fp) #读文件一行到line ​ int fputs(char *line, FILE *fp)#写line到文件 ​ 其他函数 ​ UNIX系统接口 系统调用：操作系统内的函数，实现标准库函数，不同的操作系统实现其标准库函数的方式和方法不同 read、write#输入输出 int n_read = read(int fd, char *buf, int n);int n_written = write(int fd, char *buf, int n); open、create#读写之前显式打开文件，open打开已存在文件，如果打开一个不存在文件报错，而create创建新文件或覆盖已有旧文件 #flags ：O_RDONLY、O_WRONLY、O_RDWR，perms：权限， int fd;int open(char *name, int flags, int perms);fd = open(name, flags, perms); int creat(char *name, int perms);fd = creat(name, perms); close、unlink# lseek#随机访问，不实际读写数据 long lseek(int fd, long offset, int origin); 第二部分：结合开源项目特性应用 第三部分：良好的编码风格（附录） 正确缩进 适当空格 运算符两边各加一个空格字符","categories":[{"name":"服务端","slug":"服务端","permalink":"https://hxlpub.github.io/categories/%E6%9C%8D%E5%8A%A1%E7%AB%AF/"},{"name":"C_C++","slug":"服务端/C-C","permalink":"https://hxlpub.github.io/categories/%E6%9C%8D%E5%8A%A1%E7%AB%AF/C-C/"},{"name":"基础篇：C","slug":"服务端/C-C/基础篇：C","permalink":"https://hxlpub.github.io/categories/%E6%9C%8D%E5%8A%A1%E7%AB%AF/C-C/%E5%9F%BA%E7%A1%80%E7%AF%87%EF%BC%9AC/"}],"tags":[]},{"title":"C++基础知识","slug":"c++ ","date":"2021-11-06T03:55:07.000Z","updated":"2022-01-02T09:33:46.000Z","comments":true,"path":"2021/11/06/c++ /","link":"","permalink":"https://hxlpub.github.io/2021/11/06/c++%20/","excerpt":"","text":"一、复合类型 ​","categories":[{"name":"服务端","slug":"服务端","permalink":"https://hxlpub.github.io/categories/%E6%9C%8D%E5%8A%A1%E7%AB%AF/"},{"name":"C_C++","slug":"服务端/C-C","permalink":"https://hxlpub.github.io/categories/%E6%9C%8D%E5%8A%A1%E7%AB%AF/C-C/"},{"name":"C++篇：回顾","slug":"服务端/C-C/C-篇：回顾","permalink":"https://hxlpub.github.io/categories/%E6%9C%8D%E5%8A%A1%E7%AB%AF/C-C/C-%E7%AF%87%EF%BC%9A%E5%9B%9E%E9%A1%BE/"}],"tags":[]},{"title":"hexo搭建博客","slug":"hexo_build_blog","date":"2021-09-15T13:08:37.000Z","updated":"2021-10-21T12:39:58.000Z","comments":true,"path":"2021/09/15/hexo_build_blog/","link":"","permalink":"https://hxlpub.github.io/2021/09/15/hexo_build_blog/","excerpt":"","text":"2021-10-21–评论系统上线啦！！！","categories":[{"name":"前端","slug":"前端","permalink":"https://hxlpub.github.io/categories/%E5%89%8D%E7%AB%AF/"},{"name":"静态页面","slug":"前端/静态页面","permalink":"https://hxlpub.github.io/categories/%E5%89%8D%E7%AB%AF/%E9%9D%99%E6%80%81%E9%A1%B5%E9%9D%A2/"},{"name":"Hexo静态页面生成器","slug":"前端/静态页面/Hexo静态页面生成器","permalink":"https://hxlpub.github.io/categories/%E5%89%8D%E7%AB%AF/%E9%9D%99%E6%80%81%E9%A1%B5%E9%9D%A2/Hexo%E9%9D%99%E6%80%81%E9%A1%B5%E9%9D%A2%E7%94%9F%E6%88%90%E5%99%A8/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://hxlpub.github.io/tags/Hexo/"}]},{"title":"go实现tcp协议","slug":"go_tcp","date":"2021-09-15T07:42:30.000Z","updated":"2021-10-09T12:09:12.000Z","comments":true,"path":"2021/09/15/go_tcp/","link":"","permalink":"https://hxlpub.github.io/2021/09/15/go_tcp/","excerpt":"","text":"1、client端client.go123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475//tcpclient 为client.go所在的上一层目录package tcpclientimport ( &quot;net&quot; &quot;fmt&quot; //&quot;io/ioutil&quot; &quot;strconv&quot; //&quot;../log&quot; //&quot;strings&quot; //&quot;bytes&quot; //&quot;encoding/xml&quot;)//组装tcp请求func RequestMsg(serialNum string, randomNum string, toAddr string, fromAddr string) string &#123; body := &quot;&lt;?xml version=\\&quot;1.0\\&quot;?&gt;\\r\\n&quot; + &quot;&lt;Config&gt;\\r\\n&quot; + &quot;&lt;CmdType&gt;ACTIVE&lt;/CmdType&gt;\\r\\n&quot; + &quot;&lt;CmdInfo&gt;GetActiveInfo&lt;/CmdInfo&gt;\\r\\n&quot; + &quot;&lt;SerialNumInfo&gt;\\r\\n&quot; + &quot;&lt;SerialNum&gt;&quot; + serialNum + &quot;&lt;/SerialNum&gt;\\r\\n&quot; + &quot;&lt;/SerialNumInfo&gt;\\r\\n&quot; + &quot;&lt;/Config&gt;&quot; head := &quot;HIK-PRODUCT\\r\\n&quot; + &quot;Via:HIKSTOR/1.0/TCP\\r\\n&quot; + &quot;From:&quot; + fromAddr + &quot;\\r\\n&quot; + &quot;To:&quot; + toAddr + &quot;\\r\\n&quot; + &quot;Call-ID:&quot; + randomNum + &quot;\\r\\n&quot; + &quot;Content-Type:xml\\r\\n&quot; + &quot;Content-Length:&quot; + strconv.Itoa(len(body)) + &quot;\\r\\n\\r\\n&quot; return head + body //return body&#125;//向server端发起请求func GetBomInfoFromThirdServ(serialNum string,randomNum string, toAddr string, fromAddr string) (string,error) &#123; //主动发起连接请求 conn,err :=net.Dial(&quot;tcp&quot;,&quot;10.192.44.183:35004&quot;) if err != nil &#123; fmt.Println(&quot;dial err&quot;,err) return &quot;&quot;, err &#125; defer conn.Close() //向服务端发送请求 reqmsg := RequestMsg(serialNum,randomNum,toAddr,fromAddr) _, err = conn.Write([]byte(reqmsg)) if err != nil &#123; fmt.Println(&quot;send err=&quot;, err) //出错退出 return &quot;&quot;,err &#125; //接收响应 buf := make([]byte, 1024) //response, err :=ioutil.ReadAll(conn) //if err != nil &#123; // fmt.Println(&quot;rec err&quot;,err) // return &quot;&quot;, err //&#125; n, err :=conn.Read(buf) //fmt.Println(&quot;n=&quot;, n) if err != nil &#123; fmt.Println(&quot;服务器read err=&quot;, err) //出错退出 return &quot;&quot;,err &#125; return string(buf[:n-1]),nil //return buf,nil &#125; 2、server端server.go","categories":[{"name":"服务端","slug":"服务端","permalink":"https://hxlpub.github.io/categories/%E6%9C%8D%E5%8A%A1%E7%AB%AF/"},{"name":"go","slug":"服务端/go","permalink":"https://hxlpub.github.io/categories/%E6%9C%8D%E5%8A%A1%E7%AB%AF/go/"},{"name":"协议开发","slug":"服务端/go/协议开发","permalink":"https://hxlpub.github.io/categories/%E6%9C%8D%E5%8A%A1%E7%AB%AF/go/%E5%8D%8F%E8%AE%AE%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"服务端","slug":"服务端","permalink":"https://hxlpub.github.io/tags/%E6%9C%8D%E5%8A%A1%E7%AB%AF/"}]},{"title":"Python基础","slug":"Python","date":"2021-09-14T09:26:07.000Z","updated":"2022-02-26T07:47:41.136Z","comments":true,"path":"2021/09/14/Python/","link":"","permalink":"https://hxlpub.github.io/2021/09/14/Python/","excerpt":"","text":"一、初级 环境搭建 基础语法 1 基本数据类型 数据类型转换 推导式 解释器 注释 运算符 数字 字符串 列表 元组 字典 集合 条件控制 循环语句 迭代器与生成器 函数 数据结构 模块 输入输出 File OS 错误与异常处理 面向对象 命名空间/作用域 标准库 二、高级 正则表达式 CGI编程 MySql","categories":[{"name":"服务端","slug":"服务端","permalink":"https://hxlpub.github.io/categories/%E6%9C%8D%E5%8A%A1%E7%AB%AF/"},{"name":"Python","slug":"服务端/Python","permalink":"https://hxlpub.github.io/categories/%E6%9C%8D%E5%8A%A1%E7%AB%AF/Python/"},{"name":"语言基础原理","slug":"服务端/Python/语言基础原理","permalink":"https://hxlpub.github.io/categories/%E6%9C%8D%E5%8A%A1%E7%AB%AF/Python/%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%8E%9F%E7%90%86/"}],"tags":[]},{"title":"算法","slug":"algorithm","date":"2021-09-14T09:26:07.000Z","updated":"2022-01-07T01:40:12.000Z","comments":true,"path":"2021/09/14/algorithm/","link":"","permalink":"https://hxlpub.github.io/2021/09/14/algorithm/","excerpt":"","text":"1.二分排序 K&amp;R P99","categories":[{"name":"算法","slug":"算法","permalink":"https://hxlpub.github.io/categories/%E7%AE%97%E6%B3%95/"},{"name":"排序","slug":"算法/排序","permalink":"https://hxlpub.github.io/categories/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F/"}],"tags":[]},{"title":"GCC编译","slug":"compile_debug","date":"2021-09-14T09:26:07.000Z","updated":"2022-02-26T07:50:30.168Z","comments":true,"path":"2021/09/14/compile_debug/","link":"","permalink":"https://hxlpub.github.io/2021/09/14/compile_debug/","excerpt":"","text":"​ GCC原名为GNU C语言编译器（GNU C Compiler），只能处理C语言。但其很快扩展，变得可处理C++，后来又扩展为能够支持更多编程语言，如Fortran、Pascal、Objective -C、Java、Ada、Go以及各类处理器架构上的汇编语言等，所以改名GNU编译器套件（GNU Compiler Collection）。 ​ 虽然我们称GCC是C语言的编译器，但使用gcc由C语言源代码文件生成可执行文件的过程不仅仅是编译的过程，而是要经历四个相互关联的步骤∶ ​ 预处理（也称预编译，Preprocessing） ​ 编译（Compilation） ​ 汇编（Assembly） ​ 链接（Linking）","categories":[{"name":"服务端","slug":"服务端","permalink":"https://hxlpub.github.io/categories/%E6%9C%8D%E5%8A%A1%E7%AB%AF/"},{"name":"编译","slug":"服务端/编译","permalink":"https://hxlpub.github.io/categories/%E6%9C%8D%E5%8A%A1%E7%AB%AF/%E7%BC%96%E8%AF%91/"},{"name":"GCC编译","slug":"服务端/编译/GCC编译","permalink":"https://hxlpub.github.io/categories/%E6%9C%8D%E5%8A%A1%E7%AB%AF/%E7%BC%96%E8%AF%91/GCC%E7%BC%96%E8%AF%91/"}],"tags":[]},{"title":"GCC编译","slug":"compiler","date":"2021-09-14T09:26:07.000Z","updated":"2022-03-03T09:39:38.195Z","comments":true,"path":"2021/09/14/compiler/","link":"","permalink":"https://hxlpub.github.io/2021/09/14/compiler/","excerpt":"","text":"section 1 GCC​ GCC原名为GNU C语言编译器（GNU C Compiler），只能处理C语言。但其很快扩展，变得可处理C++，后来又扩展为能够支持更多编程语言，如Fortran、Pascal、Objective -C、Java、Ada、Go以及各类处理器架构上的汇编语言等，所以改名GNU编译器套件（GNU Compiler Collection）。 ​ 虽然我们称GCC是C语言的编译器，但使用gcc由C语言源代码文件生成可执行文件的过程不仅仅是编译的过程，而是要经历四个相互关联的步骤∶ ​ 预处理（也称预编译，Preprocessing） ​ 编译（Compilation） ​ 汇编（Assembly） ​ 链接（Linking） section2 Makefile概述 什么是makefile？ windows开发IDE为我们做了这部分的工作，而在Linux 端开发，必须要自己写makefile,会不会写makefile，从一个侧面说明了一个人是否具备完成大型工程的能力。会不会写makefile，从一个侧面说明了一个人是否具备完成大型工程的能力。","categories":[{"name":"服务端","slug":"服务端","permalink":"https://hxlpub.github.io/categories/%E6%9C%8D%E5%8A%A1%E7%AB%AF/"},{"name":"编译","slug":"服务端/编译","permalink":"https://hxlpub.github.io/categories/%E6%9C%8D%E5%8A%A1%E7%AB%AF/%E7%BC%96%E8%AF%91/"},{"name":"工具-Makefile-scons","slug":"服务端/编译/工具-Makefile-scons","permalink":"https://hxlpub.github.io/categories/%E6%9C%8D%E5%8A%A1%E7%AB%AF/%E7%BC%96%E8%AF%91/%E5%B7%A5%E5%85%B7-Makefile-scons/"}],"tags":[]},{"title":"cv","slug":"cv","date":"2021-09-14T09:26:07.000Z","updated":"2021-10-15T04:00:44.000Z","comments":true,"path":"2021/09/14/cv/","link":"","permalink":"https://hxlpub.github.io/2021/09/14/cv/","excerpt":"","text":"","categories":[{"name":"计算机视觉","slug":"计算机视觉","permalink":"https://hxlpub.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/"}],"tags":[]},{"title":"postgres数据库基本操作","slug":"database_pg","date":"2021-09-14T09:26:07.000Z","updated":"2022-01-12T06:04:22.000Z","comments":true,"path":"2021/09/14/database_pg/","link":"","permalink":"https://hxlpub.github.io/2021/09/14/database_pg/","excerpt":"","text":"1.pgadmin工具 2.增删改查 ​ 插入批量记录： ​ 1）生成insertDeviceChannels 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139create or replace function insertDeviceChannels(num_limit integer) returns booleanAS$$declare id integer default 1; devName varchar; channelName varchar; devIndexCode varchar; devIp varchar; devIpEnd1 integer default 1; devIpEnd2 integer default 1; devPort integer default 1001; devExternalCode varchar; channelExternalCode varchar; regionCount integer; regionResourceLimit integer; regionResourceNum integer default 0; regionIndexCode varchar; offsetNum integer default 0;begin select count(o.region_index_code) into regionCount from tb_region o where region_status = &#x27;0&#x27;; raise notice &#x27;regionCount %&#x27; , regionCount; if num_limit % regionCount = 0 then regionResourceLimit := num_limit / regionCount; end if; if num_limit % regionCount &gt; 0 then regionResourceLimit := num_limit / regionCount + 1; end if; while devIpEnd1 &lt;= 100 loop devIpEnd2 := 1; while devIpEnd2 &lt;= 100 loop devip := &#x27;10.33.&#x27; || devIpEnd1 || &#x27;.&#x27; || devIpEnd2; devPort := 1000; while devPort &lt;= 1099 loop devName := devip; devIndexCode := uuid_generate_v4(); if regionIndexCode is null then select region_index_code into regionIndexCode from tb_region where region_status = &#x27;0&#x27; limit 1 offset offsetNum; end if; INSERT INTO public.tb_device (dev_id, dev_index_code, dev_name, dev_addr, dev_port, dev_model, active_device_code, dev_username, dev_password, pwd_strength, dev_type, dev_serial_num, dis_order, dev_capability, manufacturer, treaty_type, driver, sync_iac, remote_status, region_index_code, domain_id, ezviz_user_id, ezviz_dev_code, dev_restype, business_class, description, version, is_cascade, extended_attribute, com_id, data_no, status, create_time, update_time, creator, modifier ) VALUES (uuid_generate_v4(), devIndexCode, devName, devIp, devPort, &#x27;Simulator&#x27;, null, &#x27;admin&#x27;, &#x27;Dg/I6if34PWRn093VjyPqg==&#x27;, 3, null, &#x27;SimulatorDevice&#x27;, 1, &#x27;&#123;&#125;&#x27;, &#x27;hikvision&#x27;, &#x27;hiksdk_net&#x27;, &#x27;drv_vss_hiksdk_general_1.13.100&#x27;, 0, 1, regionIndexCode, 0, null, null, &#x27;&#123;encodeDevice&#125;&#x27;, &#x27;vms_encodeDevice_model&#x27;, null, 0, 0, &#x27;&#123; &quot;zeroChanCount&quot;: &quot;0&quot;, &quot;analogIoInCount&quot;: &quot;0&quot;, &quot;analogIoOutCount&quot;: &quot;0&quot;, &quot;digitalIoInCount&quot;: &quot;0&quot;, &quot;dataCollectStatus&quot;: &quot;1&quot;, &quot;digitalIoOutCount&quot;: &quot;0&quot;, &quot;analogChannelCount&quot;: &quot;0&quot;, &quot;digitalChannelCount&quot;: &quot;1&quot; &#125;&#x27;, &#x27;sdmc&#x27;, 1, 0, now(), now(), &#x27;admin&#x27;, &#x27;admin&#x27; ); channelName := devName || &#x27;_1&#x27;; INSERT INTO public.tb_channel (channel_id, channel_index_code, channel_name, channel_num, channel_main_type, channel_sub_type, channel_capability, dev_index_code, region_index_code, description, com_id, ezviz_safe_watch_key, treaty_type, is_cascade, cascade_platform_code, dis_order, sync_iac, data_no, status, extended_attribute, business_class, create_time, update_time, channel_restype, creator, modifier) VALUES (uuid_generate_v4(), uuid_generate_v4(), channelName, &#x27;1&#x27;, &#x27;camera&#x27;, &#x27;digital&#x27;, &#x27;&#123;&#125;&#x27;, devIndexCode, regionIndexCode, null, &#x27;sdmc&#x27;, null, null, &#x27;0&#x27;, &#x27;0&#x27;, id, null, id, 0, &#x27;&#123; &quot;osdStatus&quot;: &quot;0&quot; &#125;&#x27;, &#x27;vss_encodeDevice_camera&#x27;, now(), now(), &#x27;&#123;camera&#125;&#x27;, &#x27;admin&#x27;, &#x27;admin&#x27;); devPort := devPort + 1; regionResourceNum := regionResourceNum + 1; if regionResourceNum = regionResourceLimit then offsetNum := offsetNum + 1; regionIndexCode := null; regionResourceNum := 0; end if; if id = num_limit then return null; end if; id := id + 1; end loop; devIpEnd2 := devIpEnd2 + 1; end loop; devIpEnd1 := devIpEnd1 + 1; end loop; return null;end$$ LANGUAGE plpgsql; 2）插入10w记录 1select insertDeviceChannels(100000); 3)删除指定记录 1delete from tb_device where region_index_code = &#x27;219f98dd-a83a-468f-a2c0-3a30cd2e6082&#x27;;","categories":[{"name":"数据库","slug":"数据库","permalink":"https://hxlpub.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"postgres","slug":"数据库/postgres","permalink":"https://hxlpub.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/postgres/"}],"tags":[]},{"title":"PostgreSQL","slug":"database_redis","date":"2021-09-14T09:26:07.000Z","updated":"2021-10-14T10:05:50.000Z","comments":true,"path":"2021/09/14/database_redis/","link":"","permalink":"https://hxlpub.github.io/2021/09/14/database_redis/","excerpt":"","text":"","categories":[{"name":"数据库","slug":"数据库","permalink":"https://hxlpub.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"PostgreSQL","slug":"数据库/PostgreSQL","permalink":"https://hxlpub.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/PostgreSQL/"}],"tags":[]},{"title":"学习思路","slug":"deep-learning","date":"2021-09-14T09:26:07.000Z","updated":"2021-10-10T04:53:04.000Z","comments":true,"path":"2021/09/14/deep-learning/","link":"","permalink":"https://hxlpub.github.io/2021/09/14/deep-learning/","excerpt":"","text":"","categories":[{"name":"深度学习","slug":"深度学习","permalink":"https://hxlpub.github.io/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"},{"name":"入门","slug":"深度学习/入门","permalink":"https://hxlpub.github.io/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E5%85%A5%E9%97%A8/"},{"name":"学习思路","slug":"深度学习/入门/学习思路","permalink":"https://hxlpub.github.io/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E5%85%A5%E9%97%A8/%E5%AD%A6%E4%B9%A0%E6%80%9D%E8%B7%AF/"}],"tags":[]},{"title":"工具使用","slug":"git_tools","date":"2021-09-14T09:26:07.000Z","updated":"2021-10-20T12:49:30.000Z","comments":true,"path":"2021/09/14/git_tools/","link":"","permalink":"https://hxlpub.github.io/2021/09/14/git_tools/","excerpt":"","text":"1.把github上面的仓库克隆到本地 1git clone 仓库 2.上传本地的项目到github仓库 1234567git add * #可将当前目录下文件添加到暂存区git add [file1] [file2] ...#添加一个或多个文件到暂存区git add [dir]#添加指定目录到暂存区，包括子目录git add .#添加当前目录下的所有文件到暂存区git commit -m &quot;提交信息&quot; （注：“提交信息”里面换成你需要，如“first commit”）git push -u origin master （注：此操作目的是把本地仓库push到github上面，此步骤需要你输入帐号和密码，这里的账号和密码是你的github的账号和密码，你第一次上传的话可能会需要你输密码）","categories":[{"name":"开发工具","slug":"开发工具","permalink":"https://hxlpub.github.io/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"},{"name":"版本管理","slug":"开发工具/版本管理","permalink":"https://hxlpub.github.io/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86/"},{"name":"git","slug":"开发工具/版本管理/git","permalink":"https://hxlpub.github.io/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86/git/"}],"tags":[]},{"title":"实现从Linux服务器获取windows文件","slug":"linux","date":"2021-09-14T09:26:07.000Z","updated":"2021-10-29T03:36:18.000Z","comments":true,"path":"2021/09/14/linux/","link":"","permalink":"https://hxlpub.github.io/2021/09/14/linux/","excerpt":"","text":"问题描述​ 工作中需要从Linux服务器端去拿windows端的文件，linux服务器之间底层互传文件可以用scp很容易实现，但是 不同的操作系统之间实现文件传输,如，windows 和linux之间，又如何实现呢？ 子问题1 描述：ftp ip 需要手动输入win ftpserver所在的win用户名密码后才可以执行抓取等操作，怎么能跳过手动的验证？ 12345678910[root@localhost AuthServer]# ftp 10.192.44.183Connected to 10.192.44.183 (10.192.44.183).220 Microsoft FTP ServiceName (10.192.44.183:root): linhongxun331 Password requiredPassword:230 User logged in.Remote system type is Windows_NT.ftp&gt; 解决方案： 1234567891011121314#!/bin/shftp -n &lt;&lt;- EOF#win 端IPopen ip#win 端用户名密码user username password#传输格式ascii(or bin)#操作put *(or get)#退出byeEOF 子问题2： 解决方案 ftp：需要在windows端搭建ftpserver服务，在linux端安装ftp工具 scp 工作中使用了ftp的方案，本文着重讲解ftp实现从Linux服务器获取windows文件 实现windows 端搭建ftpserver​ 问一下度娘，很简单，在这不耽误时间，推荐 Linux 端安装ftp工具 rpm包方式安装 yum 安装 yum list |grep ftp #查看可安装版本ftp yum install ftp… ftp实现抓取windows端的文件到指定路径​ example:实现将win端的路径下文件cp 到linux端同一路径下：downloadjson.sh 1234567891011121314151617#!/bin/sh# $1 是第一个参数，即路径，执行的脚本为: ./downloadjson.sh /nas/test/test/DocumentVoucher.jsonparam1=`echo $1 |awk -F &quot;DocumentVoucher&quot; &#x27;&#123;printf $1&#125;&#x27;`#echo $&#123;param1&#125;ftp -n &lt;&lt;- EOFopen ftpserveripuser username passwordasciicd $&#123;param1&#125;get DocumentVoucher.jsonbyeEOFmkdir -p $&#123;param1&#125;cp DocumentVoucher.json $&#123;param1&#125; go语言执行脚本​ 项目中，上层应用是http 协议，目的是请求到含有文件路径报文的同时，将文件下载到Linux服务器端，故在http协议绑定的接口函数里面实现了执行该脚本,逻辑如下 123456789command := &quot;./downloadjson.sh &quot; + documentPathfmt.Println(command)cmd := exec.Command(&quot;/bin/sh&quot;, &quot;-c&quot;, command)bytes, err := cmd.Output()if err != nil &#123; fmt.Println(err) &#125;resp := string(bytes) fmt.Println(resp) 常见问题FAQ ​ ftp ip 时连接超时 1234[root@localhost AuthServer]# ftp 10.192.44.183ftp: connect: Connection timed outftp&gt; 解决方案：关闭win端的防火墙 ftp常用指令 连接ftp服务器 格式： 1ftp [hostname| ip-address] a)在linux命令行下输入： 1ftp 192.168.26.66 b)服务器询问你用户名和口令，分别输入用户名和相应密码，待认证通过即可。 2. 下载文件 下载文件通常用get和mget这两条命令。 a) get 格式： 1get [remote-file] [local-file] 将文件从远端主机中传送至本地主机中. 如要获取服务器上e:\\rose\\1.bmp,则 1ftp&gt; get /rose/1.bmp 1.bmp (回车) b) mget 格式： 1mget [remote-files] 从远端主机接收一批文件至本地主机. 如要获取服务器上e:\\rose\\下的所有文件,则 12ftp&gt; cd /roseftp&gt; mget *.* (回车) 注意：文件都下载到了linux主机的当前目录下。比如，在 /root/yint下运行的ftp命令，则文件都下载到了/root/yint 下。 3.上传文件 a) put 1格式：put local-file [remote-file] 将本地一个文件传送至远端主机中. 如要把本地的1.bmp传送到远端主机e:\\rose,并改名为333.bmp 1 ftp&gt; put 1.bmp /rose/333.bmp (回车) b) mput 1格式：mput local-files 将本地主机中一批文件传送至远端主机. 如要把本地当前目录下所有bmp文件上传到服务器e:\\rose 下 12ftp&gt; cd /rose （回车）ftp&gt; mput *.bmp （回车） 注意：上传文件都来自于主机的当前目录下。比如，在 /root/test下运行的ftp命令，则只有在/root/test下的文件linux才会 上传到服务器e:\\rose 下。 4. 断开连接 bye：中断与服务器的连接。 1 ftp&gt; bye (回车) scp常用​ scp是安全的文件拷贝，基于ssh的登录 ​ 假定你想把本地计算机/home下的一个名为a.tar.tz的文件拷贝到远程服务器192.168.0.2上的/home/tmp。而且你在远程服务器 上的帐号名为root。可以用这个命令： 1scp /home/a.tar.tz root@192.168.0.2:/home/tmp/ ​ 如果把文件从远程机器拷贝到本机当前目录用这个命令： 1scp root@192.168.0.2:/home/a.tar.tz ​ 拷贝远程机器的整个目录下的文件 1scp -r root@192.168.0.2：/home/* ./","categories":[{"name":"服务端","slug":"服务端","permalink":"https://hxlpub.github.io/categories/%E6%9C%8D%E5%8A%A1%E7%AB%AF/"},{"name":"Linux","slug":"服务端/Linux","permalink":"https://hxlpub.github.io/categories/%E6%9C%8D%E5%8A%A1%E7%AB%AF/Linux/"},{"name":"文件传输","slug":"服务端/Linux/文件传输","permalink":"https://hxlpub.github.io/categories/%E6%9C%8D%E5%8A%A1%E7%AB%AF/Linux/%E6%96%87%E4%BB%B6%E4%BC%A0%E8%BE%93/"}],"tags":[]},{"title":"内核kernel|","slug":"linux_kernel","date":"2021-09-14T09:26:07.000Z","updated":"2021-11-06T06:29:30.000Z","comments":true,"path":"2021/09/14/linux_kernel/","link":"","permalink":"https://hxlpub.github.io/2021/09/14/linux_kernel/","excerpt":"","text":"","categories":[{"name":"服务端","slug":"服务端","permalink":"https://hxlpub.github.io/categories/%E6%9C%8D%E5%8A%A1%E7%AB%AF/"},{"name":"Linux","slug":"服务端/Linux","permalink":"https://hxlpub.github.io/categories/%E6%9C%8D%E5%8A%A1%E7%AB%AF/Linux/"},{"name":"内核kernel","slug":"服务端/Linux/内核kernel","permalink":"https://hxlpub.github.io/categories/%E6%9C%8D%E5%8A%A1%E7%AB%AF/Linux/%E5%86%85%E6%A0%B8kernel/"}],"tags":[]},{"title":"Linux工具","slug":"linux_command_tools","date":"2021-09-14T09:26:07.000Z","updated":"2022-02-22T07:17:17.731Z","comments":true,"path":"2021/09/14/linux_command_tools/","link":"","permalink":"https://hxlpub.github.io/2021/09/14/linux_command_tools/","excerpt":"","text":"目录文件管理目录管理​ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748491.列出目录文件名 ls/ll 1、ls -al ~:将家目录下的所有文件列出来（含属性与隐藏文件） 2、ls -alF --color=never:不显示颜色，文件名末尾显示文件名代表的类型 3、ls -al --full-time ~ ：完整呈现文件的修改时间 权限说明drwxr-xr-x 2 root root 4096 Jul 20 2017 Documents第一栏drwxr-xr-x:类型与权限 第一个字符表示文件是目录或文件或链接等等 [d]:目录 [-]:文件 [l]:链接 [b]:装置文件里可供存储的接口设备（可随机存取装置） [c]:装置文件里串行端口设备，如键盘鼠标（一次性读取装 置） 剩余字符以三个为一组：均为rwx三个参数组合 r可读：4 w可写:2 x可执行:1 没有权限则-:0 drwxr-xr-x: rwx=4+2+1=7 r-x:4+0+1=5 r-x:4+0+1=5 则该文件的权限数字是755 第一组：文件拥有者权限 第二组：加入此群组账号的权限 第三组：非本人且未加入本群组的其他账号的权限 第二栏 表示有多少档名连接到此节点（i_node） 第三栏 表示文件或者目录的拥有者账号 第四栏 表示文件所属群组 第五栏 表示文件容量大小，默认单位bytes 第六栏 表示文件的件当日期或最近修改日期 第七栏 表示文档的名字2.切换目录 cd 1、cd /usr/bin: 绝对路径，以根目录/开头 2、cd bin:在usr下，相对路径，相对于当前目录 3、cd ～：切换到目前用户所在家目录 4、cd . :目前所在目录 5、cd .. :切换至目前目录的上一层目录 6、cd ../.. :切换至上上层目录 7、cd ~account :切换到目前用户account所在家目录/home/account 8、cd ../dir:切换到与本目录并列的另一个目录 9、cd -:回到之前的目录3.显示当前目录 pwd4.创建一个新目录 mkdir5.删除一个空目录 rmdir 传输文件1234567891011121314151.wget 从URL获取文件 wget URL #下载URL指定的文件 ex: wget www.baidu.com #下载百度网页 wget -O filename URL #从URL获取文件并重命名filename,filename包含路径 ex：wget http://mirrors.hikvision.com.cn/help/centos/7/CentOS-Base.repo -O /etc/yum.repos.d/CenOS-Base.repo #配置hik yum源 wget -o log URL#注意o与O区别，o为写日志log（怎么获取文件的过程，包括解析、建立连接、传文件等），O为文件名2.ftp 子主题 1 子主题 23.scp 用于 Linux 之间复制文件和目录 scp [可选参数] file_source file_target 1、scp /home/space/music/1.mp3 IP:/home/root/others/music （本地到远程） 2、scp -P 55555 IP:/usr/local/sin.sh /home/administrator（远程到本地） 创建文件、文件链接12341.touch filename#从无到有创建文件2.cp file file.bak #备份3.ln -sf /dev/dm-30 /dev/cvr_vg/lun1 (ln -sf 目的地 链接) 删除文件​ 1rm -rf filename #r：递归，f：强制删除，不提示 更改文件12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455561.重命名​ mv filename newfilename#将文件filename重命名为newfilename2.更改文件属性​ chattr​ 语法​ chattr [-RV][-v&lt;版本编号&gt;][+/-/=&lt;属性&gt;][文件或目录...]​ 参数​ -R 递归处理，将指定目录下的所有文件及子目录一并处理。 -v&lt;版本编号&gt; 设置文件或目录版本。 -V 显示指令执行过程。 +&lt;属性&gt; 开启文件或目录的该项属性。 -&lt;属性&gt; 关闭文件或目录的该项属性。 =&lt;属性&gt; 指定文件或目录的该项属性。 属性 a：让文件或目录仅供附加用途。 b：不更新文件或目录的最后存取时间。 c：将文件或目录压缩后存放。 d：将文件或目录排除在倾倒操作之外。 i：不得任意更动文件或目录。 s：保密性删除文件或目录。 S：即时更新文件或目录。 u：预防意外删除。 示例 chattr +i /etc/resolv.conf#用chattr命令防止系统中某个关键文件被修改 chattr +a /var/log/messages#让某个文件只能往里面追加数据，但不能删除，适用于各种日志文件3.更改文件权限 chmod 格式 chmod [-cfvR] [--help] [--version] mode file... 参数 mode : 权限设定字串 [ugoa...][[+-=][rwxX]...][,...]#格式 其中： u 表示该文件的拥有者，g 表示与该文件的拥有者属于同一个群体(group)者，o 表示其他以外的人，a 表示这三者皆是。 + 表示增加权限、- 表示取消权限、= 表示唯一设定权限。 r 表示可读取，w 表示可写入，x 表示可执行，X 表示只有当该文件是个子目录或者该文件已经被设定过为可执行。 其他参数说明： -c : 若该文件权限确实已经更改，才显示其更改动作 -f : 若该文件权限无法被更改也不要显示错误讯息 -v : 显示权限变更的详细资料 -R : 对目前目录下的所有文件与子目录进行相同的权限变更(即以递归的方式逐个变更) --help : 显示辅助说明 --version : 显示版本 示例 chmod ugo+r file1.txt#将文件 file1.txt 设为所有人皆可读取 chmod ug+w,o-w file1.txt file2.txt#将文件 file1.txt 与 file2.txt 设为该文件拥有者，与其所属同一个群体者可写入，但其他以外的人则不可写入 chmod -R a+r *#将目前目录下的所有文件与子目录皆设为任何人可读取 chmod a=rwx file == chmod 777 file 查看文件1234567891011121314151617181920212223242526272829301.cat 从头到尾显示文件内容 cat 文件 #从头到尾显示整个文件内容，当文件很大时，终端无法完全显示其所有内容 cat -n 文件 #查看文件内容的同时添加行号 三大功能 1.cat 文件 #一次显示整个文件 2.cat &gt; 文件 #从键盘创建一个文件,只能创建新文件，不能编辑已有文件，执行命令后会进入文件编辑，每次都会覆盖旧的内容 3.cat file1 file2 &gt; file#将几个文件合并为一个文件 2.more 分屏显示文件 more 文件 #分屏显示文件内容，空格：向下翻页，b：向上翻页，q：退出3.less 分屏显示文件，同more4.head 从头开始查看文件内容 head 文件 #显示文件头部，默认10行 head -n 行数 文件#查看文件的前10行5.tail 与head相反6.file 观察文件类型,某个文件的基本数据 file file 文件类型诸如,ASCII，data文件，binary文件等 file file7.查看文件格式:set ff #进入到文件，vi/vim 文件后执行:set ff 搜索文件​ 1234567891011121314151617181920212223241.find find path -option ... find . -type f#将当前目录及其子目录中的所有文件列出 find . -name &quot;*.c&quot;#将当前目录及其子目录下所有文件后缀为 .c 的文件列出来 常用：find / -name filename2.which 寻找执行档 which command -a :将所有由PATH目录中可以找到的指令均列出，而不止第一份被找到的指令名称 1、which ifconfig :找出ifconfig命令的执行文件位置3.whereis 文件档名的查找，由一些特定的目录中 寻找文件文件名 whereis [-bmsu] 文件或目录名 -l：列出whereis 会去查询的几个主要目录而已 -b:只找binary文件 -m:只找在说明文件manual路径下的文件 -s:只找source 来源文件 -u:搜寻不在上述三个项目 中的其他特殊文件 1、whereis ifconfig4.根据文件中字符串搜索文件 grep -rn &quot;字符串&quot; 比较文件​ 121.diff diff 选项 文件一 文件二 分割文件1234split 命令用于将一个文件分割成数个 -b:指定每多少字节切成一个小文件 1、split -b 1024m txst.txt -d -a 2 test.txt_ 编辑文件vim ​ 常用快捷方式： ​ 输入输出1231.&gt;&gt; 输出重定向 example: vmstat 3 &gt;&gt; test#vmstat输出重定向到文件test 系统管理1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798991001011021031041051061071081091101111121131141151161171.top 实时显示 process 的动态 top [-d 数字] |top [-bnp] -d:后接秒数，更新的秒数 -b:以批次的方式执行 -n:与-b搭配表示需要进行几次top的输出结果 -p 指定某些个PID观察 1、top -d 2 说明: 第一行：目前的时间，经过的时间，登录用户数，在1,5,15分钟的平均负载 第二行：显示目前进程总数和个别进程状态 第三行： 显示CPU的整体负载 第四行第五行：物理内存和虚拟内存使用情况（虚拟内存来源？？) 第六：输入指令时显示状态的地方 2、top -b -n 2 &gt;/tmp/top.txt#2次输出结果到文件 3、top -d 2 -p PID #持续观察该PID2.ps 显示某个时间点的进程运作情况 ps [options] -A:显示所有process,同-e -a:不与terminal相关的process -u：有效使用者相关的pro x:通常与a一起用列出较完整信息 l :详细讲该PID信息列出 j:工作的格式 -f：更完整的输出 1、ps -l 仅仅观察自己bash相关的进程 说明： F：进程旗标，总结权限，常见号码4:表示进程权限root 1:表示仅复制而没有实际执行 S：表示状态 R：运行中 S：睡眠 D：不可唤醒，可能在等待IO的情况 T：停止 Z:僵尸状态，已经终止但无法移除到内存外 UID/PID/PPID:代表此进程被该UID所拥有，进程的PID号码，此进程的PID号码 C：Cpu 使用率 PRI/NI :priority/nice优先级，越小越优先 ADDR/SZ/WCHAN：内存相关,内存部分，用掉多少内存，是否在运作 TTY：终端机位置，远程则pts/n TIME:使用掉的CPU时间 CMD：造成此进程的程序的指令 2、ps aux#观察系统所有进程 USR;使用者账号 MEM：物理内存占比 VSZ：耗掉的虚拟内存 RSS：占用的固定内存3、ps -lA#显示所有进程 4.free 用于显示内存状态5.查看cpu cat /proc/cpuinfo6.查看内核uname -r7.查看系统cat /etc/redhat-release （redhat）8.进程管理 Kill -s 9 进程号#杀掉进程9.查看目录占用者并解除占用 stat /root/hu10.systemctl 一、systemd 系统初始化程序，系统开始的第一个进程，pid为1 二、systemctl命令 systemctl list-units ##列出当前系统服务的状态 systemctl list-unit-files ##列出服务的开机状态 systemctl status sshd ##查看指定服务的状态 systemctl stop sshd ##关闭指定服务 systemctl start sshd ##开启指定服务 systemctl restart sshd ##从新启动服务 systemctl enable sshd ##设定指定服务开机开启 systemctl disable sshd ##设定指定服务开机关闭 systemctl reload sshd ##使指定服务从新加载配置 systemctl list-dependencies sshd ##查看指定服务的倚赖关系 systemctl mask sshd ##冻结指定服务 systemctl unmask sshd ##启用服务 systemctl set-default multi-user.target ##开机不开启图形 systemctl set-default graphical.target ##开机启动图形 setterm ##文本界面设定color 三、服务状态 systemctl status 服务名称 loaded ##系统服务已经初始化完成，加载过配置 active（running） ##正有一个或多个程序正在系统中执行， vsftpd就是这种模式 atcive（exited） ##僅執行一次就正常結束的服務， 目前並沒有任何程序在系統中執行 atcive（waiting） ##正在執行當中，不過還再等待其他的事件才能继续处理 inactive ##服务关闭 enbaled ##服务开机启动 disabled ##服务开机不自启 static ##服务开机启动项不可被管理 failed ##系统配置错误 11.pstree查看Linux下systemd启动了哪些服务 pstree [options]-a #包含命令行参数-c #展开相同的子树-H [PID] #突出特定过程-g #显示进程组ID-n #使用PID排序pstree 用户 #显示特定用户的进程树-s [PID ] #限制显示一个特定的过程12.查看内存型号dmidecode -t memory13. 排名前10的内存CPU消耗ps auxw|head -1;ps auxw|sort -rn -k3|head -1014.释放内存如果内存太少， 可以把占用内存多的程序停掉， 然后执行这个命令释放： echo 3 &gt;/proc/sys/vm/drop_caches 释放完后再改回去： echo 1 &gt;/proc/sys/vm/drop_caches 系统设置123子主题 1子主题 2子主题 3 磁盘、设备管理1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162631.df 列出文件系统的整体磁盘使用量 df [-ahikHTm][目录或文件名] -a:列出所有文件系统，包括系统特有的/proc等文件系统 -k:以KBytes的容量显示文件系统 -m:以MBytes的容量显示文件系统 -h：以人们交易阅读的的GB、MB、KB等格式自行显示 -H：以M=1000K取代M=1024K 的进位方式 -T：连同该partition的filesystem名称列出 -i:不用磁盘容量而以inode数量表示 1、df:列出系统内所有filesystem列出来 filesystem:表示文件系统是哪个partition 1k-blocks:表示单位1KB，可用-h或-m改变容量 Used:使用掉的磁盘空间 Available:剩下的磁盘空间 Use%:磁盘的使用率 Mounted on :磁盘挂载的目录（挂载点） 2、df -h:易读显示 3、df -aT:将系统内所有特殊文件格式以及名称列出来 4、df -h /etc：将/etc下可用的磁盘以易读的容量格式显示出来 5、df -ih：将目前的各个partition当中可用的inode数量列出2.lsblklist block device观察磁盘分区状态lsblk [-dfimpt] device-d:仅列出磁盘本身,无分区-f:含文件系统名称-i：使用ASCII的线段输出-m：输出权限数据-p:列出完整文件名 -t:列出详细数据。包括磁盘队列机制与读写的数据量大小1、lsblk -ip /dev/sdb3.blkid对系统的块设备（包括交换分区）所使用的文件系统类型、LABEL、UUID等信息进行查询4.挂载镜像 1、sudo losetup /dev/loop0 iVMS-HG-H16_CN_STD_9.2.0_V2.3.8_iSC_V1.5.100_201026_platformactive_base.img 2、 kpartx -av /dev/loop0 3、 kpartx -d /dev/loop0 4、losetup -d /dev/loop05.调整分区fdisk 1.fdisk /dev/hda p：打印分区 d：删除分区 n:新增分区 2.格式化分区 mkfs.ext4 /dev/.. 3.挂载分区 mount /dev/... 挂载点6.激活网卡 ifup eth0 磁盘维护1234567891011121314151.dd 备份(直接读取扇区sector)制作文件 dd if=&quot;input_file&quot; of=&quot;output_file&quot; bs=&quot;blocksize&quot; count=blocknum if：输入文件名，默认为标准输入。即指定源文件或设备。 of：输出文件名，默认为标准输出。即指定目的文件或设备。 count：多少的bs bs：一个block大小 1、dd if=/etc/passwd of=/etc/passwd.back #备份文件 2、dd if=/dev/sdb of=/tmp/system.iso#将光驱内容备份下来 3、dd if=/tmp/system.iso of=/dev/sdb#将镜像备份到设备 4、将/boot整个文件系统透过dd备份下来 df -h /boot#获取设备/dev/... dd if=/dev/… of=/tmp/….img 子主题 2子主题 3 网络通讯、系统性能1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798991001011021031041051061071081091101111121131141151161171181191201211221231241251261271281291301311321331341351361371381391401411.iostat I/O statistics（输入/输出统计）输出CPU和磁盘I/O相关的统计信息监控系统的IO状态 iostat [ options ] [ &lt;interval&gt; [ &lt;count&gt; ] ]-c：查看CPU部分状态信息-k:某些使用block为单位的列强制使用Kilobytes为单位-d 参数，显示设备（磁盘）使用状态-x 参数，输出更多详细信息1、iostat -c2、iostat -k 1 103、iostat -d 1 34、iostat -x 1 2说明：磁盘属性tps：该设备每秒的传输次数“一次传输”意思是“一次I/O请求”。多个逻辑请求可能会被合并为“一次I/O请求”。“一次传输”请求的大小是未知的。kB_read/s：每秒从设备（drive expressed）读取的数据量；kB_wrtn/s：每秒向设备（drive expressed）写入的数据量；kB_read：读取的总数据量；kB_wrtn：写入的总数量数据量；这些单位都为Kilobytes。CPU属性%user cpu处在用户模式下的时间百分比%nice cpu处在带NICE值的用户模式下的时间百分比%system cpu处在系统模式下的时间百分比%iowait cpu等待输入输出完成时间的百分比%steal 管理程序维护另一个虚拟处理器时，虚拟CPU的无意识等待时间百分比%idle cpu空闲时间百分比注意:如果%iowait的值过高，表示硬盘存在I/O瓶颈，%idle值高，表示CPU较空闲，如果%idle值高但系统响应慢时，有可能是CPU等待分配内存，此时应加大内存容量。%idle值如果持续低于10，那么系统的CPU处理能力相对较低，表明系统中最需要解决的资源是CPU。2.ifstat网络接口监测工具ifstat options-l 监测环路网络接口。缺省情况下ifstat监测活动的所有非环路网络接口-a 监测能检测到的所有网络接口的状态信息。-z 隐藏流量是无的接口，如接口启动了但是未使用的。-i &lt;interface&gt; 指定要监测的接口。-s 通过SNMP查询一个远程主机。-h 显示帮助信息-n 关闭周期性显示头部信息。-t 在每一行的开头加一个时间戳-T 报告所有检测接口的全部带宽-w 指定间隔时间（与官方的文档说明并不同，不知道是不是写文档的人写错，反正我测试后是间隔时间）-W 如果显示内容超出终端窗口的宽度，就换行-S 在同一行更新显示内容 -b 用kbits/s显示带宽-q 按键模式-v 显示版本信息-d 指定一个驱动来收集状态信息 3.netstatNetstat是控制台命令,是一个监控TCP/IP网络的非常有用的工具，它可以显示路由表、实际的网络连接以及每一个网络接口设备的状态信息。Netstat用于显示与IP、TCP、UDP和ICMP协议相关的统计数据，一般用于检验本机各端口的网络连接情况。netstat options-a (all) 显示所有选项，默认不显示LISTEN相关。-t (tcp) 仅显示tcp相关选项。-u (udp) 仅显示udp相关选项。-n 拒绝显示别名，能显示数字的全部转化成数字。-l 仅列出有在 Listen (监听) 的服务状态。-p 显示建立相关链接的程序名-r 显示路由信息，路由表-e 显示扩展信息，例如uid等-s 按各个协议进行统计-c 每隔一个固定时间，执行该netstat命令。LISTEN和LISTENING的状态只有用-a或者-l才能看到。1、列出所有端口 #netstat -a2、列出所有 tcp 端口 #netstat -at3、列出所有 udp 端口 #netstat -au4、只显示监听端口 #netstat -l5、只列出所有监听 tcp 端口 #netstat -lt6、只列出所有监听 udp 端口 #netstat -lu7、列出所有监听 UNIX 端口 #netstat -lx8、显示所有端口的统计信息 #netstat -s9、显示 TCP 或 UDP 端口的统计信息 #netstat -st 或 -su10、 输出中显示 PID 和进程名称 #netstat -p4.vmstat展现给定时间间隔的服务器的状态值,包括服务器的CPU使用率，内存使用，虚拟内存交换情况,IO读写情况 vmstat [options] [delay [count]]参数说明Procs（进程） r等待执行的任务数展示了正在执行和等待cpu资源的任务个数当这个值超过了cpu个数，就会出现cpu瓶颈。B等待IO的进程数量Memory(内存)swpd正在使用虚拟的内存大小，单位kfree空闲内存大小buff已用的buff大小，对块设备的读写进行缓冲cache已用的cache大小，文件系统的cacheinact非活跃内存大小，即被标明可回收的内存，区别于free和active active活跃的内存大小Swapsi每秒从交换区写入内存的大小（单位：kb/s）so每秒从内存写到交换区的大小IObi每秒读取的块数（读磁盘） 块设备每秒接收的块数量，单位是block，这里的块设备是指系统上所有的磁盘和其他块设备，现在的Linux版本块的大小为1024bytesbo每秒写入的块数（写磁盘）块设备每秒发送的块数量，单位是block system in ：中断数cs:每秒上下文切换数CPUus用户进程执行消耗cpu时间(user time) us的值比较高时，说明用户进程消耗的cpu时间多，但是如果长期超过50%的使用，那么我们就该考虑优化程序算法或其他措施了sy系统进程消耗cpu时间(system time)sys的值过高时，说明系统内核消耗的cpu资源多，这个不是良性的表现，我们应该检查原因。这里us + sy的参考值为80%，如果us+sy 大于 80%说明可能存在CPU不足Id空闲时间(包括IO等待时间) 一般来说 us+sy+id=100wa等待IO时间wa过高时，说明io等待比较严重，这可能是由于磁盘大量随机访问造成的，也有可能是磁盘的带宽出现瓶颈。5.tcpdump 虚拟机内抓一下网卡上某个ip的流量 tcpdump -i ens3 |grep 10.192.54.2206.ethtool 查看网卡信息 ethtool eth0 备份压缩12345678910111213141516171819202122232425262728293031321.zip zip -r myfile.zip ./* unzip -o -d /home/sunny myfile.zip #解压myfile.zip 到/home/sunny2.tar 用于备份文件、压缩、解压 -c：建立打包文件，可搭配-v查看过程中被打包的文件名 -t:查看打包文件的内容含有哪些档名，重点在查看档名就是了 -x:解打包或解压缩的功能，可以搭配-C在特定的目录解开，特别留意的是-c,-t，-x不可同时出现在一串指令中 -z：透过gzip的支持进行压缩解压缩，文件最好是*.tar.gz -j：透过bzip2的支持进行压缩解压缩，文件最好是*.tar.bz2 -J：透过xz的支持进行压缩解压缩，文件最好是*.tar.xz -v:在压缩解压缩的过程中，将正在处理的文件名显示出来 -f filename：-f 后面要立刻接要被处理的文档名 -C目录：这个选项用在解压缩，若要在特定目录解压缩，可以使用这个选项 -p：保留备份数据的原本权限与属性，常用于备份-c重要的配置文件 -P：保留绝对路径，即允许备份数据中含有根目录存在 --exclude=FILE：在压缩过程中，不要将FILE 打包 1、# tar -czvf test.tar.gz a.c //压缩（compress） a.c文件为test.tar.gz 2、tar -tzvf test.tar.gz （列出压缩文件内容）(list) 3、tar -xzvf test.tar.gz（解压）(extract) 4、tar -zpcv -f /root/etc.tar.gz /etc#备份/etc（先su -切换到root） tar -jpcv -f /root/etc.tar.bz2 /etc tar -Jpcv -f /root/etc.tar.xz /etc3.xz创建tar.xz文件：只要先 tar cvf xxx.tar xxx/ 这样创建xxx.tar文件先，然后使用 xz -z xxx.tar 来将 xxx.tar压缩成为 xxx.tar.xz解压tar.xz文件：先 xz -d xxx.tar.xz 将 xxx.tar.xz解压成 xxx.tar 然后，再用 tar xvf xxx.tar来解包。4.子主题 4 软件维护 Ubuntu 12345678910111213更新软件源 1.更改源sudo vim /etc/apt/sources.list 2.sudo apt-get update安装软件 3.sudo apt-get install 软件 Centos 1234567891011121314151617181920212223242526271.更改yum源wget 官方源/aliyun 等 -O /etc/yum.repos.d/CenOS-Base.repoyum clean all &amp;&amp; yum makecache #生成缓存2.安装EPEL 源EPEL (Extra Packages for Enterprise Linux)是基于Fedora的一个项目，为“红帽系”的操作系统提供额外的软件包，适用于RHEL、CentOS和Scientific Linux.我们在Centos下使用yum安装时往往找不到rpm的情况，官方的rpm repository提供的rpm包也不够丰富，很多时候需要自己编译很痛苦，而EPEL恰恰可以解决这两方面的问题。EPEL的全称叫 Extra Packages for Enterprise Linux 。EPEL是由 Fedora 社区打造，为 RHEL 及衍生发行版如 CentOS、Scientific Linux 等提供高质量软件包的项目。装上了 EPEL之后，就相当于添加了一个第三方源。————————————————版权声明：本文为CSDN博主「不忘初心fight」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。原文链接：https://blog.csdn.net/weixin_41831919/article/details/1090359361）yum install -y epel-release [root@192 daos]# ll /etc/yum.repos.d/total 52-rw-r--r--. 1 root root 1664 Oct 23 2020 CentOS-Base.repo-rw-r--r--. 1 root root 2523 Dec 26 2020 CentOS-Base.repo.aliyun-rw-r--r--. 1 root root 1309 Nov 23 2020 CentOS-CR.repo-rw-r--r--. 1 root root 649 Nov 23 2020 CentOS-Debuginfo.repo-rw-r--r--. 1 root root 314 Nov 23 2020 CentOS-fasttrack.repo-rw-r--r--. 1 root root 630 Nov 23 2020 CentOS-Media.repo-rw-r--r--. 1 root root 1331 Nov 23 2020 CentOS-Sources.repo-rw-r--r--. 1 root root 8515 Nov 23 2020 CentOS-Vault.repo-rw-r--r--. 1 root root 616 Nov 23 2020 CentOS-x86_64-kernel.repo-rw-r--r--. 1 root root 951 Oct 2 2017 epel.repo-rw-r--r--. 1 root root 1050 Oct 2 2017 epel-testing.repo2）yum repolist3) yum clean all &amp;&amp; yum makecache 其他 11.set -e # shell文件开头加上set -e,这句语句告诉bash如果任何语句的执行结果不是true则应该退出 自定义安装软件环境变量设置 1 Linux环境变量配置方法一：export PATH使用export命令直接修改PATH的值，配置MySQL进入环境变量的方法: 1234export PATH=/home/uusama/mysql/bin:$PATH# 或者把PATH放在前面export PATH=$PATH:/home/uusama/mysql/bin 注意事项： 生效时间：立即生效 生效期限：当前终端有效，窗口关闭后无效 生效范围：仅对当前用户有效 配置的环境变量中不要忘了加上原来的配置，即$PATH部分，避免覆盖原来配置 Linux环境变量配置方法二：vim ~/.bashrc通过修改用户目录下的~/.bashrc文件进行配置： 1234vim ~/.bashrc# 在最后一行加上export PATH=$PATH:/home/uusama/mysql/bin 注意事项： 生效时间：使用相同的用户打开新的终端时生效，或者手动source ~/.bashrc生效 生效期限：永久有效 生效范围：仅对当前用户有效 如果有后续的环境变量加载文件覆盖了PATH定义，则可能不生效 Linux环境变量配置方法三：vim ~/.bash_profile和修改~/.bashrc文件类似，也是要在文件最后加上新的路径即可： 1234vim ~/.bash_profile# 在最后一行加上export PATH=$PATH:/home/uusama/mysql/bin 注意事项： 生效时间：使用相同的用户打开新的终端时生效，或者手动source ~/.bash_profile生效 生效期限：永久有效 生效范围：仅对当前用户有效 如果没有~/.bash_profile文件，则可以编辑~/.profile文件或者新建一个 Linux环境变量配置方法四：vim /etc/bashrc该方法是修改系统配置，需要管理员权限（如root）或者对该文件的写入权限： 1234567# 如果/etc/bashrc文件不可编辑，需要修改为可编辑chmod -v u+w /etc/bashrcvim /etc/bashrc# 在最后一行加上export PATH=$PATH:/home/uusama/mysql/bin 注意事项： 生效时间：新开终端生效，或者手动source /etc/bashrc生效 生效期限：永久有效 生效范围：对所有用户有效 Linux环境变量配置方法五：vim /etc/profile该方法修改系统配置，需要管理员权限或者对该文件的写入权限，和vim /etc/bashrc类似： 1234567# 如果/etc/profile文件不可编辑，需要修改为可编辑chmod -v u+w /etc/profilevim /etc/profile# 在最后一行加上export PATH=$PATH:/home/uusama/mysql/bin 注意事项： 生效时间：新开终端生效，或者手动source /etc/profile生效 生效期限：永久有效 生效范围：对所有用户有效 Linux环境变量配置方法六：vim /etc/environment该方法是修改系统环境配置文件，需要管理员权限或者对该文件的写入权限： 1234567# 如果/etc/bashrc文件不可编辑，需要修改为可编辑chmod -v u+w /etc/environmentvim /etc/profile# 在最后一行加上export PATH=$PATH:/home/uusama/mysql/bin 注意事项： 生效时间：新开终端生效，或者手动source /etc/environment生效 生效期限：永久有效 生效范围：对所有用户有效 Linux环境变量加载原理解析上面列出了环境变量的各种配置方法，那么Linux是如何加载这些配置的呢？是以什么样的顺序加载的呢？ 特定的加载顺序会导致相同名称的环境变量定义被覆盖或者不生效。 环境变量的分类环境变量可以简单的分成用户自定义的环境变量以及系统级别的环境变量。 用户级别环境变量定义文件：~/.bashrc、~/.profile（部分系统为：~/.bash_profile） 系统级别环境变量定义文件：/etc/bashrc、/etc/profile(部分系统为：/etc/bash_profile）、/etc/environment 另外在用户环境变量中，系统会首先读取~/.bash_profile（或者~/.profile）文件，如果没有该文件则读取~/.bash_login，根据这些文件中内容再去读取~/.bashrc。 测试Linux环境变量加载顺序的方法为了测试各个不同文件的环境变量加载顺序，我们在每个环境变量定义文件中的第一行都定义相同的环境变量UU_ORDER，该变量的值为本身的值连接上当前文件名称。 需要修改的文件如下： /etc/environment /etc/profile /etc/profile.d/test.sh，新建文件，没有文件夹可略过 /etc/bashrc，或者/etc/bash.bashrc ~/.bash_profile，或者~/.profile ~/.bashrc 在每个文件中的第一行都加上下面这句代码，并相应的把冒号后的内容修改为当前文件的绝对文件名。 1export UU_ORDER=&quot;$UU_ORDER:~/.bash_profile&quot; 修改完之后保存，新开一个窗口，然后echo $UU_ORDER观察变量的值： 12uusama@ubuntu:~$ echo $UU_ORDER$UU_ORDER:/etc/environment:/etc/profile:/etc/bash.bashrc:/etc/profile.d/test.sh:~/.profile:~/.bashrc 可以推测出Linux加载环境变量的顺序如下： /etc/environment /etc/profile /etc/bash.bashrc /etc/profile.d/test.sh ~/.profile ~/.bashrc Linux环境变量文件加载详解由上面的测试可容易得出Linux加载环境变量的顺序如下，： 系统环境变量 -&gt; 用户自定义环境变量/etc/environment -&gt; /etc/profile -&gt; ~/.profile 打开/etc/profile文件你会发现，该文件的代码中会加载/etc/bash.bashrc文件，然后检查/etc/profile.d/目录下的.sh文件并加载。 123456789101112131415161718192021222324252627# /etc/profile: system-wide .profile file for the Bourne shell (sh(1))# and Bourne compatible shells (bash(1), ksh(1), ash(1), ...).if [ &quot;$PS1&quot; ]; then if [ &quot;$BASH&quot; ] &amp;&amp; [ &quot;$BASH&quot; != &quot;/bin/sh&quot; ]; then # The file bash.bashrc already sets the default PS1. # PS1=&#x27;\\h:\\w\\$ &#x27; if [ -f /etc/bash.bashrc ]; then . /etc/bash.bashrc fi else if [ &quot;`id -u`&quot; -eq 0 ]; then PS1=&#x27;# &#x27; else PS1=&#x27;$ &#x27; fi fifiif [ -d /etc/profile.d ]; then for i in /etc/profile.d/*.sh; do if [ -r $i ]; then . $i fi done unset ifi 其次再打开~/.profile文件，会发现该文件中加载了~/.bashrc文件。 12345678910# if running bashif [ -n &quot;$BASH_VERSION&quot; ]; then # include .bashrc if it exists if [ -f &quot;$HOME/.bashrc&quot; ]; then . &quot;$HOME/.bashrc&quot; fifi# set PATH so it includes user&#x27;s private bin directoriesPATH=&quot;$HOME/bin:$HOME/.local/bin:$PATH&quot; 从~/.profile文件中代码不难发现，/.profile文件只在用户登录的时候读取一次，而/.bashrc会在每次运行Shell脚本的时候读取一次。 一些小技巧可以自定义一个环境变量文件，比如在某个项目下定义uusama.profile，在这个文件中使用export定义一系列变量，然后在~/.profile文件后面加上：sourc uusama.profile，这样你每次登陆都可以在Shell脚本中使用自己定义的一系列变量。 也可以使用alias命令定义一些命令的别名，比如alias rm=&quot;rm -i&quot;（双引号必须），并把这个代码加入到~/.profile中，这样你每次使用rm命令的时候，都相当于使用rm -i命令，非常方便。","categories":[{"name":"服务端","slug":"服务端","permalink":"https://hxlpub.github.io/categories/%E6%9C%8D%E5%8A%A1%E7%AB%AF/"},{"name":"Linux","slug":"服务端/Linux","permalink":"https://hxlpub.github.io/categories/%E6%9C%8D%E5%8A%A1%E7%AB%AF/Linux/"},{"name":"工作常用命令","slug":"服务端/Linux/工作常用命令","permalink":"https://hxlpub.github.io/categories/%E6%9C%8D%E5%8A%A1%E7%AB%AF/Linux/%E5%B7%A5%E4%BD%9C%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"}],"tags":[]},{"title":".ko文件编写加载","slug":"linux_ko","date":"2021-09-14T09:26:07.000Z","updated":"2021-10-22T07:00:32.000Z","comments":true,"path":"2021/09/14/linux_ko/","link":"","permalink":"https://hxlpub.github.io/2021/09/14/linux_ko/","excerpt":"","text":"参考 一、.ko 文件介绍.ko文件是kernel object文件（内核模块），该文件的意义就是把内核的一些功能移动到内核外边， 需要的时候插入内核，不需要时卸载。 二、优点（1）这样可以缩小内核体积； （2）使用方便。 三、.ko文件一般的用处（1）作为一个功能模块，需要使用时，直接插入运行就行。如在imx6上连接模拟摄像头，先运行模拟摄像头对应的驱动模块 camera.ko文件，然后对应的工程执行文件运行就行。 四、使用.ko 文件1、加载驱动模块test.ko（1）方法一进入test.ko驱动模块文件所在的目录，然后直接 insmod test.ko （2）方法二将test.ko文件拷贝到/lib/module/#uname-r#/目录下，这里，#uname -r#意思是，在终端中输入uname -r后显示的内核版本及名称，例如我的环境centos 7系统下#uname-r#就是3.10.0-957.12.2.el7.x86_64然后 depmod（会在/lib/modules/#uname -r#/目录下生成modules.dep和modules.dep.bb文件，表明模块的依赖关系）最后 modprobe test（注意这里无需输入.ko后缀） 即可 注：两种方法的区别 modprobe和insmod类似，都是用来动态加载驱动模块的，区别在于modprobe可以解决load module时的依赖关系，它是通过/lib/modules/#uname -r/modules.dep(.bb)文件来查找依赖关系的；而insmod不能解决依赖问题。也就是说，如果你确定你要加载的驱动模块不依赖其他驱动模块的话，既可以insmod也可以modprobe，当然insmod可以在任何目录下执行，更方便一些。而如果你要加载的驱动模块还依赖其他ko驱动模块的话，就只能将模块拷贝到上述的特定目录，depmod后再modprobe。 2、查看已加载的驱动模块列表在任何目录下输入命令lsmod 12345678910111213141516171819202122232425`[root@HikvisionOS ~]# lsmod` `Module Size Used by``ip6t_rpfilter 12595 1` `ipt_REJECT 12541 2` `nf_reject_ipv4 13373 1 ipt_REJECT``ip6t_REJECT 12625 2` `nf_reject_ipv6 13717 1 ip6t_REJECT``xt_conntrack 12760 19` `ip_set 45644 0` `nfnetlink 14490 1 ip_set``ebtable_nat 12807 1` `ebtable_broute 12731 1` `bridge 151336 1 ebtable_broute``stp 12976 1 bridge``llc 14552 2 stp,bridge``ip6table_nat 12864 1` `nf_conntrack_ipv6 18935 11` `nf_defrag_ipv6 35104 1 nf_conntrack_ipv6``nf_nat_ipv6 14131 1 ip6table_nat``ip6table_mangle 12700 1` `ip6table_security 12710 1` `ip6table_raw 12683 1` `iptable_nat 12875 1` `nf_conntrack_ipv4 15053 10` `nf_defrag_ipv4 12729 1 nf_conntrack_ipv4` 3、卸载驱动模块在任何目录下， 输入命令 rmmod 注：“module_name”是lsmod显示的模块名称，而不是对应的ko文件名 五、编写生成.ko 文件Linux下hello.ko内核模块制作的全过程 1.linux系统用的是Redflag 6.0 SP1 下载地址：ftp://ftp.redflag-linux.com/pub/redflag/dt6sp1/SP1/redflag-6-sp1.iso， 系统安装很容易，安提示做就好。所用的内核源码目录树下载地址：ftp://ftp.redflag-linux.com/pub/redflag/dt6sp1/SP1/redflag-6-tool-sp1-src1.iso，将此iso文件挂载到/mnt下，安装其中的内核rpm包。挂载方法：mount -t iso9660 redflag-6-tool-sp1-src1.iso /mnt/ -o loop内核目录树安装方法：cd /mnt/RedFlag/SRMPS/ rpm -i kernel-2.6.23.1-4.src.rpm 2.编写hello模块代码，源码如下： hello.c 12345678910111213141516#include &lt;linux/init.h&gt; #include &lt;linux/module.h&gt; MODULE_LICENSE(&quot;GPL&quot;); static int hello_init(void) &#123; printk(KERN_ALERT &quot;Hello, world\\n&quot;); return 0; &#125; static void hello_exit(void) &#123; printk(KERN_ALERT &quot;Goodbye, cruel world\\n&quot;); &#125; module_init(hello_init); module_exit(hello_exit); 3.编写hello模块的Makefile文件，Makefile内容如下： 123456789101112Makefile#Makefile 2.6 obj-m :=hello.o KERNEL :=/usr/src/kernels/$(uname -r)/ PWD :=$(shell pwd) modules : $(MAKE) -C $(KERNEL) M=$(PWD) modules .PHONEY:clean clean : rm -f *.o *.ko 4.编译模块在命令行进入hello.c所在的文件夹下执行make命令即可完成hello模块的编译。用ls命令可以查看到hello.ko文件，此文件就是我们自定义的内核模块。 5.安装hello模块 命令行下执行命令：insmod hello.ko 。通过命令:cat /var/log/messages 可以看到下面这样的信息：“Aug 6 13:37:59 localhost kernel: Hello, world”，说明模块加载成功了。 6.另外一种模块Makefile的编写方法 Makefile 1234567891011121314151617181920# If KERNELRELEASE is defined, we&#x27;ve been invoked from the # kernel build system and can use its language. ifneq ($(KERNELRELEASE),) obj-m := hello.o # Otherwise we were called directly from the command # line; invoke the kernel build system. else KERNELDIR ?= /lib/modules/$(shell uname -r)/build PWD := $(shell pwd) default: $(MAKE) -C $(KERNELDIR) M=$(PWD) modules endif 卸载hello模块 命令行下执行命令：rmmod hello.ko即可。通过命令：cat /var/log/messages.可以看到下面这样的信息：“Aug 6 13:40:36 localhost kernel: Goodbye, cruel world”，说明模块卸载成功。 查看模块信息 命令行下执行命令：modinfo hello————————————————版权声明：本文为CSDN博主「worthsen」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。原文链接：https://blog.csdn.net/qq_38880380/article/details/79227760","categories":[{"name":"服务端","slug":"服务端","permalink":"https://hxlpub.github.io/categories/%E6%9C%8D%E5%8A%A1%E7%AB%AF/"},{"name":"Linux","slug":"服务端/Linux","permalink":"https://hxlpub.github.io/categories/%E6%9C%8D%E5%8A%A1%E7%AB%AF/Linux/"},{"name":"linux驱动","slug":"服务端/Linux/linux驱动","permalink":"https://hxlpub.github.io/categories/%E6%9C%8D%E5%8A%A1%E7%AB%AF/Linux/linux%E9%A9%B1%E5%8A%A8/"}],"tags":[]},{"title":"centos 7 基于最小化系统搭建服务器","slug":"linux_mini_system_config","date":"2021-09-14T09:26:07.000Z","updated":"2022-01-23T07:10:25.319Z","comments":true,"path":"2021/09/14/linux_mini_system_config/","link":"","permalink":"https://hxlpub.github.io/2021/09/14/linux_mini_system_config/","excerpt":"","text":"将自己的一台旧笔记本装成centos 7 配置服务器 网络配置 配置无线网卡（有网线的可以配置有线网卡）,一开始， 1.nmcli 查看网卡，我的无线网卡是wlp1s0,显示unmanaged， plugin missing，需要托管下并且安装NetworkManager-wifi模块 2.nmcli dev set wlp1s0 autoconnect yes managed yes 加入托管 3.在官网下载相应版本的rpm 包，我的是centos 7 版本NetworkManager-wifi-1.18.8-1.el7.x86_64.rpm ,拷贝到U盘 4.安装，yum install -y NetworkManager-wifi-1.18.8-1.el7.x86_64.rpm 5.安装完，重启下NetworkManager.service ,systemctl restart NetworkManager.service nmcli 查看 显示disconnected 6.连接无线 nmcli d wifi list：列出当前扫描出的热点 nmcli dev wifi connect “wifi名称” password “WiFi密码” 查看 nmcli dev show wlp1s0 已经connected 7.ping 一下自己另外的设备A，不通的，但是能ping 通网关还能ping www.baidu.com,而且在另外的设备A上ping 服务器B是通的：关闭A 防火墙 其他配置参考 [参考]: https://blog.csdn.net/chenkaifang/article/details/82531696 “CentOS7.5最小化安装之后的配置”","categories":[{"name":"服务端","slug":"服务端","permalink":"https://hxlpub.github.io/categories/%E6%9C%8D%E5%8A%A1%E7%AB%AF/"},{"name":"Linux","slug":"服务端/Linux","permalink":"https://hxlpub.github.io/categories/%E6%9C%8D%E5%8A%A1%E7%AB%AF/Linux/"},{"name":"服务器搭建","slug":"服务端/Linux/服务器搭建","permalink":"https://hxlpub.github.io/categories/%E6%9C%8D%E5%8A%A1%E7%AB%AF/Linux/%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://hxlpub.github.io/tags/linux/"}]},{"title":"linux性能分析","slug":"linux_server_performance_analysis","date":"2021-09-14T09:26:07.000Z","updated":"2021-09-30T08:01:26.000Z","comments":true,"path":"2021/09/14/linux_server_performance_analysis/","link":"","permalink":"https://hxlpub.github.io/2021/09/14/linux_server_performance_analysis/","excerpt":"","text":"","categories":[{"name":"服务端","slug":"服务端","permalink":"https://hxlpub.github.io/categories/%E6%9C%8D%E5%8A%A1%E7%AB%AF/"},{"name":"Linux","slug":"服务端/Linux","permalink":"https://hxlpub.github.io/categories/%E6%9C%8D%E5%8A%A1%E7%AB%AF/Linux/"},{"name":"服务器性能分析","slug":"服务端/Linux/服务器性能分析","permalink":"https://hxlpub.github.io/categories/%E6%9C%8D%E5%8A%A1%E7%AB%AF/Linux/%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/"}],"tags":[]},{"title":"shell_","slug":"linux_shell","date":"2021-09-14T09:26:07.000Z","updated":"2022-02-23T09:05:50.538Z","comments":true,"path":"2021/09/14/linux_shell/","link":"","permalink":"https://hxlpub.github.io/2021/09/14/linux_shell/","excerpt":"","text":"1.符号 2.读文件方法 https://blog.csdn.net/feixiaohuijava/article/details/53129413","categories":[{"name":"服务端","slug":"服务端","permalink":"https://hxlpub.github.io/categories/%E6%9C%8D%E5%8A%A1%E7%AB%AF/"},{"name":"Linux","slug":"服务端/Linux","permalink":"https://hxlpub.github.io/categories/%E6%9C%8D%E5%8A%A1%E7%AB%AF/Linux/"},{"name":"shell","slug":"服务端/Linux/shell","permalink":"https://hxlpub.github.io/categories/%E6%9C%8D%E5%8A%A1%E7%AB%AF/Linux/shell/"}],"tags":[]},{"title":"收藏的资源站点","slug":"linux_sites","date":"2021-09-14T09:26:07.000Z","updated":"2021-11-06T06:31:18.000Z","comments":true,"path":"2021/09/14/linux_sites/","link":"","permalink":"https://hxlpub.github.io/2021/09/14/linux_sites/","excerpt":"","text":"ubuntu: Ubuntu 命令技巧","categories":[{"name":"服务端","slug":"服务端","permalink":"https://hxlpub.github.io/categories/%E6%9C%8D%E5%8A%A1%E7%AB%AF/"},{"name":"Linux","slug":"服务端/Linux","permalink":"https://hxlpub.github.io/categories/%E6%9C%8D%E5%8A%A1%E7%AB%AF/Linux/"}],"tags":[]},{"title":"shell_","slug":"linux_soft_manage_FAq","date":"2021-09-14T09:26:07.000Z","updated":"2022-02-25T11:23:02.457Z","comments":true,"path":"2021/09/14/linux_soft_manage_FAq/","link":"","permalink":"https://hxlpub.github.io/2021/09/14/linux_soft_manage_FAq/","excerpt":"","text":"1.执行dnf install python3 ：bash: /usr/bin/dnf: /usr/bin/python3: bad interpreter: No such file or directory 12345678#原因，安装其他软件导致python 版本同dnf 配置文件里的python 版本不一致[root@192 /]# whereis dnf dnf: /usr/bin/dnf /etc/dnf /usr/share/man/man8/dnf.8.gz[root@192 /]# vim /usr/bin/dnf#!/usr/bin/python3.9# The dnf executable script.# error while loading shared libraries: librte_telemetry.so.21: cannot open shared object file: No such file or directory 1234vim /etc/ld.so.conf#加入so lib path如/usr/local/daos/prereq/release/spdk/libldconfig 更新一下配置 3.ldd 查看 库 no found 123vim /etc/ld.so.conf 加相应的库路径，如/usr/local/daos/prereq/release/spdk/lib 后ldconfig","categories":[{"name":"服务端","slug":"服务端","permalink":"https://hxlpub.github.io/categories/%E6%9C%8D%E5%8A%A1%E7%AB%AF/"},{"name":"Linux","slug":"服务端/Linux","permalink":"https://hxlpub.github.io/categories/%E6%9C%8D%E5%8A%A1%E7%AB%AF/Linux/"},{"name":"编译常见问题FAQ","slug":"服务端/Linux/编译常见问题FAQ","permalink":"https://hxlpub.github.io/categories/%E6%9C%8D%E5%8A%A1%E7%AB%AF/Linux/%E7%BC%96%E8%AF%91%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98FAQ/"}],"tags":[]},{"title":"学习思路","slug":"machine-learning","date":"2021-09-14T09:26:07.000Z","updated":"2021-09-30T15:17:12.000Z","comments":true,"path":"2021/09/14/machine-learning/","link":"","permalink":"https://hxlpub.github.io/2021/09/14/machine-learning/","excerpt":"","text":"","categories":[{"name":"机器学习","slug":"机器学习","permalink":"https://hxlpub.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"入门","slug":"机器学习/入门","permalink":"https://hxlpub.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E5%85%A5%E9%97%A8/"},{"name":"学习思路","slug":"机器学习/入门/学习思路","permalink":"https://hxlpub.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E5%85%A5%E9%97%A8/%E5%AD%A6%E4%B9%A0%E6%80%9D%E8%B7%AF/"}],"tags":[]},{"title":"go_linux编译运行环境搭建","slug":"go_compile","date":"2021-09-13T14:29:54.000Z","updated":"2022-02-22T12:42:21.089Z","comments":true,"path":"2021/09/13/go_compile/","link":"","permalink":"https://hxlpub.github.io/2021/09/13/go_compile/","excerpt":"","text":"1.最直接的方式​ 官网提供了第一手资料，十分全面，可以根据自己的系统（windows、linux、mac）选择自己的下载和安装方式 点击进入官网 2.源码编译方式2.1 准备 交叉编译工具链： 交叉编译：是A机器上编译生成，运行在B机器上。两个机子有不同的机器指令。 工具链：一般由编译器、连接器、解释器和调试器组成。 构建交叉工具链方法： 方法一：分步编译和安装交叉编译工具链所需要的库和源代码，最终生成交叉编译工具链。该方法相对比较困难，适合想深入学习构建交叉工具链的读者。如果只是想使用交叉工具链，建议使用下列的方法二构建交叉工具链。 方法二 通过Crosstool脚本工具来实现一次编译，生成交叉编译工具链，该方法相对于方法一要简单许多，并且出错的机会也非常少，建议大多数情况下使用该方法构建交叉编译工具链。 方法三 直接通过网上下载已经制作好的交叉编译工具链。该方法的优点不用多说，当然是简单省事，但该方法有一定的弊端就是局限性太大，因为毕竟是别人构建好的，也就是固定的，没有灵活性，所以构建所用的库以及编译器的版本也许并不适合你要编译的程序，同时也许会在使用时出现许多莫名其妙的错误，建议读者慎用此方法。 2.2 安装编译工具链3.编译参数","categories":[{"name":"服务端","slug":"服务端","permalink":"https://hxlpub.github.io/categories/%E6%9C%8D%E5%8A%A1%E7%AB%AF/"},{"name":"go","slug":"服务端/go","permalink":"https://hxlpub.github.io/categories/%E6%9C%8D%E5%8A%A1%E7%AB%AF/go/"},{"name":"编译运行环境搭建","slug":"服务端/go/编译运行环境搭建","permalink":"https://hxlpub.github.io/categories/%E6%9C%8D%E5%8A%A1%E7%AB%AF/go/%E7%BC%96%E8%AF%91%E8%BF%90%E8%A1%8C%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"}],"tags":[{"name":"golang","slug":"golang","permalink":"https://hxlpub.github.io/tags/golang/"}]},{"title":"notes","slug":"love","date":"2021-09-12T09:05:23.000Z","updated":"2021-10-10T05:00:38.000Z","comments":true,"path":"2021/09/12/love/","link":"","permalink":"https://hxlpub.github.io/2021/09/12/love/","excerpt":"","text":"ps:宝宝，爱你！！！","categories":[{"name":"startup","slug":"startup","permalink":"https://hxlpub.github.io/categories/startup/"}],"tags":[{"name":"love","slug":"love","permalink":"https://hxlpub.github.io/tags/love/"}]}],"categories":[{"name":"存储","slug":"存储","permalink":"https://hxlpub.github.io/categories/%E5%AD%98%E5%82%A8/"},{"name":"分布式异步存储系统","slug":"存储/分布式异步存储系统","permalink":"https://hxlpub.github.io/categories/%E5%AD%98%E5%82%A8/%E5%88%86%E5%B8%83%E5%BC%8F%E5%BC%82%E6%AD%A5%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F/"},{"name":"daos","slug":"存储/分布式异步存储系统/daos","permalink":"https://hxlpub.github.io/categories/%E5%AD%98%E5%82%A8/%E5%88%86%E5%B8%83%E5%BC%8F%E5%BC%82%E6%AD%A5%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F/daos/"},{"name":"startup","slug":"startup","permalink":"https://hxlpub.github.io/categories/startup/"},{"name":"设计之道","slug":"设计之道","permalink":"https://hxlpub.github.io/categories/%E8%AE%BE%E8%AE%A1%E4%B9%8B%E9%81%93/"},{"name":"概念","slug":"设计之道/概念","permalink":"https://hxlpub.github.io/categories/%E8%AE%BE%E8%AE%A1%E4%B9%8B%E9%81%93/%E6%A6%82%E5%BF%B5/"},{"name":"服务端","slug":"服务端","permalink":"https://hxlpub.github.io/categories/%E6%9C%8D%E5%8A%A1%E7%AB%AF/"},{"name":"go","slug":"服务端/go","permalink":"https://hxlpub.github.io/categories/%E6%9C%8D%E5%8A%A1%E7%AB%AF/go/"},{"name":"语言基础+原理","slug":"服务端/go/语言基础-原理","permalink":"https://hxlpub.github.io/categories/%E6%9C%8D%E5%8A%A1%E7%AB%AF/go/%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80-%E5%8E%9F%E7%90%86/"},{"name":"编码规范","slug":"服务端/go/编码规范","permalink":"https://hxlpub.github.io/categories/%E6%9C%8D%E5%8A%A1%E7%AB%AF/go/%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83/"},{"name":"编译","slug":"服务端/编译","permalink":"https://hxlpub.github.io/categories/%E6%9C%8D%E5%8A%A1%E7%AB%AF/%E7%BC%96%E8%AF%91/"},{"name":"Makefile","slug":"服务端/编译/Makefile","permalink":"https://hxlpub.github.io/categories/%E6%9C%8D%E5%8A%A1%E7%AB%AF/%E7%BC%96%E8%AF%91/Makefile/"},{"name":"C_C++","slug":"服务端/C-C","permalink":"https://hxlpub.github.io/categories/%E6%9C%8D%E5%8A%A1%E7%AB%AF/C-C/"},{"name":"基础篇：C","slug":"服务端/C-C/基础篇：C","permalink":"https://hxlpub.github.io/categories/%E6%9C%8D%E5%8A%A1%E7%AB%AF/C-C/%E5%9F%BA%E7%A1%80%E7%AF%87%EF%BC%9AC/"},{"name":"C++篇：回顾","slug":"服务端/C-C/C-篇：回顾","permalink":"https://hxlpub.github.io/categories/%E6%9C%8D%E5%8A%A1%E7%AB%AF/C-C/C-%E7%AF%87%EF%BC%9A%E5%9B%9E%E9%A1%BE/"},{"name":"前端","slug":"前端","permalink":"https://hxlpub.github.io/categories/%E5%89%8D%E7%AB%AF/"},{"name":"静态页面","slug":"前端/静态页面","permalink":"https://hxlpub.github.io/categories/%E5%89%8D%E7%AB%AF/%E9%9D%99%E6%80%81%E9%A1%B5%E9%9D%A2/"},{"name":"Hexo静态页面生成器","slug":"前端/静态页面/Hexo静态页面生成器","permalink":"https://hxlpub.github.io/categories/%E5%89%8D%E7%AB%AF/%E9%9D%99%E6%80%81%E9%A1%B5%E9%9D%A2/Hexo%E9%9D%99%E6%80%81%E9%A1%B5%E9%9D%A2%E7%94%9F%E6%88%90%E5%99%A8/"},{"name":"协议开发","slug":"服务端/go/协议开发","permalink":"https://hxlpub.github.io/categories/%E6%9C%8D%E5%8A%A1%E7%AB%AF/go/%E5%8D%8F%E8%AE%AE%E5%BC%80%E5%8F%91/"},{"name":"Python","slug":"服务端/Python","permalink":"https://hxlpub.github.io/categories/%E6%9C%8D%E5%8A%A1%E7%AB%AF/Python/"},{"name":"语言基础原理","slug":"服务端/Python/语言基础原理","permalink":"https://hxlpub.github.io/categories/%E6%9C%8D%E5%8A%A1%E7%AB%AF/Python/%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%8E%9F%E7%90%86/"},{"name":"算法","slug":"算法","permalink":"https://hxlpub.github.io/categories/%E7%AE%97%E6%B3%95/"},{"name":"排序","slug":"算法/排序","permalink":"https://hxlpub.github.io/categories/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F/"},{"name":"GCC编译","slug":"服务端/编译/GCC编译","permalink":"https://hxlpub.github.io/categories/%E6%9C%8D%E5%8A%A1%E7%AB%AF/%E7%BC%96%E8%AF%91/GCC%E7%BC%96%E8%AF%91/"},{"name":"工具-Makefile-scons","slug":"服务端/编译/工具-Makefile-scons","permalink":"https://hxlpub.github.io/categories/%E6%9C%8D%E5%8A%A1%E7%AB%AF/%E7%BC%96%E8%AF%91/%E5%B7%A5%E5%85%B7-Makefile-scons/"},{"name":"计算机视觉","slug":"计算机视觉","permalink":"https://hxlpub.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/"},{"name":"数据库","slug":"数据库","permalink":"https://hxlpub.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"postgres","slug":"数据库/postgres","permalink":"https://hxlpub.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/postgres/"},{"name":"PostgreSQL","slug":"数据库/PostgreSQL","permalink":"https://hxlpub.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/PostgreSQL/"},{"name":"深度学习","slug":"深度学习","permalink":"https://hxlpub.github.io/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"},{"name":"入门","slug":"深度学习/入门","permalink":"https://hxlpub.github.io/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E5%85%A5%E9%97%A8/"},{"name":"学习思路","slug":"深度学习/入门/学习思路","permalink":"https://hxlpub.github.io/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E5%85%A5%E9%97%A8/%E5%AD%A6%E4%B9%A0%E6%80%9D%E8%B7%AF/"},{"name":"开发工具","slug":"开发工具","permalink":"https://hxlpub.github.io/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"},{"name":"版本管理","slug":"开发工具/版本管理","permalink":"https://hxlpub.github.io/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86/"},{"name":"git","slug":"开发工具/版本管理/git","permalink":"https://hxlpub.github.io/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86/git/"},{"name":"Linux","slug":"服务端/Linux","permalink":"https://hxlpub.github.io/categories/%E6%9C%8D%E5%8A%A1%E7%AB%AF/Linux/"},{"name":"文件传输","slug":"服务端/Linux/文件传输","permalink":"https://hxlpub.github.io/categories/%E6%9C%8D%E5%8A%A1%E7%AB%AF/Linux/%E6%96%87%E4%BB%B6%E4%BC%A0%E8%BE%93/"},{"name":"内核kernel","slug":"服务端/Linux/内核kernel","permalink":"https://hxlpub.github.io/categories/%E6%9C%8D%E5%8A%A1%E7%AB%AF/Linux/%E5%86%85%E6%A0%B8kernel/"},{"name":"工作常用命令","slug":"服务端/Linux/工作常用命令","permalink":"https://hxlpub.github.io/categories/%E6%9C%8D%E5%8A%A1%E7%AB%AF/Linux/%E5%B7%A5%E4%BD%9C%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"name":"linux驱动","slug":"服务端/Linux/linux驱动","permalink":"https://hxlpub.github.io/categories/%E6%9C%8D%E5%8A%A1%E7%AB%AF/Linux/linux%E9%A9%B1%E5%8A%A8/"},{"name":"服务器搭建","slug":"服务端/Linux/服务器搭建","permalink":"https://hxlpub.github.io/categories/%E6%9C%8D%E5%8A%A1%E7%AB%AF/Linux/%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA/"},{"name":"服务器性能分析","slug":"服务端/Linux/服务器性能分析","permalink":"https://hxlpub.github.io/categories/%E6%9C%8D%E5%8A%A1%E7%AB%AF/Linux/%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/"},{"name":"shell","slug":"服务端/Linux/shell","permalink":"https://hxlpub.github.io/categories/%E6%9C%8D%E5%8A%A1%E7%AB%AF/Linux/shell/"},{"name":"编译常见问题FAQ","slug":"服务端/Linux/编译常见问题FAQ","permalink":"https://hxlpub.github.io/categories/%E6%9C%8D%E5%8A%A1%E7%AB%AF/Linux/%E7%BC%96%E8%AF%91%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98FAQ/"},{"name":"机器学习","slug":"机器学习","permalink":"https://hxlpub.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"入门","slug":"机器学习/入门","permalink":"https://hxlpub.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E5%85%A5%E9%97%A8/"},{"name":"学习思路","slug":"机器学习/入门/学习思路","permalink":"https://hxlpub.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E5%85%A5%E9%97%A8/%E5%AD%A6%E4%B9%A0%E6%80%9D%E8%B7%AF/"},{"name":"编译运行环境搭建","slug":"服务端/go/编译运行环境搭建","permalink":"https://hxlpub.github.io/categories/%E6%9C%8D%E5%8A%A1%E7%AB%AF/go/%E7%BC%96%E8%AF%91%E8%BF%90%E8%A1%8C%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"}],"tags":[{"name":"love more","slug":"love-more","permalink":"https://hxlpub.github.io/tags/love-more/"},{"name":"设计","slug":"设计","permalink":"https://hxlpub.github.io/tags/%E8%AE%BE%E8%AE%A1/"},{"name":"服务端","slug":"服务端","permalink":"https://hxlpub.github.io/tags/%E6%9C%8D%E5%8A%A1%E7%AB%AF/"},{"name":"Hexo","slug":"Hexo","permalink":"https://hxlpub.github.io/tags/Hexo/"},{"name":"linux","slug":"linux","permalink":"https://hxlpub.github.io/tags/linux/"},{"name":"golang","slug":"golang","permalink":"https://hxlpub.github.io/tags/golang/"},{"name":"love","slug":"love","permalink":"https://hxlpub.github.io/tags/love/"}]}