{"meta":{"title":"linhongxun's blog","subtitle":"","description":"沉淀技术","author":"linhongxun","url":"https://hxlpub.github.io","root":"/"},"pages":[{"title":"","date":"2022-01-23T13:22:32.794Z","updated":"2022-01-23T13:22:32.794Z","comments":true,"path":"baidu_verify_code-cy3v7EZjHQ.html","permalink":"https://hxlpub.github.io/baidu_verify_code-cy3v7EZjHQ.html","excerpt":"","text":"af8c45052f3f71cf99a43cc291aaf1c8"},{"title":"","date":"2022-03-13T11:10:28.495Z","updated":"2022-03-13T11:10:28.495Z","comments":true,"path":"google8f56f9384c97481d.html","permalink":"https://hxlpub.github.io/google8f56f9384c97481d.html","excerpt":"","text":"google-site-verification: google8f56f9384c97481d.html"},{"title":"categories","date":"2021-09-12T12:40:56.000Z","updated":"2021-09-12T12:42:06.000Z","comments":true,"path":"categories/index.bak.html","permalink":"https://hxlpub.github.io/categories/index.bak.html","excerpt":"","text":""},{"title":"about me","date":"2021-09-12T12:48:58.000Z","updated":"2022-03-13T09:05:02.431Z","comments":true,"path":"about/index.html","permalink":"https://hxlpub.github.io/about/index.html","excerpt":"","text":"E-mail: &#104;&#111;&#x6e;&#103;&#120;&#117;&#x6e;&#108;&#x69;&#x6e;&#112;&#117;&#98;&#x40;&#49;&#54;&#51;&#46;&#99;&#x6f;&#109; or &#104;&#x6f;&#x6e;&#x67;&#120;&#x75;&#x6e;&#x6c;&#x69;&#110;&#x40;&#115;&#x69;&#x6e;&#x61;&#x2e;&#99;&#111;&#109; Blog: https://hxlpub.github.io Github: https://github.com/hxlpub"},{"title":"书单","date":"2022-03-13T09:28:01.014Z","updated":"2022-03-13T09:27:48.952Z","comments":false,"path":"books/index.bak.html","permalink":"https://hxlpub.github.io/books/index.bak.html","excerpt":"","text":""},{"title":"分类","date":"2022-03-13T09:14:58.632Z","updated":"2022-03-12T13:59:18.462Z","comments":false,"path":"categories/index.html","permalink":"https://hxlpub.github.io/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2021-09-12T12:49:10.000Z","updated":"2022-03-13T09:25:01.893Z","comments":true,"path":"tags/index.bak.html","permalink":"https://hxlpub.github.io/tags/index.bak.html","excerpt":"","text":""},{"title":"Repositories","date":"2022-03-13T09:14:18.985Z","updated":"2022-03-12T13:59:18.462Z","comments":false,"path":"repository/index.html","permalink":"https://hxlpub.github.io/repository/index.html","excerpt":"","text":""},{"title":"书单","date":"2022-03-13T09:28:04.918Z","updated":"2022-03-13T09:28:04.918Z","comments":false,"path":"books/index.html","permalink":"https://hxlpub.github.io/books/index.html","excerpt":"","text":""},{"title":"标签","date":"2022-03-13T09:25:23.619Z","updated":"2022-03-13T09:25:23.619Z","comments":false,"path":"tags/index.html","permalink":"https://hxlpub.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"define_a_systemd_service","slug":"define-a-systemd-service","date":"2022-04-01T11:05:53.000Z","updated":"2022-04-02T02:50:05.175Z","comments":true,"path":"2022/04/01/define-a-systemd-service/","link":"","permalink":"https://hxlpub.github.io/2022/04/01/define-a-systemd-service/","excerpt":"","text":"将编译生成的二进制文件 修改/usr/lib/systemd/system/daos_agent.service ExecStart=/usr/local/daos/bin/daos_agent -i -o &lt;’path to agent configuration file/daos_agent.yml’&gt; systemctl daemon-reload systemctl enable daos_agent.service systemctl start daos_agent.service","categories":[{"name":"Linux","slug":"Linux","permalink":"https://hxlpub.github.io/categories/Linux/"}],"tags":[{"name":"systemd","slug":"systemd","permalink":"https://hxlpub.github.io/tags/systemd/"}]},{"title":"python_newer","slug":"python-newer","date":"2022-03-29T10:09:39.000Z","updated":"2022-04-02T02:50:21.285Z","comments":true,"path":"2022/03/29/python-newer/","link":"","permalink":"https://hxlpub.github.io/2022/03/29/python-newer/","excerpt":"","text":"开胃菜 相比之下，Python 更易于使用，无论在 Windows、Mac OS X 或 Unix 操作系统上它都会帮助你更快地完成任务 与 Shell 脚本或批处理文件相比，它为编写大型程序提供了更多的结构和支持。 Python 提供了比 C 更多的错误检查，并且作为一门 高级语言，它内置支持高级的数据结构类型，例如：灵活的数组和字典。 Python 允许你将程序分割为不同的模块，以便在其他的 Python 程序中重用。Python 内置提供了大量的标准模块，你可以将其用作程序的基础，或者作为学习 Python 编程的示例。这些模块提供了诸如文件 I/O、系统调用、Socket 支持，甚至类似 Tk 的用户图形界面（GUI）工具包接口 Python 是一门解释型语言，因为无需编译和链接，你可以在程序开发中节省宝贵的时间。Python 解释器可以交互的使用，这使得试验语言的特性、编写临时程序或在自底向上的程序开发中测试方法非常容易。你甚至还可以把它当做一个桌面计算器。 Python 让程序编写的紧凑和可读。用 Python 编写的程序通常比同样的 C、C++ 或 Java 程序更短小，这是因为以下几个原因: 12345* 高级数据结构使你可以在一条语句中表达复杂的操作；* 语句组使用缩进代替开始和结束大括号来组织；* 变量或参数无需声明。 Python 是 可扩展 的：如果你会 C 语言编程便可以轻易地为解释器添加内置函数或模块，或者为了对性能瓶颈作优化，或者将 Python 程序与只有二进制形式的库（比如某个专业的商业图形库）连接起来。一旦你真正掌握了它，你可以将 Python 解释器集成进某个 C 应用程序，并把它当作那个程序的扩展或命令行语言。 使用python解释器 2.1.调用python解释器 ​ 2.2 ​","categories":[{"name":"Python","slug":"Python","permalink":"https://hxlpub.github.io/categories/Python/"}],"tags":[{"name":"python","slug":"python","permalink":"https://hxlpub.github.io/tags/python/"}]},{"title":"daos","slug":"daos_2.0","date":"2022-01-24T07:57:07.000Z","updated":"2022-03-26T09:01:34.541Z","comments":true,"path":"2022/01/24/daos_2.0/","link":"","permalink":"https://hxlpub.github.io/2022/01/24/daos_2.0/","excerpt":"","text":"","categories":[{"name":"分布式异步存储系统","slug":"分布式异步存储系统","permalink":"https://hxlpub.github.io/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E5%BC%82%E6%AD%A5%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"分布式存储","slug":"分布式存储","permalink":"https://hxlpub.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8/"}]},{"title":"newpc_test_for_hexo_blog","slug":"newpc","date":"2022-01-15T09:05:23.000Z","updated":"2022-03-26T08:50:54.949Z","comments":true,"path":"2022/01/15/newpc/","link":"","permalink":"https://hxlpub.github.io/2022/01/15/newpc/","excerpt":"","text":"ps:new year love more ！！！","categories":[{"name":"startup","slug":"startup","permalink":"https://hxlpub.github.io/categories/startup/"}],"tags":[{"name":"love more","slug":"love-more","permalink":"https://hxlpub.github.io/tags/love-more/"}]},{"title":"设计模式","slug":"system_design_thinking","date":"2022-01-13T02:16:07.000Z","updated":"2022-03-26T08:51:57.827Z","comments":true,"path":"2022/01/13/system_design_thinking/","link":"","permalink":"https://hxlpub.github.io/2022/01/13/system_design_thinking/","excerpt":"","text":"1、异步同步阻塞非阻塞（以下知乎十分有趣） https://www.zhihu.com/question/26393784 老张爱喝茶，废话不说，煮开水。 出场人物：老张，水壶两把（普通水壶，简称水壶；会响的水壶，简称响水壶）。 1)老张把水壶放到火上，立等水开。（同步阻塞） 老张觉得自己有点傻 2)老张把水壶放到火上，去客厅看电视，时不时去厨房看看水开没有。（同步非阻塞） 老张还是觉得自己有点傻，于是变高端了，买了把会响笛的那种水壶。水开之后，能大声发出嘀~~~~的噪音。 3)老张把响水壶放到火上，立等水开。（异步阻塞） 老张觉得这样傻等意义不大 4)老张把响水壶放到火上，去客厅看电视，水壶响之前不再去看它了，响了再去拿壶。（异步非阻塞） 老张觉得自己聪明了。 所谓同步异步，只是对于水壶而言。 普通水壶，同步；响水壶，异步。 虽然都能干活，但响水壶可以在自己完工之后，提示老张水开了。这是普通水壶所不能及的。 同步只能让调用者去轮询自己（情况2中），造成老张效率的低下。所谓阻塞非阻塞，仅仅对于老张而言。 立等的老张，阻塞；看电视的老张，非阻塞。 情况1和情况3中老张就是阻塞的，媳妇喊他都不知道。虽然3中响水壶是异步的，可对于立等的老张没有太大的意义。所以一般异步是配合非阻塞使用的，这样才能发挥异步的效用。 作者：知乎用户链接：https://www.zhihu.com/question/26393784/answer/513257548来源：知乎著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://hxlpub.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://hxlpub.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"golang之必知必会","slug":"go_base","date":"2022-01-09T04:47:30.000Z","updated":"2022-03-26T09:04:20.513Z","comments":true,"path":"2022/01/09/go_base/","link":"","permalink":"https://hxlpub.github.io/2022/01/09/go_base/","excerpt":"","text":"go简介 Go 是一个开源的编程语言，它能让构造简单、可靠且高效的软件变得容易。 特色 简洁、快速、安全 并行、有趣、开源 内存管理、数组安全、编译迅速 Go 语言最主要的特性： 自动垃圾回收 更丰富的内置类型 函数多返回值 错误处理 匿名函数和闭包 类型和接口 并发编程 反射 语言交互性 用途 Go 语言被设计成一门应用于搭载 Web 服务器，存储集群或类似用途的巨型中央服务器的系统编程语言。 对于高性能分布式系统领域而言，Go 语言无疑比大多数其它语言有着更高的开发效率。它提供了海量并行的支持，这对于游戏服务端的开发而言是再好不过了。 hello go 123456789101112131415161718package mainimport &quot;fmt&quot;func main()&#123; fmt.Println(&quot;hello go!!!&quot;)&#125;[root@192 go]# go run hello.go #go run 执行hello go!!![root@192 go]# go build hello.go #go build 编译生成二进制[root@192 go]# lltotal 1896-rwxr-xr-x. 1 root root 1937013 Mar 14 10:00 hello-rw-r--r--. 1 root root 70 Mar 14 09:59 hello.go[root@192 go]# ./hello hello go!!! 程序结构 包声明 引入包 函数 变量 语句 &amp; 表达式 注释 12345678package mainimport &quot;fmt&quot;func main() &#123;// 注意&#123; 不能在单独的行上，否则会报错 /* 这是我的第一个简单的程序 */ fmt.Println(&quot;Hello, World!&quot;)&#125; 第一行代码 package main 定义了包名。你必须在源文件中非注释的第一行指明这个文件属于哪个包，如：package main。package main表示一个可独立执行的程序，每个 Go 应用程序都包含一个名为 main 的包。 下一行 import “fmt” 告诉 Go 编译器这个程序需要使用 fmt 包（的函数，或其他元素），fmt 包实现了格式化 IO（输入/输出）的函数。 下一行 func main() 是程序开始执行的函数。main 函数是每一个可执行程序所必须包含的，一般来说都是在启动后第一个执行的函数（如果有 init() 函数则会先执行该函数）。 下一行 /…/ 是注释，在程序执行时将被忽略。单行注释是最常见的注释形式，你可以在任何地方使用以 // 开头的单行注释。多行注释也叫块注释，均已以 /* 开头，并以 */ 结尾，且不可以嵌套使用，多行注释一般用于包的文档描述或注释成块的代码片段。 下一行 fmt.Println(…) 可以将字符串输出到控制台，并在最后自动增加换行字符 \\n。使用 fmt.Print(“hello, world\\n”) 可以得到相同的结果。Print 和 Println 这两个函数也支持使用变量，如：fmt.Println(arr)。如果没有特别指定，它们会以默认的打印格式将变量 arr 输出到控制台。 当标识符（包括常量、变量、类型、函数名、结构字段等等）以一个大写字母开头，如：Group1，那么使用这种形式的标识符的对象就可以被外部包的代码所使用（客户端程序需要先导入这个包），这被称为导出（像面向对象语言中的 public）；标识符如果以小写字母开头，则对包外是不可见的，但是他们在整个包的内部是可见并且可用的（像面向对象语言中的 protected ）。 基础语法 Go 标记Go 程序可以由多个标记组成，可以是关键字，标识符，常量，字符串，符号。如以下 GO 语句由 6 个标记组成： 1fmt.Println(&quot;Hello, World!&quot;) 1 6 个标记是(每行一个)： 1234561. fmt2. .3. Println4. (5. &quot;Hello, World!&quot;6. ) 行分隔符在 Go 程序中，一行代表一个语句结束。每个语句不需要像 C 家族中的其它语言一样以分号 ; 结尾，因为这些工作都将由 Go 编译器自动完成。 如果你打算将多个语句写在同一行，它们则必须使用 ; 人为区分，但在实际开发中我们并不鼓励这种做法。 以下为两个语句： 12fmt.Println(&quot;Hello, World!&quot;)fmt.Println(&quot;菜鸟教程：runoob.com&quot;) 注释注释不会被编译，每一个包应该有相关注释。 单行注释是最常见的注释形式，你可以在任何地方使用以 // 开头的单行注释。多行注释也叫块注释，均已以 /* 开头，并以 */ 结尾。如： 12345// 单行注释/* Author by 菜鸟教程 我是多行注释 */ 标识符标识符用来命名变量、类型等程序实体。一个标识符实际上就是一个或是多个字母(AZ和az)数字(0~9)、下划线_组成的序列，但是第一个字符必须是字母或下划线而不能是数字。 以下是有效的标识符： 12mahesh kumar abc move_name a_123myname50 _temp j a23b9 retVal 以下是无效的标识符： 1ab（以数字开头） case（Go 语言的关键字） a+b（运算符是不允许的） 字符串连接Go 语言的字符串可以通过 + 实现： 实例12345package mainimport &quot;fmt&quot;func main() &#123; fmt.Println(&quot;Google&quot; + &quot;Runoob&quot;)&#125; 关键字下面列举了 Go 代码中会使用到的 25 个关键字或保留字： break default func interface select case defer go map struct chan else goto package switch const fallthrough if range type continue for import return var 除了以上介绍的这些关键字，Go 语言还有 36 个预定义标识符： append bool byte cap close complex complex64 complex128 uint16 copy false float32 float64 imag int int8 int16 uint32 int32 int64 iota len make new nil panic uint64 print println real recover string true uint uint8 uintptr 程序一般由关键字、常量、变量、运算符、类型和函数组成。 程序中可能会使用到这些分隔符：括号 ()，中括号 [] 和大括号 {}。 程序中可能会使用到这些标点符号：.、,、;、: 和 …。 Go 语言的空格Go 语言中变量的声明必须使用空格隔开，如： 1var age int; 语句中适当使用空格能让程序更易阅读。 无空格： 1fruit=apples+oranges; 在变量与运算符间加入空格，程序看起来更加美观，如： 1fruit = apples + oranges; 格式化字符串Go 语言中使用 fmt.Sprintf 格式化字符串并赋值给新串： 实例package main import ( “fmt”) 12345678func main() &#123; // %d 表示整型数字，%s 表示字符串 var stockcode=123 var enddate=&quot;2020-12-31&quot; var url=&quot;Code=%d&amp;endDate=%s&quot; var target_url=fmt.Sprintf(url,stockcode,enddate) fmt.Println(target_url)&#125; 输出结果为： 1Code=123&amp;endDate=2020-12-31 Go 可以使用 fmt.Sprintf 来格式化字符串，格式如下： 1fmt.Sprintf(格式化样式, 参数列表…) 格式化样式：字符串形式，格式化符号以 % 开头， %s 字符串格式，%d 十进制的整数格式。 参数列表：多个参数以逗号分隔，个数必须与格式化样式中的个数一一对应，否则运行时会报错。 Go 字符串格式化符号: 格 式 描 述 %v 按值的本来值输出 %+v 在 %v 基础上，对结构体字段名和值进行展开 %#v 输出 Go 语言语法格式的值 %T 输出 Go 语言语法格式的类型和值 %% 输出 % 本体 %b 整型以二进制方式显示 %o 整型以八进制方式显示 %d 整型以十进制方式显示 %x 整型以十六进制方式显示 %X 整型以十六进制、字母大写方式显示 %U Unicode 字符 %f 浮点数 %p 指针，十六进制方式显示 数据类型 在 Go 编程语言中，数据类型用于声明函数和变量。 数据类型的出现是为了把数据分成所需内存大小不同的数据，编程的时候需要用大数据的时候才需要申请大内存，就可以充分利用内存。 Go 语言按类别有以下几种数据类型： 序号 类型和描述 1 布尔型 布尔型的值只可以是常量 true 或者 false。一个简单的例子：var b bool = true。 2 数字类型 整型 int 和浮点型 float32、float64，Go 语言支持整型和浮点型数字，并且支持复数，其中位的运算采用补码。 3 字符串类型: 字符串就是一串固定长度的字符连接起来的字符序列。Go 的字符串是由单个字节连接起来的。Go 语言的字符串的字节使用 UTF-8 编码标识 Unicode 文本。 4 派生类型: 包括：(a) 指针类型（Pointer）(b) 数组类型(c) 结构化类型(struct)(d) Channel 类型(e) 函数类型(f) 切片类型(g) 接口类型（interface）(h) Map 类型 数字类型Go 也有基于架构的类型，例如：int、uint 和 uintptr。 序号 类型和描述 1 uint8 无符号 8 位整型 (0 到 255) 2 uint16 无符号 16 位整型 (0 到 65535) 3 uint32 无符号 32 位整型 (0 到 4294967295) 4 uint64 无符号 64 位整型 (0 到 18446744073709551615) 5 int8 有符号 8 位整型 (-128 到 127) 6 int16 有符号 16 位整型 (-32768 到 32767) 7 int32 有符号 32 位整型 (-2147483648 到 2147483647) 8 int64 有符号 64 位整型 (-9223372036854775808 到 9223372036854775807) 浮点型 序号 类型和描述 1 float32 IEEE-754 32位浮点型数 2 float64 IEEE-754 64位浮点型数 3 complex64 32 位实数和虚数 4 complex128 64 位实数和虚数 其他数字类型以下列出了其他更多的数字类型： 序号 类型和描述 1 byte 类似 uint8 2 rune 类似 int32 3 uint 32 或 64 位 4 int 与 uint 一样大小 5 uintptr 无符号整型，用于存放一个指针 变量 变量来源于数学，是计算机语言中能储存计算结果或能表示值抽象概念。 变量可以通过变量名访问。 Go 语言变量名由字母、数字、下划线组成，其中首个字符不能为数字。 声明变量的一般形式是使用 var 关键字： 1var identifier type 可以一次声明多个变量： 1var identifier1, identifier2 type 12345678910111213package mainimport &quot;fmt&quot;func main() &#123; var a string = &quot;Runoob&quot; fmt.Println(a) var b, c int = 1, 2 fmt.Println(b, c)&#125;以上实例输出结果为：Runoob1 2 变量声明第一种，指定变量类型，如果没有初始化，则变量默认为零值。 123456789101112131415161718192021222324var v_name v_typev_name = value零值就是变量没有做初始化时系统默认设置的值。package mainimport &quot;fmt&quot;func main() &#123; // 声明一个变量并初始化 var a = &quot;RUNOOB&quot; fmt.Println(a) // 没有初始化就为零值 var b int fmt.Println(b) // bool 零值为 false var c bool fmt.Println(c)&#125;以上实例执行结果为：RUNOOB0false 数值类型（包括complex64/128）为 0 布尔类型为 false 字符串为 **””**（空字符串） 以下几种类型为 nil： ```govar a *intvar a []intvar a map[string] intvar a chan intvar a func(string) intvar a error // error 是接口package mainimport “fmt”func main() {var i int var f float64 var b bool var s string fmt.Printf(&quot;%v %v %v %q\\n&quot;, i, f, b, s) }输出结果是：0 0 false “”12345**第二种，根据值自行判定变量类型。**```govar v_name = value 123456789package mainimport &quot;fmt&quot;func main() &#123; var d = true fmt.Println(d)&#125;输出结果是：true 第三种，如果变量已经使用 var 声明过了，再使用 *:=* 声明变量，就产生编译错误，格式： 1v_name := value 12var intVal int intVal :=1 // 这时候会产生编译错误，因为 intVal 已经声明，不需要重新声明 直接使用下面的语句即可： 12345intVal := 1 // 此时不会产生编译错误，因为有声明新的变量，因为 := 是一个声明语句intVal := 1 相等于：var intVal int intVal =1 多变量声明1234567891011121314//类型相同多个变量, 非全局变量var vname1, vname2, vname3 typevname1, vname2, vname3 = v1, v2, v3var vname1, vname2, vname3 = v1, v2, v3 // 和 python 很像,不需要显示声明类型，自动推断vname1, vname2, vname3 := v1, v2, v3 // 出现在 := 左侧的变量不应该是已经被声明过的，否则会导致编译错误// 这种因式分解关键字的写法一般用于声明全局变量var ( vname1 v_type1 vname2 v_type2) 123456789101112131415161718192021package mainvar x, y intvar ( // 这种因式分解关键字的写法一般用于声明全局变量 a int b bool)var c, d int = 1, 2var e, f = 123, &quot;hello&quot;//这种不带声明格式的只能在函数体中出现//g, h := 123, &quot;hello&quot;func main()&#123; g, h := 123, &quot;hello&quot; println(x, y, a, b, c, d, e, f, g, h)&#125;以上实例执行结果为：0 0 0 false 1 2 123 hello 123 hello 简短形式，使用 := 赋值操作符a := 50 或 b := false。 a 和 b 的类型（int 和 bool）将由编译器自动推断。 这是使用变量的首选形式，但是它只能被用在函数体内，而不可以用于全局变量的声明与赋值。使用操作符 := 可以高效地创建一个新的变量，称之为初始化声明。 注意事项如果在相同的代码块中，我们不可以再次对于相同名称的变量使用初始化声明，例如：a := 20 就是不被允许的，编译器会提示错误 no new variables on left side of :=，但是 a = 20 是可以的，因为这是给相同的变量赋予一个新的值。 如果你在定义变量 a 之前使用它，则会得到编译错误 undefined: a。 如果你声明了一个局部变量却没有在相同的代码块中使用它，同样会得到编译错误; 但是全局变量是允许声明但不使用的。 同一类型的多个变量可以声明在同一行，如： 1var a, b, c int 多变量可以在同一行进行赋值，如： 123var a, b intvar c stringa, b, c = 5, 7, &quot;abc&quot; 上面这行假设了变量 a，b 和 c 都已经被声明，否则的话应该这样使用： 1a, b, c := 5, 7, &quot;abc&quot; 右边的这些值以相同的顺序赋值给左边的变量，所以 a 的值是 5， b 的值是 7，c 的值是 “abc”。 这被称为 并行 或 同时 赋值。 如果你想要交换两个变量的值，则可以简单地使用 a, b = b, a，两个变量的类型必须是相同。 空白标识符 _ 也被用于抛弃值，如值 5 在：_, b = 5, 7 中被抛弃。 _ 实际上是一个只写变量，你不能得到它的值。这样做是因为 Go 语言中你必须使用所有被声明的变量，但有时你并不需要使用从一个函数得到的所有返回值。 并行赋值也被用于当一个函数返回多个返回值时，比如这里的 val 和错误 err 是通过调用 Func1 函数同时得到：val, err = Func1(var1)。 常量 常量是一个简单值的标识符，在程序运行时，不会被修改的量。 常量中的数据类型只可以是布尔型、数字型（整数型、浮点型和复数）和字符串型。 常量的定义格式： 1const identifier [type] = value 你可以省略类型说明符 [type]，因为编译器可以根据变量的值来推断其类型。 显式类型定义： const b string = &quot;abc&quot; 隐式类型定义： const b = &quot;abc&quot; 多个相同类型的声明可以简写为： 1const c_name1, c_name2 = value1, value2 12345678910111213141516171819package mainimport &quot;fmt&quot;func main() &#123; const LENGTH int = 10 const WIDTH int = 5 var area int const a, b, c = 1, false, &quot;str&quot; //多重赋值 area = LENGTH * WIDTH fmt.Printf(&quot;面积为 : %d&quot;, area) println() println(a, b, c) &#125;以上实例运行结果为：面积为 : 501 false str 常量还可以用作枚举： 12345const ( Unknown = 0 Female = 1 Male = 2) 常量可以用len(), cap(), unsafe.Sizeof()函数计算表达式的值。常量表达式中，函数必须是内置函数，否则编译不过： 实例package main import “unsafe”const ( a = “abc” b = len(a) c = unsafe.Sizeof(a)) func main(){ println(a, b, c)} 以上实例运行结果为： 1abc 3 16 iotaiota，特殊常量，可以认为是一个可以被编译器修改的常量。 iota 在 const关键字出现时将被重置为 0(const 内部的第一行之前)，const 中每新增一行常量声明将使 iota 计数一次(iota 可理解为 const 语句块中的行索引)。 iota 可以被用作枚举值： 12345const ( a = iota b = iota c = iota) 第一个 iota 等于 0，每当 iota 在新的一行被使用时，它的值都会自动加 1；所以 a=0, b=1, c=2 可以简写为如下形式： 12345const ( a = iota b c) 123456789101112131415161718192021package mainimport &quot;fmt&quot;func main() &#123; const ( a = iota //0 b //1 c //2 d = &quot;ha&quot; //独立值，iota += 1 e //&quot;ha&quot; iota += 1 f = 100 //iota +=1 g //100 iota +=1 h = iota //7,恢复计数 i //8 ) fmt.Println(a,b,c,d,e,f,g,h,i)&#125;以上实例运行结果为：0 1 2 ha ha 100 100 7 8 运算符 注意：go没有三目运算符 优先级 分类 运算符 结合性 1 逗号运算符 , 从左到右 2 赋值运算符 =、+=、-=、*=、/=、 %=、 &gt;&gt;=、 &lt;&lt;=、&amp;=、^=、|= 从右到左 3 逻辑或 || 从左到右 4 逻辑与 &amp;&amp; 从左到右 5 按位或 | 从左到右 6 按位异或 ^ 从左到右 7 按位与 &amp; 从左到右 8 相等/不等 ==、!= 从左到右 9 关系运算符 &lt;、&lt;=、&gt;、&gt;= 从左到右 10 位移运算符 &lt;&lt;、&gt;&gt; 从左到右 11 加法/减法 +、- 从左到右 12 乘法/除法/取余 *（乘号）、/、% 从左到右 13 单目运算符 + 、-、 !、 ~、 (type)*、 &amp; sizeof （待确认） 从右到左 14 后缀运算符 ( )、[ ]、-&gt;、.、++、– 从左到右 http://c.biancheng.net/view/5559.html 条件语句 Go 语言提供了以下几种条件判断语句： 语句 描述 if 语句 if 语句 由一个布尔表达式后紧跟一个或多个语句组成。 if…else 语句 if 语句 后可以使用可选的 else 语句, else 语句中的表达式在布尔表达式为 false 时执行。 if 嵌套语句 你可以在 if 或 else if 语句中嵌入一个或多个 if 或 else if 语句。 switch 语句 switch 语句用于基于不同条件执行不同动作。 select 语句 select 语句类似于 switch 语句，但是select会随机执行一个可运行的case。如果没有case可运行，它将阻塞，直到有case可运行。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798991001011021031041051061071081091101111121131141151161171181191201211221231241251261271281291301311.if if 布尔表达式 &#123; /* 如果条件为 true 则执行以下语句 */ &#125;2.if elseif 布尔表达式 &#123; /* 如果条件为 true 则执行以下语句 */&#125; else &#123; /* 如果条件为 false 则执行以下语句 */ &#125;3.if嵌套 if 布尔表达式1 &#123; /* if 条件语句为 true 执行 */ if 布尔表达式2 &#123; /* if 条件语句为 true 执行 */ &#125; &#125;4.switchswitch var1 &#123; case val1: ... case val2: ... default: ...&#125;/* 定义局部变量 */ var grade string = &quot;B&quot; var marks int = 90 switch marks &#123; case 90: grade = &quot;A&quot; case 80: grade = &quot;B&quot; case 50,60,70 : grade = &quot;C&quot; default: grade = &quot;D&quot; &#125; switch &#123; case grade == &quot;A&quot; : fmt.Printf(&quot;优秀!\\n&quot; ) case grade == &quot;B&quot;, grade == &quot;C&quot; : fmt.Printf(&quot;良好\\n&quot; ) case grade == &quot;D&quot; : fmt.Printf(&quot;及格\\n&quot; ) case grade == &quot;F&quot;: fmt.Printf(&quot;不及格\\n&quot; ) default: fmt.Printf(&quot;差\\n&quot; ); &#125;5.Type Switchswitch 语句还可以被用于 type-switch 来判断某个 interface 变量中实际存储的变量类型。Type Switch 语法格式如下：switch x.(type)&#123; case type: statement(s); case type: statement(s); /* 你可以定义任意个数的case */ default: /* 可选 */ statement(s);&#125;var x interface&#123;&#125; switch i := x.(type) &#123; case nil: fmt.Printf(&quot; x 的类型 :%T&quot;,i) case int: fmt.Printf(&quot;x 是 int 型&quot;) case float64: fmt.Printf(&quot;x 是 float64 型&quot;) case func(int) float64: fmt.Printf(&quot;x 是 func(int) 型&quot;) case bool, string: fmt.Printf(&quot;x 是 bool 或 string 型&quot; ) default: fmt.Printf(&quot;未知型&quot;) &#125; 6.fallthrough使用 fallthrough 会强制执行后面的 case 语句，fallthrough 不会判断下一条 case 的表达式结果是否为 true。func main()&#123; switch &#123; case false: fmt.Println(&quot;1、case 条件语句为 false&quot;) fallthrough case true: fmt.Println(&quot;2、case 条件语句为 true&quot;) fallthrough case false: fmt.Println(&quot;3、case 条件语句为 false&quot;) fallthrough case true: fmt.Println(&quot;4、case 条件语句为 true&quot;) case false: fmt.Println(&quot;5、case 条件语句为 false&quot;) fallthrough default: fmt.Println(&quot;6、默认 case&quot;) &#125;&#125;以上代码执行结果为：2、case 条件语句为 true3、case 条件语句为 false4、case 条件语句为 true从以上代码输出的结果可以看出：switch 从第一个判断表达式为 true 的 case 开始执行，如果 case 带有 fallthrough，程序会继续执行下一条 case，且它不会去判断下一个 case 的表达式是否为 true。7.select select是 Go 中的一个控制结构，类似于用于通信的 switch 语句。每个 case 必须是一个通信操作，要么是发送要么是接收。select 随机执行一个可运行的 case。如果没有 case 可运行，它将阻塞，直到有 case 可运行。一个默认的子句应该总是可运行的。select 语句的语法如下：select &#123; case communication clause : statement(s); case communication clause : statement(s); /* 你可以定义任意数量的 case */ default : /* 可选 */ statement(s);&#125;以下描述了 select 语句的语法：每个 case 都必须是一个通信所有 channel 表达式都会被求值所有被发送的表达式都会被求值如果任意某个通信可以进行，它就执行，其他被忽略。如果有多个 case 都可以运行，Select 会随机公平地选出一个执行。其他不会执行。否则：1.如果有 default 子句，则执行该语句。2.如果没有 default 子句，select 将阻塞，直到某个通信可以运行；Go 不会重新对 channel 或值进行求值。以上代码执行结果为：no communication 循环语句 函数 匿名函数https://www.jianshu.com/p/91140fdd6e91 变量作用域 数组 指针 结构体 注意结构体标签如，Age int json:&quot;age,omitempty&quot; https://www.cnblogs.com/liyutian/p/10050320.html 切片 Go 语言切片是对数组的抽象。 Go 数组的长度不可改变，在特定场景中这样的集合就不太适用，Go 中提供了一种灵活，功能强悍的内置类型切片(“动态数组”)，与数组相比切片的长度是不固定的，可以追加元素，在追加时可能使切片的容量增大。 定义切片： 你可以声明一个未指定大小的数组来定义切片： 1var identifier []type 切片不需要说明长度。 或使用 make() 函数来创建切片: 123var slice1 []type = make([]type, len)也可以简写为slice1 := make([]type, len) 也可以指定容量，其中 capacity 为可选参数。 1make([]T, length, capacity) 这里 len 是数组的长度并且也是切片的初始长度。 切片初始化1s :=[] int &#123;1,2,3 &#125; 直接初始化切片，**[]** 表示是切片类型，**{1,2,3}** 初始化值依次是 1,2,3，其 cap=len=3。 1s := arr[:] 初始化切片 s，是数组 arr 的引用。 1s := arr[startIndex:endIndex] 将 arr 中从下标 startIndex 到 endIndex-1 下的元素创建为一个新的切片。 1s := arr[startIndex:] 默认 endIndex 时将表示一直到arr的最后一个元素。 1s := arr[:endIndex] 默认 startIndex 时将表示从 arr 的第一个元素开始。 1s1 := s[startIndex:endIndex] 通过切片 s 初始化切片 s1。 1s :=make([]int,len,cap) 通过内置函数 make() 初始化切片s，**[]int** 标识为其元素类型为 int 的切片。 切片是可索引的，并且可以由 len() 方法获取长度。 切片提供了计算容量的方法 cap() 可以测量切片最长可以达到多少。 以下为具体实例： 实例package main import “fmt” func main() { var numbers = make([]int,3,5) printSlice(numbers)} func printSlice(x []int){ fmt.Printf(“len=%d cap=%d slice=%v\\n“,len(x),cap(x),x)} 以上实例运行输出结果为: 1len=3 cap=5 slice=[0 0 0] 空(nil)切片一个切片在未初始化之前默认为 nil，长度为 0，实例如下： 实例package main import “fmt” func main() { var numbers []int printSlice(numbers) if(numbers == nil){ fmt.Printf(“切片是空的”) }} func printSlice(x []int){ fmt.Printf(“len=%d cap=%d slice=%v\\n“,len(x),cap(x),x)} 以上实例运行输出结果为: 12len=0 cap=0 slice=[]切片是空的 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package mainimport &quot;fmt&quot;func main() &#123; /* 创建切片 */ numbers := []int&#123;0,1,2,3,4,5,6,7,8&#125; printSlice(numbers) /* 打印原始切片 */ fmt.Println(&quot;numbers ==&quot;, numbers) /* 打印子切片从索引1(包含) 到索引4(不包含)*/ fmt.Println(&quot;numbers[1:4] ==&quot;, numbers[1:4]) /* 默认下限为 0*/ fmt.Println(&quot;numbers[:3] ==&quot;, numbers[:3]) /* 默认上限为 len(s)*/ fmt.Println(&quot;numbers[4:] ==&quot;, numbers[4:]) numbers1 := make([]int,0,5) printSlice(numbers1) /* 打印子切片从索引 0(包含) 到索引 2(不包含) */ number2 := numbers[:2] printSlice(number2) /* 打印子切片从索引 2(包含) 到索引 5(不包含) */ number3 := numbers[2:5] printSlice(number3)&#125;func printSlice(x []int)&#123; fmt.Printf(&quot;len=%d cap=%d slice=%v\\n&quot;,len(x),cap(x),x)&#125;执行以上代码输出结果为：len=9 cap=9 slice=[0 1 2 3 4 5 6 7 8]numbers == [0 1 2 3 4 5 6 7 8]numbers[1:4] == [1 2 3]numbers[:3] == [0 1 2]numbers[4:] == [4 5 6 7 8]len=0 cap=5 slice=[]len=2 cap=9 slice=[0 1]len=3 cap=7 slice=[2 3 4] append() 和 copy() 函数如果想增加切片的容量，我们必须创建一个新的更大的切片并把原分片的内容都拷贝过来。 下面的代码描述了从拷贝切片的 copy 方法和向切片追加新元素的 append 方法。 1234567891011121314151617181920212223242526272829303132333435363738package mainimport &quot;fmt&quot;func main() &#123; var numbers []int printSlice(numbers) /* 允许追加空切片 */ numbers = append(numbers, 0) printSlice(numbers) /* 向切片添加一个元素 */ numbers = append(numbers, 1) printSlice(numbers) /* 同时添加多个元素 */ numbers = append(numbers, 2,3,4) printSlice(numbers) /* 创建切片 numbers1 是之前切片的两倍容量*/ numbers1 := make([]int, len(numbers), (cap(numbers))*2) /* 拷贝 numbers 的内容到 numbers1 */ copy(numbers1,numbers) printSlice(numbers1) &#125;func printSlice(x []int)&#123; fmt.Printf(&quot;len=%d cap=%d slice=%v\\n&quot;,len(x),cap(x),x)&#125;以上代码执行输出结果为：len=0 cap=0 slice=[]len=1 cap=1 slice=[0]len=2 cap=2 slice=[0 1]len=5 cap=6 slice=[0 1 2 3 4]len=5 cap=12 slice=[0 1 2 3 4] 范围 Map（集合） 递归函数 类型转换 接口 错误处理 并发 channel 参考： https://www.runoob.com/w3cnote/go-channel-intro.html Channel是Go中的一个核心类型，你可以把它看成一个管道，通过它并发核心单元就可以发送或者接收数据进行通讯(communication)。 它的操作符是箭头 &lt;- 。 12ch &lt;- v // 发送值v到Channel ch中v := &lt;-ch // 从Channel ch中接收数据，并将数据赋值给v (箭头的指向就是数据的流向) 就像 map 和 slice 数据类型一样, channel必须先创建再使用: 1ch := make(chan int) channel类型 Channel类型的定义格式如下： 1ChannelType = ( &quot;chan&quot; | &quot;chan&quot; &quot;&lt;-&quot; | &quot;&lt;-&quot; &quot;chan&quot; ) ElementType . 它包括三种类型的定义。可选的&lt;-代表channel的方向。如果没有指定方向，那么Channel就是双向的，既可以接收数据，也可以发送数据。 123chan T // 可以接收和发送类型为 T 的数据chan&lt;- float64 // 只可以用来发送 float64 类型的数据&lt;-chan int // 只可以用来接收 int 类型的数据 &lt;-总是优先和最左边的类型结合。 1234chan&lt;- chan int // 等价 chan&lt;- (chan int)chan&lt;- &lt;-chan int // 等价 chan&lt;- (&lt;-chan int)&lt;-chan &lt;-chan int // 等价 &lt;-chan (&lt;-chan int)chan (&lt;-chan int) 使用make初始化Channel,并且可以设置容量: 1make(chan int, 100) 容量(capacity)代表Channel容纳的最多的元素的数量，代表Channel的缓存的大小。如果没有设置容量，或者容量设置为0, 说明Channel没有缓存，只有sender和receiver都准备好了后它们的通讯(communication)才会发生(Blocking)。如果设置了缓存，就有可能不发生阻塞， 只有buffer满了后 send才会阻塞， 而只有缓存空了后receive才会阻塞。一个nil channel不会通信。 可以通过内建的close方法可以关闭Channel。 你可以在多个goroutine从/往 一个channel 中 receive/send 数据, 不必考虑额外的同步措施。 Channel可以作为一个先入先出(FIFO)的队列，接收的数据和发送的数据的顺序是一致的。 channel的 receive支持 multi-valued assignment，如 1v, ok := &lt;-ch 它可以用来检查Channel是否已经被关闭了。 send语句send语句用来往Channel中发送数据， 如ch &lt;- 3。它的定义如下: 12SendStmt = Channel &quot;&lt;-&quot; Expression .Channel = Expression . 在通讯(communication)开始前channel和expression必选先求值出来(evaluated)，比如下面的(3+4)先计算出7然后再发送给channel。 12345c := make(chan int)defer close(c)go func() &#123; c &lt;- 3 + 4 &#125;()i := &lt;-cfmt.Println(i) send被执行前(proceed)通讯(communication)一直被阻塞着。如前所言，无缓存的channel只有在receiver准备好后send才被执行。如果有缓存，并且缓存未满，则send会被执行。 往一个已经被close的channel中继续发送数据会导致run-time panic。 往nil channel中发送数据会一致被阻塞着。 ​ receive 操作符&lt;-ch用来从channel ch中接收数据，这个表达式会一直被block,直到有数据可以接收。 从一个nil channel中接收数据会一直被block。 从一个被close的channel中接收数据不会被阻塞，而是立即返回，接收完已发送的数据后会返回元素类型的零值(zero value)。 如前所述，你可以使用一个额外的返回参数来检查channel是否关闭。 123x, ok := &lt;-chx, ok = &lt;-chvar x, ok = &lt;-ch 如果OK 是false，表明接收的x是产生的零值，这个channel被关闭了或者为空。 blocking 默认情况下，发送和接收会一直阻塞着，直到另一方准备好。这种方式可以用来在gororutine中进行同步，而不必使用显示的锁或者条件变量。 如官方的例子中x, y := &lt;-c, &lt;-c这句会一直等待计算结果发送到channel中。 12345678910111213141516import &quot;fmt&quot;func sum(s []int, c chan int) &#123; sum := 0 for _, v := range s &#123; sum += v &#125; c &lt;- sum // send sum to c&#125;func main() &#123; s := []int&#123;7, 2, 8, -9, 4, 0&#125; c := make(chan int) go sum(s[:len(s)/2], c) go sum(s[len(s)/2:], c) x, y := &lt;-c, &lt;-c // receive from c fmt.Println(x, y, x+y)&#125; Buffered channels Range select timeout Timer and Ticker close 同步 开发工具 其他： 符号… https://blog.csdn.net/jeffrey11223/article/details/79166724 package作用以及定义 https://www.jianshu.com/p/df33ee0d51ce go test 测试","categories":[{"name":"golang","slug":"golang","permalink":"https://hxlpub.github.io/categories/golang/"}],"tags":[{"name":"golang","slug":"golang","permalink":"https://hxlpub.github.io/tags/golang/"}]},{"title":"golang之编码规范","slug":"go_base_coding_rule","date":"2022-01-09T04:47:30.000Z","updated":"2022-03-26T09:06:21.612Z","comments":true,"path":"2022/01/09/go_base_coding_rule/","link":"","permalink":"https://hxlpub.github.io/2022/01/09/go_base_coding_rule/","excerpt":"","text":"","categories":[{"name":"golang","slug":"golang","permalink":"https://hxlpub.github.io/categories/golang/"}],"tags":[{"name":"golang","slug":"golang","permalink":"https://hxlpub.github.io/tags/golang/"}]},{"title":"Makefile","slug":"Makefile","date":"2021-11-09T11:56:07.000Z","updated":"2022-03-26T09:11:58.775Z","comments":true,"path":"2021/11/09/Makefile/","link":"","permalink":"https://hxlpub.github.io/2021/11/09/Makefile/","excerpt":"","text":"​","categories":[{"name":"编译","slug":"编译","permalink":"https://hxlpub.github.io/categories/%E7%BC%96%E8%AF%91/"}],"tags":[{"name":"Makefile","slug":"Makefile","permalink":"https://hxlpub.github.io/tags/Makefile/"}]},{"title":"c 的几个重要特性","slug":"c","date":"2021-11-06T03:55:07.000Z","updated":"2022-03-26T09:08:39.548Z","comments":true,"path":"2021/11/06/c/","link":"","permalink":"https://hxlpub.github.io/2021/11/06/c/","excerpt":"","text":"1.本篇目的：着重介绍C的几个重要特性一级底层原理 2.本篇的结构 第一部分：几个重要的特性与底层原理 第二部分：结合开源项目特性应用 第三部分：良好的编码风格（附录） 第一部分：几个重要的特性与底层原理 预处理器几个特性 #include指令：文件包含，该指令所在的行都将被替换为由文件名指定的文件的内容，一种将所有声明捆绑在一起的较好的办法，保证所有的源文件有相同的定义与变量声明 ​ #include “文件” ：先在源文件所在位置查找该文件，如果在该位置未找到，再根据相应规则查找 ​ #include &lt;文件&gt; ：根据相应规则查找 #define指令：宏替换，#define 名字 替换文本 宏：将函数定义为宏可避免调用函数时所需的运行时开销 变量 类型 作用域 存储位置 生命周期 特点 static 所在文件（static 外部变量）、 所在函数（static 局部变量） 定义后一直占据存储空间 只被初始化一次（程序执行前），初始化表达式是常量表达式，没有初始化表达式的元素被初始化为0 register 局部变量 、函数形参 寄存器 程序更小，执行速度更快 外部变量external 只被初始化一次（程序执行前），初始化表达式必须是常量表达式，没有初始化表达式的元素被初始化为0; 局部变量 函数内部 函数被调用期间 每次进入函数或程序块都初始化，没有初始化表达式的元素被初始化为0 指针 ​ 运算符&amp;：取地址，只能应用于内存中对象，即变量与数组元素，不能作用与表达式、常量、或register变量​ 运算符：间接寻址或间接引用运算符，作用于指针时，将访问指针所指向的对象。​ &amp;、优先级高于算术运算符​ 指针变量可以相互赋值，指向相同的对象 1）指针与数组 ： ​ 一般，指针编写的程序比用数组下标编写的程序执行速度快​ 一个通过数组和下标实现的表达式可等价地通过指针和偏移量实现 ​ char s[] == char *s 、&amp;a[2] == a+2 （a数组） 2）特性 某些情况下对指针进行比较运算（如指针p、q指向同一个数组的成员） 指针可以和整数相加或相减 指针的算术运算具有一致性：所有的指针运算都会自动考虑它所指向的对象的长度 有效的指针运算： 相同类型指针之间赋值运算 指针同整数之间的加法减法 指向相同数组中元素的两个指针间的减法和比较运算 指针赋值为0或指针与0之间的比较运算 3）指针数组、指针的指针 如char *lineptr[10] 初始化：如，static char *name[] = {“xiaoming”,”xiaoqiang”} 指针数组优点：数组的每一个元素的长度可以不同 4)函数指针 K&amp;R P99 运算符优先级 1）优先级1：数组下标[]，圆括号( )，成员选择（对象）.，成员选择（指针）-&gt; 结合方向为左到右 2）优先级2：负号运算符-，强制类型转换，自增运算符++，自减运算符–，取值运算符，取地址运算符&amp;，逻辑非运算符！，按位取反运算符~，长度运算sizeof符，结合方向为右到左 3）优先级3：除/，乘*，余数%，结合方向为左到右 4）优先级4：加+，减-，结合方向为左到右 5）优先级5：左移&lt;&lt;，右移&gt;&gt;，结合方向为左到右 6）优先级6：大于&gt;，大于等于&gt;=，小于&lt;，小于等于&lt;=，结合方向为左到右 7）优先级7：等于==，不等于!=，结合方向为左到右 8）优先级8：级别先后为，按位与&amp;，按位异或^，按位或| ，逻辑与&amp;&amp;，逻辑或|| 条件运算符?:，注意得是条件运算结合方向为右到左 9）优先级9：赋值运算符=，除后赋值/=，乘后赋值*=，取模后赋值%=，加后赋值+=，减后赋值-=，左移后赋值&lt;&lt;=，右移后赋值&gt;&gt;=，按位与后赋值&amp;=，按位异或后赋值^=，按位或后赋值|=，结合方向为右到左 结构 struct point { ​ int x; ​ int y; }; 声明：struct {int x,int y} x,y,z; #分配存储空间 ​ struct point pt; 初始化： ​ struct point maxpt = {320, 200}; 成员：maxpt.x ​ maxpt.y 嵌套： ​ struct rect { ​ struct point pt1; ​ struct point pt2; ​ }; ​ struct rect screen; ​ 成员： screen.pt1.x 合法操作： ​ 1.作为一个整体赋值和赋值 ​ 2.通过&amp;取地址 ​ 3.访问其成员 结构指针： ​ struct point *ptrstr; ​ ptrstr -&gt; x 结构数组 ​ struct key {​ char *word;​ int count; &#125; keytab[] = &#123; &#123; &quot;auto&quot;, 0 &#125;, &#123; &quot;break&quot;, 0 &#125;, &#123; &quot;case&quot;, 0 &#125; ​ } 结构指针 ​ 关键字统计 自引用结构 ​ K$R P116 ex:统计输入所有单词出现频次（二叉树） 表查找 类型定义（typedef） 联合 位字段 ​ 命令行参数 123456789101112131415#include &lt;stdio.h&gt;#include &lt;string.h&gt;int main(int argc, char *argv[] )&#123; #./test -x 注意优先级顺序 printf(&quot;%s\\n&quot;,argv[0]);#./test printf(&quot;%c\\n&quot;,(*++argv)[0]);#- argv指向argv[1] printf(&quot;%c\\n&quot;,*++argv[0]);#x,先与[]结合,所以依然指向argv[1] printf(&quot;%d\\n&quot;,argc);#2&#125;~ 运算符集合 控制流语句 标准库 ​ 输入输出：printf (“%d”,i)、scanf(“%d”,&amp;i) ​ 文件访问： ​ 1.打开文件，返回文件指针 ​ 123FILE *fp;FILE *fopen(char *name,char *mode) fp = fopen(name,mode) ​ 2.文件读写 ​ int getc(FILE *fp) ​ int putc(FILE *fp) ​ #define getchar() getc(stdin)​ #define putchar(c) putc((c), stdout) ​ int fscanf(FILE *fp, char *format, …)​ int fprintf(FILE *fp, char *format, …) ​ 3.关闭文件 ​ int fclose (FILE *fp) ​ 错误处理 ​ stderr 和exit ​ fprintf(stderr, “%s: can’t open %s\\n”,prog, *argv); ​ int ferror（FILE *fp）#若流fp中出错，则函数返回一个非0值 ​ int feof(FILE *fp) #如果指定的文件到达文件结尾，返回一个非0值 ​ 行输入行输出 ​ char *fgets(char *line, int maxline, FILE *fp) #读文件一行到line ​ int fputs(char *line, FILE *fp)#写line到文件 ​ 其他函数 ​ UNIX系统接口 系统调用：操作系统内的函数，实现标准库函数，不同的操作系统实现其标准库函数的方式和方法不同 read、write#输入输出 int n_read = read(int fd, char *buf, int n);int n_written = write(int fd, char *buf, int n); open、create#读写之前显式打开文件，open打开已存在文件，如果打开一个不存在文件报错，而create创建新文件或覆盖已有旧文件 #flags ：O_RDONLY、O_WRONLY、O_RDWR，perms：权限， int fd;int open(char *name, int flags, int perms);fd = open(name, flags, perms); int creat(char *name, int perms);fd = creat(name, perms); close、unlink# lseek#随机访问，不实际读写数据 long lseek(int fd, long offset, int origin); 第二部分：结合开源项目特性应用 第三部分：良好的编码风格（附录） 正确缩进 适当空格 运算符两边各加一个空格字符","categories":[{"name":"c","slug":"c","permalink":"https://hxlpub.github.io/categories/c/"}],"tags":[{"name":"c","slug":"c","permalink":"https://hxlpub.github.io/tags/c/"}]},{"title":"cplusplus","slug":"cplusplus","date":"2021-11-06T03:55:07.000Z","updated":"2022-03-26T09:00:25.351Z","comments":true,"path":"2021/11/06/cplusplus/","link":"","permalink":"https://hxlpub.github.io/2021/11/06/cplusplus/","excerpt":"","text":"一、复合类型 ​","categories":[{"name":"cplusplus","slug":"cplusplus","permalink":"https://hxlpub.github.io/categories/cplusplus/"}],"tags":[{"name":"cplusplus","slug":"cplusplus","permalink":"https://hxlpub.github.io/tags/cplusplus/"}]},{"title":"hexo搭建博客","slug":"hexo_build_blog","date":"2021-09-15T13:08:37.000Z","updated":"2022-03-26T08:28:47.664Z","comments":true,"path":"2021/09/15/hexo_build_blog/","link":"","permalink":"https://hxlpub.github.io/2021/09/15/hexo_build_blog/","excerpt":"","text":"2021-10-21–评论系统上线啦！！！ 1.点击页面小爱心","categories":[{"name":"Hexo","slug":"Hexo","permalink":"https://hxlpub.github.io/categories/Hexo/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://hxlpub.github.io/tags/Hexo/"}]},{"title":"golang实现tcp协议","slug":"go_tcp","date":"2021-09-15T07:42:30.000Z","updated":"2022-03-26T08:28:36.809Z","comments":true,"path":"2021/09/15/go_tcp/","link":"","permalink":"https://hxlpub.github.io/2021/09/15/go_tcp/","excerpt":"","text":"1、client端client.go123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475//tcpclient 为client.go所在的上一层目录package tcpclientimport ( &quot;net&quot; &quot;fmt&quot; //&quot;io/ioutil&quot; &quot;strconv&quot; //&quot;../log&quot; //&quot;strings&quot; //&quot;bytes&quot; //&quot;encoding/xml&quot;)//组装tcp请求func RequestMsg(serialNum string, randomNum string, toAddr string, fromAddr string) string &#123; body := &quot;&lt;?xml version=\\&quot;1.0\\&quot;?&gt;\\r\\n&quot; + &quot;&lt;Config&gt;\\r\\n&quot; + &quot;&lt;CmdType&gt;ACTIVE&lt;/CmdType&gt;\\r\\n&quot; + &quot;&lt;CmdInfo&gt;GetActiveInfo&lt;/CmdInfo&gt;\\r\\n&quot; + &quot;&lt;SerialNumInfo&gt;\\r\\n&quot; + &quot;&lt;SerialNum&gt;&quot; + serialNum + &quot;&lt;/SerialNum&gt;\\r\\n&quot; + &quot;&lt;/SerialNumInfo&gt;\\r\\n&quot; + &quot;&lt;/Config&gt;&quot; head := &quot;HIK-PRODUCT\\r\\n&quot; + &quot;Via:HIKSTOR/1.0/TCP\\r\\n&quot; + &quot;From:&quot; + fromAddr + &quot;\\r\\n&quot; + &quot;To:&quot; + toAddr + &quot;\\r\\n&quot; + &quot;Call-ID:&quot; + randomNum + &quot;\\r\\n&quot; + &quot;Content-Type:xml\\r\\n&quot; + &quot;Content-Length:&quot; + strconv.Itoa(len(body)) + &quot;\\r\\n\\r\\n&quot; return head + body //return body&#125;//向server端发起请求func GetBomInfoFromThirdServ(serialNum string,randomNum string, toAddr string, fromAddr string) (string,error) &#123; //主动发起连接请求 conn,err :=net.Dial(&quot;tcp&quot;,&quot;10.192.44.183:35004&quot;) if err != nil &#123; fmt.Println(&quot;dial err&quot;,err) return &quot;&quot;, err &#125; defer conn.Close() //向服务端发送请求 reqmsg := RequestMsg(serialNum,randomNum,toAddr,fromAddr) _, err = conn.Write([]byte(reqmsg)) if err != nil &#123; fmt.Println(&quot;send err=&quot;, err) //出错退出 return &quot;&quot;,err &#125; //接收响应 buf := make([]byte, 1024) //response, err :=ioutil.ReadAll(conn) //if err != nil &#123; // fmt.Println(&quot;rec err&quot;,err) // return &quot;&quot;, err //&#125; n, err :=conn.Read(buf) //fmt.Println(&quot;n=&quot;, n) if err != nil &#123; fmt.Println(&quot;服务器read err=&quot;, err) //出错退出 return &quot;&quot;,err &#125; return string(buf[:n-1]),nil //return buf,nil &#125; 2、server端server.go","categories":[{"name":"golang","slug":"golang","permalink":"https://hxlpub.github.io/categories/golang/"}],"tags":[{"name":"golang","slug":"golang","permalink":"https://hxlpub.github.io/tags/golang/"}]},{"title":"Python之必知必会","slug":"Python","date":"2021-09-14T09:26:07.000Z","updated":"2022-04-02T03:18:34.938Z","comments":true,"path":"2021/09/14/Python/","link":"","permalink":"https://hxlpub.github.io/2021/09/14/Python/","excerpt":"","text":"环境配置 import 时找不到模块，修改python sys.path 12&gt;&gt;&gt; import sys&gt;&gt;&gt; sys.path.append(&#x27;/home/daos/site_scons&#x27;) 基础语法 编码 默认情况下，Python 3 源码文件以 UTF-8 编码，所有字符串都是 unicode 字符串。 当然你也可以为源码文件指定不同的编码： 1# -*- coding: cp-1252 -*- 标识符 第一个字符必须是字母表中字母或下划线 _ 。 标识符的其他的部分由字母、数字和下划线组成。 标识符对大小写敏感。 在 Python 3 中，可以用中文作为变量名，非 ASCII 标识符也是允许的了。 保留字 保留字即关键字，我们不能把它们用作任何标识符名称。Python 的标准库提供了一个 keyword 模块，可以输出当前版本的所有关键字： 12345&gt;&gt;&gt; import keyword&gt;&gt;&gt; keyword.kwlist[&#x27;False&#x27;, &#x27;None&#x27;, &#x27;True&#x27;, &#x27;__peg_parser__&#x27;, &#x27;and&#x27;, &#x27;as&#x27;, &#x27;assert&#x27;, &#x27;async&#x27;, &#x27;await&#x27;, &#x27;break&#x27;, &#x27;class&#x27;, &#x27;continue&#x27;, &#x27;def&#x27;, &#x27;del&#x27;, &#x27;elif&#x27;, &#x27;else&#x27;, &#x27;except&#x27;, &#x27;finally&#x27;, &#x27;for&#x27;, &#x27;from&#x27;, &#x27;global&#x27;, &#x27;if&#x27;, &#x27;import&#x27;, &#x27;in&#x27;, &#x27;is&#x27;, &#x27;lambda&#x27;, &#x27;nonlocal&#x27;, &#x27;not&#x27;, &#x27;or&#x27;, &#x27;pass&#x27;, &#x27;raise&#x27;, &#x27;return&#x27;, &#x27;try&#x27;, &#x27;while&#x27;, &#x27;with&#x27;, &#x27;yield&#x27;]&gt;&gt;&gt; 注释 123456789101112# 单行注释 #print (&quot;Hello, Python!&quot;) # 第二个注释、# 多行注释 &#x27;&#x27;&#x27;&#x27;注释内容&#x27;&#x27;&#x27; 和&quot;&quot;&quot;注释内容&quot;&quot;&quot;&#x27;&#x27;&#x27;第三注释第四注释&#x27;&#x27;&#x27; &quot;&quot;&quot;第五注释第六注释&quot;&quot;&quot; 行与缩进 python最具特色的就是使用缩进来表示代码块，不需要使用大括号 {} 。 缩进的空格数是可变的，但是同一个代码块的语句必须包含相同的缩进空格数。 12345678910111213if True: print (&quot;Answer&quot;) print (&quot;True&quot;)else: print (&quot;Answer&quot;) print (&quot;False&quot;) # 缩进不一致，会导致运行错误root@192 python]# python test.py File &quot;/home/tests/python/test.py&quot;, line 14 print (&quot;False&quot;) ^IndentationError: unindent does not match any outer indentation level 多行语句 Python 通常是一行写完一条语句，但如果语句很长，我们可以使用反斜杠 ** 来实现多行语句，例如： 123total = item_one + \\ item_two + \\ item_three 在 [], {}, 或 () 中的多行语句，不需要使用反斜杠 ****，例如： 12total = [&#x27;item_one&#x27;, &#x27;item_two&#x27;, &#x27;item_three&#x27;, &#x27;item_four&#x27;, &#x27;item_five&#x27;] 数字类型 int (整数), 如 1, 只有一种整数类型 int，表示为长整型，没有 python2 中的 Long。 bool (布尔), 如 True。 float (浮点数), 如 1.23、3E-2 complex (复数), 如 1 + 2j、 1.1 + 2.2j 字符串 Python 中单引号 ‘ 和双引号 “ 使用完全相同。 使用三引号(‘’’ 或 “””)可以指定一个多行字符串。 转义符 ****。 反斜杠可以用来转义，使用 r 可以让反斜杠不发生转义。 如 r”this is a line with \\n” 则 \\n 会显示，并不是换行。 按字面意义级联字符串，如 “this “ “is “ “string” 会被自动转换为 this is string。 字符串可以用 + 运算符连接在一起，用 ***** 运算符重复。 Python 中的字符串有两种索引方式，从左往右以 0 开始，从右往左以 -1 开始。 Python 中的字符串不能改变。 Python 没有单独的字符类型，一个字符就是长度为 1 的字符串。 字符串的截取的语法格式如下：变量[头下标:尾下标:步长] 12345678910111213141516171819202122232425262728293031323334word = &#x27;字符串&#x27;sentence = &quot;这是一个句子。&quot;paragraph = &quot;&quot;&quot;这是一个段落，可以由多行组成&quot;&quot;&quot;#!/usr/bin/python3 str=&#x27;123456789&#x27; print(str) # 输出字符串print(str[0:-1]) # 输出第一个到倒数第二个的所有字符print(str[0]) # 输出字符串第一个字符print(str[2:5]) # 输出从第三个开始到第五个的字符print(str[2:]) # 输出从第三个开始后的所有字符print(str[1:5:2]) # 输出从第二个开始到第五个且每隔一个的字符（步长为2）print(str * 2) # 输出字符串两次print(str + &#x27;你好&#x27;) # 连接字符串 print(&#x27;------------------------------&#x27;) print(&#x27;hello\\nrunoob&#x27;) # 使用反斜杠(\\)+n转义特殊字符print(r&#x27;hello\\nrunoob&#x27;) # 在字符串前面添加一个 r，表示原始字符串，不会发生转义123456789123456781345345678924123456789123456789123456789你好------------------------------hellorunoobhello\\nrunoob 空行 函数之间或类的方法之间用空行分隔，表示一段新的代码的开始。类和函数入口之间也用一行空行分隔，以突出函数入口的开始。 空行与代码缩进不同，空行并不是 Python 语法的一部分。书写时不插入空行，Python 解释器运行也不会出错。但是空行的作用在于分隔两段不同功能或含义的代码，便于日后代码的维护或重构。 记住：空行也是程序代码的一部分。 等待用户输入 1234567input(&quot;\\n\\n按下 enter 键后退出。&quot;)[root@192 python]# python test.py Truepress enter to exit 同一行显示多条语句 在同一行中使用多条语句，语句之间使用分号 ; 分割 1import sys; x = &#x27;runoob&#x27;; sys.stdout.write(x + &#x27;\\n&#x27;) 多个语句构成代码组 缩进相同的一组语句构成一个代码块，我们称之代码组。 像if、while、def和class这样的复合语句，首行以关键字开始，以冒号( : )结束，该行之后的一行或多行代码构成代码组。 我们将首行及后面的代码组称为一个子句(clause)。 123456if expression : suiteelif expression : suite else : suite print print 默认输出是换行的，如果要实现不换行需要在变量末尾加上 **end=””**： 123456789101112131415161718#!/usr/bin/python3 x=&quot;a&quot;y=&quot;b&quot;# 换行输出print( x )print( y ) print(&#x27;---------&#x27;)# 不换行输出print( x, end=&quot; &quot; )print( y, end=&quot; &quot; )print()ab---------a b import 与 from … import 在 python 用 import 或者 from…import 来导入相应的模块。 将整个模块(somemodule)导入，格式为： import somemodule 从某个模块中导入某个函数,格式为： from somemodule import somefunction 从某个模块中导入多个函数,格式为： from somemodule import firstfunc, secondfunc, thirdfunc 将某个模块中的全部函数导入，格式为： from somemodule import * 1234567891011#导入sys 模块import sysprint(&#x27;================Python import mode==========================&#x27;)print (&#x27;命令行参数为:&#x27;)for i in sys.argv: print (i)print (&#x27;\\n python 路径为&#x27;,sys.path)#导入sys模块的argv 和path成员from sys import argv,path # 导入特定的成员print(&#x27;================python from import===================================&#x27;)print(&#x27;path:&#x27;,path) # 因为已经导入path成员，所以此处引用时不需要加sys.path 命令行参数 稍后补充 基本数据类型 变量不需要声明。每个变量在使用前都必须赋值，变量赋值以后该变量才会被创建。 变量就是变量，它没有类型，我们所说的”类型”是变量所指的内存中对象的类型。 12345678#!/usr/bin/python3counter = 100 # 整型变量miles = 1000.0 # 浮点型变量name = &quot;runoob&quot; # 字符串print (counter)print (miles)print (name) 多变量赋值 12a = b = c = 1a, b, c = 1, 2, &quot;hello&quot; 标准数据类型 python3 中有6中标准数据类型： Number（数字） String（字符串） List（列表） Tuple（元组） Set（集合） Dictionary（字典） 不可变数据（3 个）：Number（数字）、String（字符串）、Tuple（元组）； 可变数据（3 个）：List（列表）、Dictionary（字典）、Set（集合）。 Number Python3 支持 int、float、bool、complex（复数）。 内置的 type() 函数可以用来查询变量所指的对象类型。 123&gt;&gt;&gt; a, b, c, d = 20, 5.5, True, 4+3j&gt;&gt;&gt; print(type(a), type(b), type(c), type(d))&lt;class &#x27;int&#x27;&gt; &lt;class &#x27;float&#x27;&gt; &lt;class &#x27;bool&#x27;&gt; &lt;class &#x27;complex&#x27;&gt; 还可以用 isinstance 来判断： 1234&gt;&gt;&gt; a = 111&gt;&gt;&gt; isinstance(a, int)True&gt;&gt;&gt; isinstance 和 type 的区别在于： type()不会认为子类是一种父类类型。 isinstance()会认为子类是一种父类类型。 123456789101112131415161718192021222324252627282930&gt;&gt;&gt; class A:... pass... &gt;&gt;&gt; class B(A):... pass... &gt;&gt;&gt; isinstance(A(), A)True&gt;&gt;&gt; type(A()) == A True&gt;&gt;&gt; isinstance(B(), A)True&gt;&gt;&gt; type(B()) == AFalse注意：Python3 中，bool 是 int 的子类，True 和 False 可以和数字相加， True==1、False==0 会返回 True，但可以通过 is 来判断类型。&gt;&gt;&gt; issubclass(bool, int) True&gt;&gt;&gt; True==1True&gt;&gt;&gt; False==0True&gt;&gt;&gt; True+12&gt;&gt;&gt; False+11&gt;&gt;&gt; 1 is TrueFalse&gt;&gt;&gt; 0 is FalseFalse 使用del语句删除单个或多个对象。例如： 12del vardel var_a, var_b 数值运算 1234567891011121314&gt;&gt;&gt; 5 + 4 # 加法9&gt;&gt;&gt; 4.3 - 2 # 减法2.3&gt;&gt;&gt; 3 * 7 # 乘法21&gt;&gt;&gt; 2 / 4 # 除法，得到一个浮点数0.5&gt;&gt;&gt; 2 // 4 # 除法，得到一个整数0&gt;&gt;&gt; 17 % 3 # 取余2&gt;&gt;&gt; 2 ** 5 # 乘方32 String 数据类型转换 推导式 解释器 注释 运算符 数字 字符串 列表 元组 字典 集合 条件控制 循环语句 迭代器与生成器 函数 数据结构 模块 输入输出 File OS 错误与异常处理 面向对象 命名空间/作用域 标准库 二、高级 正则表达式 CGI编程 MySql","categories":[{"name":"Python","slug":"Python","permalink":"https://hxlpub.github.io/categories/Python/"}],"tags":[{"name":"python","slug":"python","permalink":"https://hxlpub.github.io/tags/python/"}]},{"title":"排序","slug":"algorithm","date":"2021-09-14T09:26:07.000Z","updated":"2022-03-26T09:08:17.422Z","comments":true,"path":"2021/09/14/algorithm/","link":"","permalink":"https://hxlpub.github.io/2021/09/14/algorithm/","excerpt":"","text":"1.二分排序 K&amp;R P99","categories":[{"name":"算法","slug":"算法","permalink":"https://hxlpub.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"排序算法","slug":"排序算法","permalink":"https://hxlpub.github.io/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"}]},{"title":"GCC编译","slug":"compile_debug","date":"2021-09-14T09:26:07.000Z","updated":"2022-03-26T07:50:26.967Z","comments":true,"path":"2021/09/14/compile_debug/","link":"","permalink":"https://hxlpub.github.io/2021/09/14/compile_debug/","excerpt":"","text":"​ GCC原名为GNU C语言编译器（GNU C Compiler），只能处理C语言。但其很快扩展，变得可处理C++，后来又扩展为能够支持更多编程语言，如Fortran、Pascal、Objective -C、Java、Ada、Go以及各类处理器架构上的汇编语言等，所以改名GNU编译器套件（GNU Compiler Collection）。 ​ 虽然我们称GCC是C语言的编译器，但使用gcc由C语言源代码文件生成可执行文件的过程不仅仅是编译的过程，而是要经历四个相互关联的步骤∶ ​ 预处理（也称预编译，Preprocessing） ​ 编译（Compilation） ​ 汇编（Assembly） ​ 链接（Linking）","categories":[{"name":"编译","slug":"编译","permalink":"https://hxlpub.github.io/categories/%E7%BC%96%E8%AF%91/"}],"tags":[{"name":"编译","slug":"编译","permalink":"https://hxlpub.github.io/tags/%E7%BC%96%E8%AF%91/"}]},{"title":"编译原理","slug":"compiler","date":"2021-09-14T09:26:07.000Z","updated":"2022-03-26T09:00:17.844Z","comments":true,"path":"2021/09/14/compiler/","link":"","permalink":"https://hxlpub.github.io/2021/09/14/compiler/","excerpt":"","text":"section 1 GCC​ GCC原名为GNU C语言编译器（GNU C Compiler），只能处理C语言。但其很快扩展，变得可处理C++，后来又扩展为能够支持更多编程语言，如Fortran、Pascal、Objective -C、Java、Ada、Go以及各类处理器架构上的汇编语言等，所以改名GNU编译器套件（GNU Compiler Collection）。 ​ 虽然我们称GCC是C语言的编译器，但使用gcc由C语言源代码文件生成可执行文件的过程不仅仅是编译的过程，而是要经历四个相互关联的步骤∶ ​ 预处理（也称预编译，Preprocessing） ​ 编译（Compilation） ​ 汇编（Assembly） ​ 链接（Linking） section2 Makefile概述 什么是makefile？ windows开发IDE为我们做了这部分的工作，而在Linux 端开发，必须要自己写makefile,会不会写makefile，从一个侧面说明了一个人是否具备完成大型工程的能力。会不会写makefile，从一个侧面说明了一个人是否具备完成大型工程的能力。","categories":[{"name":"编译","slug":"编译","permalink":"https://hxlpub.github.io/categories/%E7%BC%96%E8%AF%91/"}],"tags":[{"name":"编译","slug":"编译","permalink":"https://hxlpub.github.io/tags/%E7%BC%96%E8%AF%91/"}]},{"title":"cv","slug":"cv","date":"2021-09-14T09:26:07.000Z","updated":"2022-03-26T09:01:13.127Z","comments":true,"path":"2021/09/14/cv/","link":"","permalink":"https://hxlpub.github.io/2021/09/14/cv/","excerpt":"","text":"","categories":[{"name":"计算机视觉CV","slug":"计算机视觉CV","permalink":"https://hxlpub.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89CV/"}],"tags":[{"name":"cv","slug":"cv","permalink":"https://hxlpub.github.io/tags/cv/"}]},{"title":"postgres数据库之基本操作","slug":"database_pg","date":"2021-09-14T09:26:07.000Z","updated":"2022-03-26T08:20:25.511Z","comments":true,"path":"2021/09/14/database_pg/","link":"","permalink":"https://hxlpub.github.io/2021/09/14/database_pg/","excerpt":"","text":"1.pgadmin工具 2.增删改查 ​ 插入批量记录： ​ 1）生成insertDeviceChannels 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139create or replace function insertDeviceChannels(num_limit integer) returns booleanAS$$declare id integer default 1; devName varchar; channelName varchar; devIndexCode varchar; devIp varchar; devIpEnd1 integer default 1; devIpEnd2 integer default 1; devPort integer default 1001; devExternalCode varchar; channelExternalCode varchar; regionCount integer; regionResourceLimit integer; regionResourceNum integer default 0; regionIndexCode varchar; offsetNum integer default 0;begin select count(o.region_index_code) into regionCount from tb_region o where region_status = &#x27;0&#x27;; raise notice &#x27;regionCount %&#x27; , regionCount; if num_limit % regionCount = 0 then regionResourceLimit := num_limit / regionCount; end if; if num_limit % regionCount &gt; 0 then regionResourceLimit := num_limit / regionCount + 1; end if; while devIpEnd1 &lt;= 100 loop devIpEnd2 := 1; while devIpEnd2 &lt;= 100 loop devip := &#x27;10.33.&#x27; || devIpEnd1 || &#x27;.&#x27; || devIpEnd2; devPort := 1000; while devPort &lt;= 1099 loop devName := devip; devIndexCode := uuid_generate_v4(); if regionIndexCode is null then select region_index_code into regionIndexCode from tb_region where region_status = &#x27;0&#x27; limit 1 offset offsetNum; end if; INSERT INTO public.tb_device (dev_id, dev_index_code, dev_name, dev_addr, dev_port, dev_model, active_device_code, dev_username, dev_password, pwd_strength, dev_type, dev_serial_num, dis_order, dev_capability, manufacturer, treaty_type, driver, sync_iac, remote_status, region_index_code, domain_id, ezviz_user_id, ezviz_dev_code, dev_restype, business_class, description, version, is_cascade, extended_attribute, com_id, data_no, status, create_time, update_time, creator, modifier ) VALUES (uuid_generate_v4(), devIndexCode, devName, devIp, devPort, &#x27;Simulator&#x27;, null, &#x27;admin&#x27;, &#x27;Dg/I6if34PWRn093VjyPqg==&#x27;, 3, null, &#x27;SimulatorDevice&#x27;, 1, &#x27;&#123;&#125;&#x27;, &#x27;hikvision&#x27;, &#x27;hiksdk_net&#x27;, &#x27;drv_vss_hiksdk_general_1.13.100&#x27;, 0, 1, regionIndexCode, 0, null, null, &#x27;&#123;encodeDevice&#125;&#x27;, &#x27;vms_encodeDevice_model&#x27;, null, 0, 0, &#x27;&#123; &quot;zeroChanCount&quot;: &quot;0&quot;, &quot;analogIoInCount&quot;: &quot;0&quot;, &quot;analogIoOutCount&quot;: &quot;0&quot;, &quot;digitalIoInCount&quot;: &quot;0&quot;, &quot;dataCollectStatus&quot;: &quot;1&quot;, &quot;digitalIoOutCount&quot;: &quot;0&quot;, &quot;analogChannelCount&quot;: &quot;0&quot;, &quot;digitalChannelCount&quot;: &quot;1&quot; &#125;&#x27;, &#x27;sdmc&#x27;, 1, 0, now(), now(), &#x27;admin&#x27;, &#x27;admin&#x27; ); channelName := devName || &#x27;_1&#x27;; INSERT INTO public.tb_channel (channel_id, channel_index_code, channel_name, channel_num, channel_main_type, channel_sub_type, channel_capability, dev_index_code, region_index_code, description, com_id, ezviz_safe_watch_key, treaty_type, is_cascade, cascade_platform_code, dis_order, sync_iac, data_no, status, extended_attribute, business_class, create_time, update_time, channel_restype, creator, modifier) VALUES (uuid_generate_v4(), uuid_generate_v4(), channelName, &#x27;1&#x27;, &#x27;camera&#x27;, &#x27;digital&#x27;, &#x27;&#123;&#125;&#x27;, devIndexCode, regionIndexCode, null, &#x27;sdmc&#x27;, null, null, &#x27;0&#x27;, &#x27;0&#x27;, id, null, id, 0, &#x27;&#123; &quot;osdStatus&quot;: &quot;0&quot; &#125;&#x27;, &#x27;vss_encodeDevice_camera&#x27;, now(), now(), &#x27;&#123;camera&#125;&#x27;, &#x27;admin&#x27;, &#x27;admin&#x27;); devPort := devPort + 1; regionResourceNum := regionResourceNum + 1; if regionResourceNum = regionResourceLimit then offsetNum := offsetNum + 1; regionIndexCode := null; regionResourceNum := 0; end if; if id = num_limit then return null; end if; id := id + 1; end loop; devIpEnd2 := devIpEnd2 + 1; end loop; devIpEnd1 := devIpEnd1 + 1; end loop; return null;end$$ LANGUAGE plpgsql; 2）插入10w记录 1select insertDeviceChannels(100000); 3)删除指定记录 1delete from tb_device where region_index_code = &#x27;219f98dd-a83a-468f-a2c0-3a30cd2e6082&#x27;;","categories":[{"name":"数据库","slug":"数据库","permalink":"https://hxlpub.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"postgres","slug":"postgres","permalink":"https://hxlpub.github.io/tags/postgres/"}]},{"title":"PostgreSQL数据库","slug":"database_redis","date":"2021-09-14T09:26:07.000Z","updated":"2022-03-26T09:01:46.873Z","comments":true,"path":"2021/09/14/database_redis/","link":"","permalink":"https://hxlpub.github.io/2021/09/14/database_redis/","excerpt":"","text":"","categories":[{"name":"数据库","slug":"数据库","permalink":"https://hxlpub.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"pg","slug":"pg","permalink":"https://hxlpub.github.io/tags/pg/"}]},{"title":"学习思路","slug":"deep-learning","date":"2021-09-14T09:26:07.000Z","updated":"2022-03-26T09:02:10.564Z","comments":true,"path":"2021/09/14/deep-learning/","link":"","permalink":"https://hxlpub.github.io/2021/09/14/deep-learning/","excerpt":"","text":"","categories":[{"name":"深度学习","slug":"深度学习","permalink":"https://hxlpub.github.io/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"DL","slug":"DL","permalink":"https://hxlpub.github.io/tags/DL/"}]},{"title":"git版本管理工具","slug":"git_tools","date":"2021-09-14T09:26:07.000Z","updated":"2022-03-26T09:04:24.038Z","comments":true,"path":"2021/09/14/git_tools/","link":"","permalink":"https://hxlpub.github.io/2021/09/14/git_tools/","excerpt":"","text":"1.把github上面的仓库克隆到本地 1git clone 仓库 2.上传本地的项目到github仓库 1234567git add * #可将当前目录下文件添加到暂存区git add [file1] [file2] ...#添加一个或多个文件到暂存区git add [dir]#添加指定目录到暂存区，包括子目录git add .#添加当前目录下的所有文件到暂存区git commit -m &quot;提交信息&quot; （注：“提交信息”里面换成你需要，如“first commit”）git push -u origin master （注：此操作目的是把本地仓库push到github上面，此步骤需要你输入帐号和密码，这里的账号和密码是你的github的账号和密码，你第一次上传的话可能会需要你输密码）","categories":[{"name":"开发工具","slug":"开发工具","permalink":"https://hxlpub.github.io/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"版本管理","slug":"版本管理","permalink":"https://hxlpub.github.io/tags/%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86/"}]},{"title":"实现从Linux服务器获取windows文件","slug":"linux","date":"2021-09-14T09:26:07.000Z","updated":"2022-03-26T09:06:44.984Z","comments":true,"path":"2021/09/14/linux/","link":"","permalink":"https://hxlpub.github.io/2021/09/14/linux/","excerpt":"","text":"问题描述​ 工作中需要从Linux服务器端去拿windows端的文件，linux服务器之间底层互传文件可以用scp很容易实现，但是 不同的操作系统之间实现文件传输,如，windows 和linux之间，又如何实现呢？ 子问题1 描述：ftp ip 需要手动输入win ftpserver所在的win用户名密码后才可以执行抓取等操作，怎么能跳过手动的验证？ 12345678910[root@localhost AuthServer]# ftp 10.192.44.183Connected to 10.192.44.183 (10.192.44.183).220 Microsoft FTP ServiceName (10.192.44.183:root): linhongxun331 Password requiredPassword:230 User logged in.Remote system type is Windows_NT.ftp&gt; 解决方案： 1234567891011121314#!/bin/shftp -n &lt;&lt;- EOF#win 端IPopen ip#win 端用户名密码user username password#传输格式ascii(or bin)#操作put *(or get)#退出byeEOF 子问题2： 解决方案 ftp：需要在windows端搭建ftpserver服务，在linux端安装ftp工具 scp 工作中使用了ftp的方案，本文着重讲解ftp实现从Linux服务器获取windows文件 实现windows 端搭建ftpserver​ 问一下度娘，很简单，在这不耽误时间，推荐 Linux 端安装ftp工具 rpm包方式安装 yum 安装 yum list |grep ftp #查看可安装版本ftp yum install ftp… ftp实现抓取windows端的文件到指定路径​ example:实现将win端的路径下文件cp 到linux端同一路径下：downloadjson.sh 1234567891011121314151617#!/bin/sh# $1 是第一个参数，即路径，执行的脚本为: ./downloadjson.sh /nas/test/test/DocumentVoucher.jsonparam1=`echo $1 |awk -F &quot;DocumentVoucher&quot; &#x27;&#123;printf $1&#125;&#x27;`#echo $&#123;param1&#125;ftp -n &lt;&lt;- EOFopen ftpserveripuser username passwordasciicd $&#123;param1&#125;get DocumentVoucher.jsonbyeEOFmkdir -p $&#123;param1&#125;cp DocumentVoucher.json $&#123;param1&#125; go语言执行脚本​ 项目中，上层应用是http 协议，目的是请求到含有文件路径报文的同时，将文件下载到Linux服务器端，故在http协议绑定的接口函数里面实现了执行该脚本,逻辑如下 123456789command := &quot;./downloadjson.sh &quot; + documentPathfmt.Println(command)cmd := exec.Command(&quot;/bin/sh&quot;, &quot;-c&quot;, command)bytes, err := cmd.Output()if err != nil &#123; fmt.Println(err) &#125;resp := string(bytes) fmt.Println(resp) 常见问题FAQ ​ ftp ip 时连接超时 1234[root@localhost AuthServer]# ftp 10.192.44.183ftp: connect: Connection timed outftp&gt; 解决方案：关闭win端的防火墙 ftp常用指令 连接ftp服务器 格式： 1ftp [hostname| ip-address] a)在linux命令行下输入： 1ftp 192.168.26.66 b)服务器询问你用户名和口令，分别输入用户名和相应密码，待认证通过即可。 2. 下载文件 下载文件通常用get和mget这两条命令。 a) get 格式： 1get [remote-file] [local-file] 将文件从远端主机中传送至本地主机中. 如要获取服务器上e:\\rose\\1.bmp,则 1ftp&gt; get /rose/1.bmp 1.bmp (回车) b) mget 格式： 1mget [remote-files] 从远端主机接收一批文件至本地主机. 如要获取服务器上e:\\rose\\下的所有文件,则 12ftp&gt; cd /roseftp&gt; mget *.* (回车) 注意：文件都下载到了linux主机的当前目录下。比如，在 /root/yint下运行的ftp命令，则文件都下载到了/root/yint 下。 3.上传文件 a) put 1格式：put local-file [remote-file] 将本地一个文件传送至远端主机中. 如要把本地的1.bmp传送到远端主机e:\\rose,并改名为333.bmp 1 ftp&gt; put 1.bmp /rose/333.bmp (回车) b) mput 1格式：mput local-files 将本地主机中一批文件传送至远端主机. 如要把本地当前目录下所有bmp文件上传到服务器e:\\rose 下 12ftp&gt; cd /rose （回车）ftp&gt; mput *.bmp （回车） 注意：上传文件都来自于主机的当前目录下。比如，在 /root/test下运行的ftp命令，则只有在/root/test下的文件linux才会 上传到服务器e:\\rose 下。 4. 断开连接 bye：中断与服务器的连接。 1 ftp&gt; bye (回车) scp常用​ scp是安全的文件拷贝，基于ssh的登录 ​ 假定你想把本地计算机/home下的一个名为a.tar.tz的文件拷贝到远程服务器192.168.0.2上的/home/tmp。而且你在远程服务器 上的帐号名为root。可以用这个命令： 1scp /home/a.tar.tz root@192.168.0.2:/home/tmp/ ​ 如果把文件从远程机器拷贝到本机当前目录用这个命令： 1scp root@192.168.0.2:/home/a.tar.tz ​ 拷贝远程机器的整个目录下的文件 1scp -r root@192.168.0.2：/home/* ./","categories":[{"name":"Linux","slug":"Linux","permalink":"https://hxlpub.github.io/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://hxlpub.github.io/tags/Linux/"}]},{"title":"Linux工具","slug":"linux_command_tools","date":"2021-09-14T09:26:07.000Z","updated":"2022-03-26T09:07:00.388Z","comments":true,"path":"2021/09/14/linux_command_tools/","link":"","permalink":"https://hxlpub.github.io/2021/09/14/linux_command_tools/","excerpt":"","text":"目录文件管理目录管理123456789101112131415161718192021222324252627282930313233343536373839404142434445464748491.列出目录文件名 ls/ll 1、ls -al ~:将家目录下的所有文件列出来（含属性与隐藏文件） 2、ls -alF --color=never:不显示颜色，文件名末尾显示文件名代表的类型 3、ls -al --full-time ~ ：完整呈现文件的修改时间 权限说明drwxr-xr-x 2 root root 4096 Jul 20 2017 Documents第一栏drwxr-xr-x:类型与权限 第一个字符表示文件是目录或文件或链接等等 [d]:目录 [-]:文件 [l]:链接 [b]:装置文件里可供存储的接口设备（可随机存取装置） [c]:装置文件里串行端口设备，如键盘鼠标（一次性读取装 置） 剩余字符以三个为一组：均为rwx三个参数组合 r可读：4 w可写:2 x可执行:1 没有权限则-:0 drwxr-xr-x: rwx=4+2+1=7 r-x:4+0+1=5 r-x:4+0+1=5 则该文件的权限数字是755 第一组：文件拥有者权限 第二组：加入此群组账号的权限 第三组：非本人且未加入本群组的其他账号的权限 第二栏 表示有多少档名连接到此节点（i_node） 第三栏 表示文件或者目录的拥有者账号 第四栏 表示文件所属群组 第五栏 表示文件容量大小，默认单位bytes 第六栏 表示文件的件当日期或最近修改日期 第七栏 表示文档的名字2.切换目录 cd 1、cd /usr/bin: 绝对路径，以根目录/开头 2、cd bin:在usr下，相对路径，相对于当前目录 3、cd ～：切换到目前用户所在家目录 4、cd . :目前所在目录 5、cd .. :切换至目前目录的上一层目录 6、cd ../.. :切换至上上层目录 7、cd ~account :切换到目前用户account所在家目录/home/account 8、cd ../dir:切换到与本目录并列的另一个目录 9、cd -:回到之前的目录3.显示当前目录 pwd4.创建一个新目录 mkdir5.删除一个空目录 rmdir 传输文件1234567891011121314151.wget 从URL获取文件 wget URL #下载URL指定的文件 ex: wget www.baidu.com #下载百度网页 wget -O filename URL #从URL获取文件并重命名filename,filename包含路径 ex：wget http://mirrors.hikvision.com.cn/help/centos/7/CentOS-Base.repo -O /etc/yum.repos.d/CenOS-Base.repo #配置hik yum源 wget -o log URL#注意o与O区别，o为写日志log（怎么获取文件的过程，包括解析、建立连接、传文件等），O为文件名2.ftp 子主题 1 子主题 23.scp 用于 Linux 之间复制文件和目录 scp [可选参数] file_source file_target 1、scp /home/space/music/1.mp3 IP:/home/root/others/music （本地到远程） 2、scp -P 55555 IP:/usr/local/sin.sh /home/administrator（远程到本地） 创建文件、文件链接12341.touch filename#从无到有创建文件2.cp file file.bak #备份3.ln -sf /dev/dm-30 /dev/cvr_vg/lun1 (ln -sf 目的地 链接) 删除文件​ 1rm -rf filename #r：递归，f：强制删除，不提示 更改文件12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455561.重命名​ mv filename newfilename#将文件filename重命名为newfilename2.更改文件属性​ chattr​ 语法​ chattr [-RV][-v&lt;版本编号&gt;][+/-/=&lt;属性&gt;][文件或目录...]​ 参数​ -R 递归处理，将指定目录下的所有文件及子目录一并处理。 -v&lt;版本编号&gt; 设置文件或目录版本。 -V 显示指令执行过程。 +&lt;属性&gt; 开启文件或目录的该项属性。 -&lt;属性&gt; 关闭文件或目录的该项属性。 =&lt;属性&gt; 指定文件或目录的该项属性。 属性 a：让文件或目录仅供附加用途。 b：不更新文件或目录的最后存取时间。 c：将文件或目录压缩后存放。 d：将文件或目录排除在倾倒操作之外。 i：不得任意更动文件或目录。 s：保密性删除文件或目录。 S：即时更新文件或目录。 u：预防意外删除。 示例 chattr +i /etc/resolv.conf#用chattr命令防止系统中某个关键文件被修改 chattr +a /var/log/messages#让某个文件只能往里面追加数据，但不能删除，适用于各种日志文件3.更改文件权限 chmod 格式 chmod [-cfvR] [--help] [--version] mode file... 参数 mode : 权限设定字串 [ugoa...][[+-=][rwxX]...][,...]#格式 其中： u 表示该文件的拥有者，g 表示与该文件的拥有者属于同一个群体(group)者，o 表示其他以外的人，a 表示这三者皆是。 + 表示增加权限、- 表示取消权限、= 表示唯一设定权限。 r 表示可读取，w 表示可写入，x 表示可执行，X 表示只有当该文件是个子目录或者该文件已经被设定过为可执行。 其他参数说明： -c : 若该文件权限确实已经更改，才显示其更改动作 -f : 若该文件权限无法被更改也不要显示错误讯息 -v : 显示权限变更的详细资料 -R : 对目前目录下的所有文件与子目录进行相同的权限变更(即以递归的方式逐个变更) --help : 显示辅助说明 --version : 显示版本 示例 chmod ugo+r file1.txt#将文件 file1.txt 设为所有人皆可读取 chmod ug+w,o-w file1.txt file2.txt#将文件 file1.txt 与 file2.txt 设为该文件拥有者，与其所属同一个群体者可写入，但其他以外的人则不可写入 chmod -R a+r *#将目前目录下的所有文件与子目录皆设为任何人可读取 chmod a=rwx file == chmod 777 file 查看文件1234567891011121314151617181920212223242526272829301.cat 从头到尾显示文件内容 cat 文件 #从头到尾显示整个文件内容，当文件很大时，终端无法完全显示其所有内容 cat -n 文件 #查看文件内容的同时添加行号 三大功能 1.cat 文件 #一次显示整个文件 2.cat &gt; 文件 #从键盘创建一个文件,只能创建新文件，不能编辑已有文件，执行命令后会进入文件编辑，每次都会覆盖旧的内容 3.cat file1 file2 &gt; file#将几个文件合并为一个文件 2.more 分屏显示文件 more 文件 #分屏显示文件内容，空格：向下翻页，b：向上翻页，q：退出3.less 分屏显示文件，同more4.head 从头开始查看文件内容 head 文件 #显示文件头部，默认10行 head -n 行数 文件#查看文件的前10行5.tail 与head相反6.file 观察文件类型,某个文件的基本数据 file file 文件类型诸如,ASCII，data文件，binary文件等 file file7.查看文件格式:set ff #进入到文件，vi/vim 文件后执行:set ff 搜索文件​ 1234567891011121314151617181920212223241.find find path -option ... find . -type f#将当前目录及其子目录中的所有文件列出 find . -name &quot;*.c&quot;#将当前目录及其子目录下所有文件后缀为 .c 的文件列出来 常用：find / -name filename2.which 寻找执行档 which command -a :将所有由PATH目录中可以找到的指令均列出，而不止第一份被找到的指令名称 1、which ifconfig :找出ifconfig命令的执行文件位置3.whereis 文件档名的查找，由一些特定的目录中 寻找文件文件名 whereis [-bmsu] 文件或目录名 -l：列出whereis 会去查询的几个主要目录而已 -b:只找binary文件 -m:只找在说明文件manual路径下的文件 -s:只找source 来源文件 -u:搜寻不在上述三个项目 中的其他特殊文件 1、whereis ifconfig4.根据文件中字符串搜索文件 grep -rn &quot;字符串&quot; 比较文件​ 121.diff diff 选项 文件一 文件二 分割文件1234split 命令用于将一个文件分割成数个 -b:指定每多少字节切成一个小文件 1、split -b 1024m txst.txt -d -a 2 test.txt_ 编辑文件vim ​ 常用快捷方式： ​ 输入输出1231.&gt;&gt; 输出重定向 example: vmstat 3 &gt;&gt; test#vmstat输出重定向到文件test 系统管理1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798991001011021031041051061071081091101111121131141151161171.top 实时显示 process 的动态 top [-d 数字] |top [-bnp] -d:后接秒数，更新的秒数 -b:以批次的方式执行 -n:与-b搭配表示需要进行几次top的输出结果 -p 指定某些个PID观察 1、top -d 2 说明: 第一行：目前的时间，经过的时间，登录用户数，在1,5,15分钟的平均负载 第二行：显示目前进程总数和个别进程状态 第三行： 显示CPU的整体负载 第四行第五行：物理内存和虚拟内存使用情况（虚拟内存来源？？) 第六：输入指令时显示状态的地方 2、top -b -n 2 &gt;/tmp/top.txt#2次输出结果到文件 3、top -d 2 -p PID #持续观察该PID2.ps 显示某个时间点的进程运作情况 ps [options] -A:显示所有process,同-e -a:不与terminal相关的process -u：有效使用者相关的pro x:通常与a一起用列出较完整信息 l :详细讲该PID信息列出 j:工作的格式 -f：更完整的输出 1、ps -l 仅仅观察自己bash相关的进程 说明： F：进程旗标，总结权限，常见号码4:表示进程权限root 1:表示仅复制而没有实际执行 S：表示状态 R：运行中 S：睡眠 D：不可唤醒，可能在等待IO的情况 T：停止 Z:僵尸状态，已经终止但无法移除到内存外 UID/PID/PPID:代表此进程被该UID所拥有，进程的PID号码，此进程的PID号码 C：Cpu 使用率 PRI/NI :priority/nice优先级，越小越优先 ADDR/SZ/WCHAN：内存相关,内存部分，用掉多少内存，是否在运作 TTY：终端机位置，远程则pts/n TIME:使用掉的CPU时间 CMD：造成此进程的程序的指令 2、ps aux#观察系统所有进程 USR;使用者账号 MEM：物理内存占比 VSZ：耗掉的虚拟内存 RSS：占用的固定内存3、ps -lA#显示所有进程 4.free 用于显示内存状态5.查看cpu cat /proc/cpuinfo6.查看内核uname -r7.查看系统cat /etc/redhat-release （redhat）8.进程管理 Kill -s 9 进程号#杀掉进程9.查看目录占用者并解除占用 stat /root/hu10.systemctl 一、systemd 系统初始化程序，系统开始的第一个进程，pid为1 二、systemctl命令 systemctl list-units ##列出当前系统服务的状态 systemctl list-unit-files ##列出服务的开机状态 systemctl status sshd ##查看指定服务的状态 systemctl stop sshd ##关闭指定服务 systemctl start sshd ##开启指定服务 systemctl restart sshd ##从新启动服务 systemctl enable sshd ##设定指定服务开机开启 systemctl disable sshd ##设定指定服务开机关闭 systemctl reload sshd ##使指定服务从新加载配置 systemctl list-dependencies sshd ##查看指定服务的倚赖关系 systemctl mask sshd ##冻结指定服务 systemctl unmask sshd ##启用服务 systemctl set-default multi-user.target ##开机不开启图形 systemctl set-default graphical.target ##开机启动图形 setterm ##文本界面设定color 三、服务状态 systemctl status 服务名称 loaded ##系统服务已经初始化完成，加载过配置 active（running） ##正有一个或多个程序正在系统中执行， vsftpd就是这种模式 atcive（exited） ##僅執行一次就正常結束的服務， 目前並沒有任何程序在系統中執行 atcive（waiting） ##正在執行當中，不過還再等待其他的事件才能继续处理 inactive ##服务关闭 enbaled ##服务开机启动 disabled ##服务开机不自启 static ##服务开机启动项不可被管理 failed ##系统配置错误 11.pstree查看Linux下systemd启动了哪些服务 pstree [options]-a #包含命令行参数-c #展开相同的子树-H [PID] #突出特定过程-g #显示进程组ID-n #使用PID排序pstree 用户 #显示特定用户的进程树-s [PID ] #限制显示一个特定的过程12.查看内存型号dmidecode -t memory13. 排名前10的内存CPU消耗ps auxw|head -1;ps auxw|sort -rn -k3|head -1014.释放内存如果内存太少， 可以把占用内存多的程序停掉， 然后执行这个命令释放： echo 3 &gt;/proc/sys/vm/drop_caches 释放完后再改回去： echo 1 &gt;/proc/sys/vm/drop_caches 系统设置123子主题 1子主题 2子主题 3 磁盘、设备管理1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162631.df 列出文件系统的整体磁盘使用量 df [-ahikHTm][目录或文件名] -a:列出所有文件系统，包括系统特有的/proc等文件系统 -k:以KBytes的容量显示文件系统 -m:以MBytes的容量显示文件系统 -h：以人们交易阅读的的GB、MB、KB等格式自行显示 -H：以M=1000K取代M=1024K 的进位方式 -T：连同该partition的filesystem名称列出 -i:不用磁盘容量而以inode数量表示 1、df:列出系统内所有filesystem列出来 filesystem:表示文件系统是哪个partition 1k-blocks:表示单位1KB，可用-h或-m改变容量 Used:使用掉的磁盘空间 Available:剩下的磁盘空间 Use%:磁盘的使用率 Mounted on :磁盘挂载的目录（挂载点） 2、df -h:易读显示 3、df -aT:将系统内所有特殊文件格式以及名称列出来 4、df -h /etc：将/etc下可用的磁盘以易读的容量格式显示出来 5、df -ih：将目前的各个partition当中可用的inode数量列出2.lsblklist block device观察磁盘分区状态lsblk [-dfimpt] device-d:仅列出磁盘本身,无分区-f:含文件系统名称-i：使用ASCII的线段输出-m：输出权限数据-p:列出完整文件名 -t:列出详细数据。包括磁盘队列机制与读写的数据量大小1、lsblk -ip /dev/sdb3.blkid对系统的块设备（包括交换分区）所使用的文件系统类型、LABEL、UUID等信息进行查询4.挂载镜像 1、sudo losetup /dev/loop0 iVMS-HG-H16_CN_STD_9.2.0_V2.3.8_iSC_V1.5.100_201026_platformactive_base.img 2、 kpartx -av /dev/loop0 3、 kpartx -d /dev/loop0 4、losetup -d /dev/loop05.调整分区fdisk 1.fdisk /dev/hda p：打印分区 d：删除分区 n:新增分区 2.格式化分区 mkfs.ext4 /dev/.. 3.挂载分区 mount /dev/... 挂载点6.激活网卡 ifup eth0 磁盘维护1234567891011121314151.dd 备份(直接读取扇区sector)制作文件 dd if=&quot;input_file&quot; of=&quot;output_file&quot; bs=&quot;blocksize&quot; count=blocknum if：输入文件名，默认为标准输入。即指定源文件或设备。 of：输出文件名，默认为标准输出。即指定目的文件或设备。 count：多少的bs bs：一个block大小 1、dd if=/etc/passwd of=/etc/passwd.back #备份文件 2、dd if=/dev/sdb of=/tmp/system.iso#将光驱内容备份下来 3、dd if=/tmp/system.iso of=/dev/sdb#将镜像备份到设备 4、将/boot整个文件系统透过dd备份下来 df -h /boot#获取设备/dev/... dd if=/dev/… of=/tmp/….img 子主题 2子主题 3 网络通讯、系统性能1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798991001011021031041051061071081091101111121131141151161171181191201211221231241251261271281291301311321331341351361371381391401411.iostat I/O statistics（输入/输出统计）输出CPU和磁盘I/O相关的统计信息监控系统的IO状态 iostat [ options ] [ &lt;interval&gt; [ &lt;count&gt; ] ]-c：查看CPU部分状态信息-k:某些使用block为单位的列强制使用Kilobytes为单位-d 参数，显示设备（磁盘）使用状态-x 参数，输出更多详细信息1、iostat -c2、iostat -k 1 103、iostat -d 1 34、iostat -x 1 2说明：磁盘属性tps：该设备每秒的传输次数“一次传输”意思是“一次I/O请求”。多个逻辑请求可能会被合并为“一次I/O请求”。“一次传输”请求的大小是未知的。kB_read/s：每秒从设备（drive expressed）读取的数据量；kB_wrtn/s：每秒向设备（drive expressed）写入的数据量；kB_read：读取的总数据量；kB_wrtn：写入的总数量数据量；这些单位都为Kilobytes。CPU属性%user cpu处在用户模式下的时间百分比%nice cpu处在带NICE值的用户模式下的时间百分比%system cpu处在系统模式下的时间百分比%iowait cpu等待输入输出完成时间的百分比%steal 管理程序维护另一个虚拟处理器时，虚拟CPU的无意识等待时间百分比%idle cpu空闲时间百分比注意:如果%iowait的值过高，表示硬盘存在I/O瓶颈，%idle值高，表示CPU较空闲，如果%idle值高但系统响应慢时，有可能是CPU等待分配内存，此时应加大内存容量。%idle值如果持续低于10，那么系统的CPU处理能力相对较低，表明系统中最需要解决的资源是CPU。2.ifstat网络接口监测工具ifstat options-l 监测环路网络接口。缺省情况下ifstat监测活动的所有非环路网络接口-a 监测能检测到的所有网络接口的状态信息。-z 隐藏流量是无的接口，如接口启动了但是未使用的。-i &lt;interface&gt; 指定要监测的接口。-s 通过SNMP查询一个远程主机。-h 显示帮助信息-n 关闭周期性显示头部信息。-t 在每一行的开头加一个时间戳-T 报告所有检测接口的全部带宽-w 指定间隔时间（与官方的文档说明并不同，不知道是不是写文档的人写错，反正我测试后是间隔时间）-W 如果显示内容超出终端窗口的宽度，就换行-S 在同一行更新显示内容 -b 用kbits/s显示带宽-q 按键模式-v 显示版本信息-d 指定一个驱动来收集状态信息 3.netstatNetstat是控制台命令,是一个监控TCP/IP网络的非常有用的工具，它可以显示路由表、实际的网络连接以及每一个网络接口设备的状态信息。Netstat用于显示与IP、TCP、UDP和ICMP协议相关的统计数据，一般用于检验本机各端口的网络连接情况。netstat options-a (all) 显示所有选项，默认不显示LISTEN相关。-t (tcp) 仅显示tcp相关选项。-u (udp) 仅显示udp相关选项。-n 拒绝显示别名，能显示数字的全部转化成数字。-l 仅列出有在 Listen (监听) 的服务状态。-p 显示建立相关链接的程序名-r 显示路由信息，路由表-e 显示扩展信息，例如uid等-s 按各个协议进行统计-c 每隔一个固定时间，执行该netstat命令。LISTEN和LISTENING的状态只有用-a或者-l才能看到。1、列出所有端口 #netstat -a2、列出所有 tcp 端口 #netstat -at3、列出所有 udp 端口 #netstat -au4、只显示监听端口 #netstat -l5、只列出所有监听 tcp 端口 #netstat -lt6、只列出所有监听 udp 端口 #netstat -lu7、列出所有监听 UNIX 端口 #netstat -lx8、显示所有端口的统计信息 #netstat -s9、显示 TCP 或 UDP 端口的统计信息 #netstat -st 或 -su10、 输出中显示 PID 和进程名称 #netstat -p4.vmstat展现给定时间间隔的服务器的状态值,包括服务器的CPU使用率，内存使用，虚拟内存交换情况,IO读写情况 vmstat [options] [delay [count]]参数说明Procs（进程） r等待执行的任务数展示了正在执行和等待cpu资源的任务个数当这个值超过了cpu个数，就会出现cpu瓶颈。B等待IO的进程数量Memory(内存)swpd正在使用虚拟的内存大小，单位kfree空闲内存大小buff已用的buff大小，对块设备的读写进行缓冲cache已用的cache大小，文件系统的cacheinact非活跃内存大小，即被标明可回收的内存，区别于free和active active活跃的内存大小Swapsi每秒从交换区写入内存的大小（单位：kb/s）so每秒从内存写到交换区的大小IObi每秒读取的块数（读磁盘） 块设备每秒接收的块数量，单位是block，这里的块设备是指系统上所有的磁盘和其他块设备，现在的Linux版本块的大小为1024bytesbo每秒写入的块数（写磁盘）块设备每秒发送的块数量，单位是block system in ：中断数cs:每秒上下文切换数CPUus用户进程执行消耗cpu时间(user time) us的值比较高时，说明用户进程消耗的cpu时间多，但是如果长期超过50%的使用，那么我们就该考虑优化程序算法或其他措施了sy系统进程消耗cpu时间(system time)sys的值过高时，说明系统内核消耗的cpu资源多，这个不是良性的表现，我们应该检查原因。这里us + sy的参考值为80%，如果us+sy 大于 80%说明可能存在CPU不足Id空闲时间(包括IO等待时间) 一般来说 us+sy+id=100wa等待IO时间wa过高时，说明io等待比较严重，这可能是由于磁盘大量随机访问造成的，也有可能是磁盘的带宽出现瓶颈。5.tcpdump 虚拟机内抓一下网卡上某个ip的流量 tcpdump -i ens3 |grep 10.192.54.2206.ethtool 查看网卡信息 ethtool eth0 备份压缩12345678910111213141516171819202122232425262728293031321.zip zip -r myfile.zip ./* unzip -o -d /home/sunny myfile.zip #解压myfile.zip 到/home/sunny2.tar 用于备份文件、压缩、解压 -c：建立打包文件，可搭配-v查看过程中被打包的文件名 -t:查看打包文件的内容含有哪些档名，重点在查看档名就是了 -x:解打包或解压缩的功能，可以搭配-C在特定的目录解开，特别留意的是-c,-t，-x不可同时出现在一串指令中 -z：透过gzip的支持进行压缩解压缩，文件最好是*.tar.gz -j：透过bzip2的支持进行压缩解压缩，文件最好是*.tar.bz2 -J：透过xz的支持进行压缩解压缩，文件最好是*.tar.xz -v:在压缩解压缩的过程中，将正在处理的文件名显示出来 -f filename：-f 后面要立刻接要被处理的文档名 -C目录：这个选项用在解压缩，若要在特定目录解压缩，可以使用这个选项 -p：保留备份数据的原本权限与属性，常用于备份-c重要的配置文件 -P：保留绝对路径，即允许备份数据中含有根目录存在 --exclude=FILE：在压缩过程中，不要将FILE 打包 1、# tar -czvf test.tar.gz a.c //压缩（compress） a.c文件为test.tar.gz 2、tar -tzvf test.tar.gz （列出压缩文件内容）(list) 3、tar -xzvf test.tar.gz（解压）(extract) 4、tar -zpcv -f /root/etc.tar.gz /etc#备份/etc（先su -切换到root） tar -jpcv -f /root/etc.tar.bz2 /etc tar -Jpcv -f /root/etc.tar.xz /etc3.xz创建tar.xz文件：只要先 tar cvf xxx.tar xxx/ 这样创建xxx.tar文件先，然后使用 xz -z xxx.tar 来将 xxx.tar压缩成为 xxx.tar.xz解压tar.xz文件：先 xz -d xxx.tar.xz 将 xxx.tar.xz解压成 xxx.tar 然后，再用 tar xvf xxx.tar来解包。4.子主题 4 软件维护 Ubuntu 12345678910111213更新软件源 1.更改源sudo vim /etc/apt/sources.list 2.sudo apt-get update安装软件 3.sudo apt-get install 软件 Centos 1234567891011121314151617181920212223242526271.更改yum源wget 官方源/aliyun 等 -O /etc/yum.repos.d/CenOS-Base.repoyum clean all &amp;&amp; yum makecache #生成缓存2.安装EPEL 源EPEL (Extra Packages for Enterprise Linux)是基于Fedora的一个项目，为“红帽系”的操作系统提供额外的软件包，适用于RHEL、CentOS和Scientific Linux.我们在Centos下使用yum安装时往往找不到rpm的情况，官方的rpm repository提供的rpm包也不够丰富，很多时候需要自己编译很痛苦，而EPEL恰恰可以解决这两方面的问题。EPEL的全称叫 Extra Packages for Enterprise Linux 。EPEL是由 Fedora 社区打造，为 RHEL 及衍生发行版如 CentOS、Scientific Linux 等提供高质量软件包的项目。装上了 EPEL之后，就相当于添加了一个第三方源。————————————————版权声明：本文为CSDN博主「不忘初心fight」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。原文链接：https://blog.csdn.net/weixin_41831919/article/details/1090359361）yum install -y epel-release [root@192 daos]# ll /etc/yum.repos.d/total 52-rw-r--r--. 1 root root 1664 Oct 23 2020 CentOS-Base.repo-rw-r--r--. 1 root root 2523 Dec 26 2020 CentOS-Base.repo.aliyun-rw-r--r--. 1 root root 1309 Nov 23 2020 CentOS-CR.repo-rw-r--r--. 1 root root 649 Nov 23 2020 CentOS-Debuginfo.repo-rw-r--r--. 1 root root 314 Nov 23 2020 CentOS-fasttrack.repo-rw-r--r--. 1 root root 630 Nov 23 2020 CentOS-Media.repo-rw-r--r--. 1 root root 1331 Nov 23 2020 CentOS-Sources.repo-rw-r--r--. 1 root root 8515 Nov 23 2020 CentOS-Vault.repo-rw-r--r--. 1 root root 616 Nov 23 2020 CentOS-x86_64-kernel.repo-rw-r--r--. 1 root root 951 Oct 2 2017 epel.repo-rw-r--r--. 1 root root 1050 Oct 2 2017 epel-testing.repo2）yum repolist3) yum clean all &amp;&amp; yum makecache 其他 11.set -e # shell文件开头加上set -e,这句语句告诉bash如果任何语句的执行结果不是true则应该退出 自定义安装软件环境变量设置 1 Linux环境变量配置方法一：export PATH使用export命令直接修改PATH的值，配置MySQL进入环境变量的方法: 1234export PATH=/home/uusama/mysql/bin:$PATH# 或者把PATH放在前面export PATH=$PATH:/home/uusama/mysql/bin 注意事项： 生效时间：立即生效 生效期限：当前终端有效，窗口关闭后无效 生效范围：仅对当前用户有效 配置的环境变量中不要忘了加上原来的配置，即$PATH部分，避免覆盖原来配置 Linux环境变量配置方法二：vim ~/.bashrc通过修改用户目录下的~/.bashrc文件进行配置： 1234vim ~/.bashrc# 在最后一行加上export PATH=$PATH:/home/uusama/mysql/bin 注意事项： 生效时间：使用相同的用户打开新的终端时生效，或者手动source ~/.bashrc生效 生效期限：永久有效 生效范围：仅对当前用户有效 如果有后续的环境变量加载文件覆盖了PATH定义，则可能不生效 Linux环境变量配置方法三：vim ~/.bash_profile和修改~/.bashrc文件类似，也是要在文件最后加上新的路径即可： 1234vim ~/.bash_profile# 在最后一行加上export PATH=$PATH:/home/uusama/mysql/bin 注意事项： 生效时间：使用相同的用户打开新的终端时生效，或者手动source ~/.bash_profile生效 生效期限：永久有效 生效范围：仅对当前用户有效 如果没有~/.bash_profile文件，则可以编辑~/.profile文件或者新建一个 Linux环境变量配置方法四：vim /etc/bashrc该方法是修改系统配置，需要管理员权限（如root）或者对该文件的写入权限： 1234567# 如果/etc/bashrc文件不可编辑，需要修改为可编辑chmod -v u+w /etc/bashrcvim /etc/bashrc# 在最后一行加上export PATH=$PATH:/home/uusama/mysql/bin 注意事项： 生效时间：新开终端生效，或者手动source /etc/bashrc生效 生效期限：永久有效 生效范围：对所有用户有效 Linux环境变量配置方法五：vim /etc/profile该方法修改系统配置，需要管理员权限或者对该文件的写入权限，和vim /etc/bashrc类似： 1234567# 如果/etc/profile文件不可编辑，需要修改为可编辑chmod -v u+w /etc/profilevim /etc/profile# 在最后一行加上export PATH=$PATH:/home/uusama/mysql/bin 注意事项： 生效时间：新开终端生效，或者手动source /etc/profile生效 生效期限：永久有效 生效范围：对所有用户有效 Linux环境变量配置方法六：vim /etc/environment该方法是修改系统环境配置文件，需要管理员权限或者对该文件的写入权限： 1234567# 如果/etc/bashrc文件不可编辑，需要修改为可编辑chmod -v u+w /etc/environmentvim /etc/profile# 在最后一行加上export PATH=$PATH:/home/uusama/mysql/bin 注意事项： 生效时间：新开终端生效，或者手动source /etc/environment生效 生效期限：永久有效 生效范围：对所有用户有效 Linux环境变量加载原理解析上面列出了环境变量的各种配置方法，那么Linux是如何加载这些配置的呢？是以什么样的顺序加载的呢？ 特定的加载顺序会导致相同名称的环境变量定义被覆盖或者不生效。 环境变量的分类环境变量可以简单的分成用户自定义的环境变量以及系统级别的环境变量。 用户级别环境变量定义文件：~/.bashrc、~/.profile（部分系统为：~/.bash_profile） 系统级别环境变量定义文件：/etc/bashrc、/etc/profile(部分系统为：/etc/bash_profile）、/etc/environment 另外在用户环境变量中，系统会首先读取~/.bash_profile（或者~/.profile）文件，如果没有该文件则读取~/.bash_login，根据这些文件中内容再去读取~/.bashrc。 测试Linux环境变量加载顺序的方法为了测试各个不同文件的环境变量加载顺序，我们在每个环境变量定义文件中的第一行都定义相同的环境变量UU_ORDER，该变量的值为本身的值连接上当前文件名称。 需要修改的文件如下： /etc/environment /etc/profile /etc/profile.d/test.sh，新建文件，没有文件夹可略过 /etc/bashrc，或者/etc/bash.bashrc ~/.bash_profile，或者~/.profile ~/.bashrc 在每个文件中的第一行都加上下面这句代码，并相应的把冒号后的内容修改为当前文件的绝对文件名。 1export UU_ORDER=&quot;$UU_ORDER:~/.bash_profile&quot; 修改完之后保存，新开一个窗口，然后echo $UU_ORDER观察变量的值： 12uusama@ubuntu:~$ echo $UU_ORDER$UU_ORDER:/etc/environment:/etc/profile:/etc/bash.bashrc:/etc/profile.d/test.sh:~/.profile:~/.bashrc 可以推测出Linux加载环境变量的顺序如下： /etc/environment /etc/profile /etc/bash.bashrc /etc/profile.d/test.sh ~/.profile ~/.bashrc Linux环境变量文件加载详解由上面的测试可容易得出Linux加载环境变量的顺序如下，： 系统环境变量 -&gt; 用户自定义环境变量/etc/environment -&gt; /etc/profile -&gt; ~/.profile 打开/etc/profile文件你会发现，该文件的代码中会加载/etc/bash.bashrc文件，然后检查/etc/profile.d/目录下的.sh文件并加载。 123456789101112131415161718192021222324252627# /etc/profile: system-wide .profile file for the Bourne shell (sh(1))# and Bourne compatible shells (bash(1), ksh(1), ash(1), ...).if [ &quot;$PS1&quot; ]; then if [ &quot;$BASH&quot; ] &amp;&amp; [ &quot;$BASH&quot; != &quot;/bin/sh&quot; ]; then # The file bash.bashrc already sets the default PS1. # PS1=&#x27;\\h:\\w\\$ &#x27; if [ -f /etc/bash.bashrc ]; then . /etc/bash.bashrc fi else if [ &quot;`id -u`&quot; -eq 0 ]; then PS1=&#x27;# &#x27; else PS1=&#x27;$ &#x27; fi fifiif [ -d /etc/profile.d ]; then for i in /etc/profile.d/*.sh; do if [ -r $i ]; then . $i fi done unset ifi 其次再打开~/.profile文件，会发现该文件中加载了~/.bashrc文件。 12345678910# if running bashif [ -n &quot;$BASH_VERSION&quot; ]; then # include .bashrc if it exists if [ -f &quot;$HOME/.bashrc&quot; ]; then . &quot;$HOME/.bashrc&quot; fifi# set PATH so it includes user&#x27;s private bin directoriesPATH=&quot;$HOME/bin:$HOME/.local/bin:$PATH&quot; 从~/.profile文件中代码不难发现，/.profile文件只在用户登录的时候读取一次，而/.bashrc会在每次运行Shell脚本的时候读取一次。 一些小技巧可以自定义一个环境变量文件，比如在某个项目下定义uusama.profile，在这个文件中使用export定义一系列变量，然后在~/.profile文件后面加上：sourc uusama.profile，这样你每次登陆都可以在Shell脚本中使用自己定义的一系列变量。 也可以使用alias命令定义一些命令的别名，比如alias rm=&quot;rm -i&quot;（双引号必须），并把这个代码加入到~/.profile中，这样你每次使用rm命令的时候，都相当于使用rm -i命令，非常方便。","categories":[{"name":"Linux","slug":"Linux","permalink":"https://hxlpub.github.io/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://hxlpub.github.io/tags/Linux/"}]},{"title":"Linux内核kernel","slug":"linux_kernel","date":"2021-09-14T09:26:07.000Z","updated":"2022-03-26T09:07:22.616Z","comments":true,"path":"2021/09/14/linux_kernel/","link":"","permalink":"https://hxlpub.github.io/2021/09/14/linux_kernel/","excerpt":"","text":"","categories":[{"name":"Linux","slug":"Linux","permalink":"https://hxlpub.github.io/categories/Linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://hxlpub.github.io/tags/linux/"}]},{"title":"Linux驱动.ko文件编写加载","slug":"linux_ko","date":"2021-09-14T09:26:07.000Z","updated":"2022-03-26T08:45:12.487Z","comments":true,"path":"2021/09/14/linux_ko/","link":"","permalink":"https://hxlpub.github.io/2021/09/14/linux_ko/","excerpt":"","text":"参考 一、.ko 文件介绍.ko文件是kernel object文件（内核模块），该文件的意义就是把内核的一些功能移动到内核外边， 需要的时候插入内核，不需要时卸载。 二、优点（1）这样可以缩小内核体积； （2）使用方便。 三、.ko文件一般的用处（1）作为一个功能模块，需要使用时，直接插入运行就行。如在imx6上连接模拟摄像头，先运行模拟摄像头对应的驱动模块 camera.ko文件，然后对应的工程执行文件运行就行。 四、使用.ko 文件1、加载驱动模块test.ko（1）方法一进入test.ko驱动模块文件所在的目录，然后直接 insmod test.ko （2）方法二将test.ko文件拷贝到/lib/module/#uname-r#/目录下，这里，#uname -r#意思是，在终端中输入uname -r后显示的内核版本及名称，例如我的环境centos 7系统下#uname-r#就是3.10.0-957.12.2.el7.x86_64然后 depmod（会在/lib/modules/#uname -r#/目录下生成modules.dep和modules.dep.bb文件，表明模块的依赖关系）最后 modprobe test（注意这里无需输入.ko后缀） 即可 注：两种方法的区别 modprobe和insmod类似，都是用来动态加载驱动模块的，区别在于modprobe可以解决load module时的依赖关系，它是通过/lib/modules/#uname -r/modules.dep(.bb)文件来查找依赖关系的；而insmod不能解决依赖问题。也就是说，如果你确定你要加载的驱动模块不依赖其他驱动模块的话，既可以insmod也可以modprobe，当然insmod可以在任何目录下执行，更方便一些。而如果你要加载的驱动模块还依赖其他ko驱动模块的话，就只能将模块拷贝到上述的特定目录，depmod后再modprobe。 2、查看已加载的驱动模块列表在任何目录下输入命令lsmod 12345678910111213141516171819202122232425`[root@HikvisionOS ~]# lsmod` `Module Size Used by``ip6t_rpfilter 12595 1` `ipt_REJECT 12541 2` `nf_reject_ipv4 13373 1 ipt_REJECT``ip6t_REJECT 12625 2` `nf_reject_ipv6 13717 1 ip6t_REJECT``xt_conntrack 12760 19` `ip_set 45644 0` `nfnetlink 14490 1 ip_set``ebtable_nat 12807 1` `ebtable_broute 12731 1` `bridge 151336 1 ebtable_broute``stp 12976 1 bridge``llc 14552 2 stp,bridge``ip6table_nat 12864 1` `nf_conntrack_ipv6 18935 11` `nf_defrag_ipv6 35104 1 nf_conntrack_ipv6``nf_nat_ipv6 14131 1 ip6table_nat``ip6table_mangle 12700 1` `ip6table_security 12710 1` `ip6table_raw 12683 1` `iptable_nat 12875 1` `nf_conntrack_ipv4 15053 10` `nf_defrag_ipv4 12729 1 nf_conntrack_ipv4` 3、卸载驱动模块在任何目录下， 输入命令 rmmod 注：“module_name”是lsmod显示的模块名称，而不是对应的ko文件名 五、编写生成.ko 文件Linux下hello.ko内核模块制作的全过程 1.linux系统用的是Redflag 6.0 SP1 下载地址：ftp://ftp.redflag-linux.com/pub/redflag/dt6sp1/SP1/redflag-6-sp1.iso， 系统安装很容易，安提示做就好。所用的内核源码目录树下载地址：ftp://ftp.redflag-linux.com/pub/redflag/dt6sp1/SP1/redflag-6-tool-sp1-src1.iso，将此iso文件挂载到/mnt下，安装其中的内核rpm包。挂载方法：mount -t iso9660 redflag-6-tool-sp1-src1.iso /mnt/ -o loop内核目录树安装方法：cd /mnt/RedFlag/SRMPS/ rpm -i kernel-2.6.23.1-4.src.rpm 2.编写hello模块代码，源码如下： hello.c 12345678910111213141516#include &lt;linux/init.h&gt; #include &lt;linux/module.h&gt; MODULE_LICENSE(&quot;GPL&quot;); static int hello_init(void) &#123; printk(KERN_ALERT &quot;Hello, world\\n&quot;); return 0; &#125; static void hello_exit(void) &#123; printk(KERN_ALERT &quot;Goodbye, cruel world\\n&quot;); &#125; module_init(hello_init); module_exit(hello_exit); 3.编写hello模块的Makefile文件，Makefile内容如下： 123456789101112Makefile#Makefile 2.6 obj-m :=hello.o KERNEL :=/usr/src/kernels/$(uname -r)/ PWD :=$(shell pwd) modules : $(MAKE) -C $(KERNEL) M=$(PWD) modules .PHONEY:clean clean : rm -f *.o *.ko 4.编译模块在命令行进入hello.c所在的文件夹下执行make命令即可完成hello模块的编译。用ls命令可以查看到hello.ko文件，此文件就是我们自定义的内核模块。 5.安装hello模块 命令行下执行命令：insmod hello.ko 。通过命令:cat /var/log/messages 可以看到下面这样的信息：“Aug 6 13:37:59 localhost kernel: Hello, world”，说明模块加载成功了。 6.另外一种模块Makefile的编写方法 Makefile 1234567891011121314151617181920# If KERNELRELEASE is defined, we&#x27;ve been invoked from the # kernel build system and can use its language. ifneq ($(KERNELRELEASE),) obj-m := hello.o # Otherwise we were called directly from the command # line; invoke the kernel build system. else KERNELDIR ?= /lib/modules/$(shell uname -r)/build PWD := $(shell pwd) default: $(MAKE) -C $(KERNELDIR) M=$(PWD) modules endif 卸载hello模块 命令行下执行命令：rmmod hello.ko即可。通过命令：cat /var/log/messages.可以看到下面这样的信息：“Aug 6 13:40:36 localhost kernel: Goodbye, cruel world”，说明模块卸载成功。 查看模块信息 命令行下执行命令：modinfo hello————————————————版权声明：本文为CSDN博主「worthsen」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。原文链接：https://blog.csdn.net/qq_38880380/article/details/79227760","categories":[{"name":"Linux","slug":"Linux","permalink":"https://hxlpub.github.io/categories/Linux/"}],"tags":[]},{"title":"服务器搭建之基于最小化系统centos7搭建服务器","slug":"linux_mini_system_config","date":"2021-09-14T09:26:07.000Z","updated":"2022-03-26T08:45:51.242Z","comments":true,"path":"2021/09/14/linux_mini_system_config/","link":"","permalink":"https://hxlpub.github.io/2021/09/14/linux_mini_system_config/","excerpt":"","text":"将自己的一台旧笔记本装成centos 7 配置服务器 网络配置 配置无线网卡（有网线的可以配置有线网卡）,一开始， 1.nmcli 查看网卡，我的无线网卡是wlp1s0,显示unmanaged， plugin missing，需要托管下并且安装NetworkManager-wifi模块 2.nmcli dev set wlp1s0 autoconnect yes managed yes 加入托管 3.在官网下载相应版本的rpm 包，我的是centos 7 版本NetworkManager-wifi-1.18.8-1.el7.x86_64.rpm ,拷贝到U盘 4.安装，yum install -y NetworkManager-wifi-1.18.8-1.el7.x86_64.rpm 5.安装完，重启下NetworkManager.service ,systemctl restart NetworkManager.service nmcli 查看 显示disconnected 6.连接无线 nmcli d wifi list：列出当前扫描出的热点 nmcli dev wifi connect “wifi名称” password “WiFi密码” 查看 nmcli dev show wlp1s0 已经connected 7.ping 一下自己另外的设备A，不通的，但是能ping 通网关还能ping www.baidu.com,而且在另外的设备A上ping 服务器B是通的：关闭A 防火墙 其他配置参考 [参考]: https://blog.csdn.net/chenkaifang/article/details/82531696 “CentOS7.5最小化安装之后的配置”","categories":[{"name":"Linux","slug":"Linux","permalink":"https://hxlpub.github.io/categories/Linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://hxlpub.github.io/tags/linux/"}]},{"title":"linux性能分析","slug":"linux_server_performance_analysis","date":"2021-09-14T09:26:07.000Z","updated":"2022-03-26T08:46:12.343Z","comments":true,"path":"2021/09/14/linux_server_performance_analysis/","link":"","permalink":"https://hxlpub.github.io/2021/09/14/linux_server_performance_analysis/","excerpt":"","text":"","categories":[{"name":"Linux","slug":"Linux","permalink":"https://hxlpub.github.io/categories/Linux/"}],"tags":[]},{"title":"shell","slug":"linux_shell","date":"2021-09-14T09:26:07.000Z","updated":"2022-03-26T09:09:40.092Z","comments":true,"path":"2021/09/14/linux_shell/","link":"","permalink":"https://hxlpub.github.io/2021/09/14/linux_shell/","excerpt":"","text":"1.符号 2.读文件方法 https://blog.csdn.net/feixiaohuijava/article/details/53129413","categories":[{"name":"Linux","slug":"Linux","permalink":"https://hxlpub.github.io/categories/Linux/"}],"tags":[{"name":"shell","slug":"shell","permalink":"https://hxlpub.github.io/tags/shell/"}]},{"title":"常用的开源资源","slug":"linux_sites","date":"2021-09-14T09:26:07.000Z","updated":"2022-03-26T09:10:59.432Z","comments":true,"path":"2021/09/14/linux_sites/","link":"","permalink":"https://hxlpub.github.io/2021/09/14/linux_sites/","excerpt":"","text":"ubuntu: Ubuntu 命令技巧","categories":[{"name":"Linux","slug":"Linux","permalink":"https://hxlpub.github.io/categories/Linux/"}],"tags":[{"name":"open_sites","slug":"open-sites","permalink":"https://hxlpub.github.io/tags/open-sites/"}]},{"title":"编译常见问题FAQ","slug":"linux_soft_manage_FAq","date":"2021-09-14T09:26:07.000Z","updated":"2022-03-26T09:11:23.177Z","comments":true,"path":"2021/09/14/linux_soft_manage_FAq/","link":"","permalink":"https://hxlpub.github.io/2021/09/14/linux_soft_manage_FAq/","excerpt":"","text":"1.执行dnf install python3 ：bash: /usr/bin/dnf: /usr/bin/python3: bad interpreter: No such file or directory 12345678#原因，安装其他软件导致python 版本同dnf 配置文件里的python 版本不一致[root@192 /]# whereis dnf dnf: /usr/bin/dnf /etc/dnf /usr/share/man/man8/dnf.8.gz[root@192 /]# vim /usr/bin/dnf#!/usr/bin/python3.9# The dnf executable script.# error while loading shared libraries: librte_telemetry.so.21: cannot open shared object file: No such file or directory 1234vim /etc/ld.so.conf#加入so lib path如/usr/local/daos/prereq/release/spdk/libldconfig 更新一下配置 3.ldd 查看 库 no found 123vim /etc/ld.so.conf 加相应的库路径，如/usr/local/daos/prereq/release/spdk/lib 后ldconfig","categories":[{"name":"Linux","slug":"Linux","permalink":"https://hxlpub.github.io/categories/Linux/"}],"tags":[{"name":"编译FAQ","slug":"编译FAQ","permalink":"https://hxlpub.github.io/tags/%E7%BC%96%E8%AF%91FAQ/"}]},{"title":"学习思路","slug":"machine-learning","date":"2021-09-14T09:26:07.000Z","updated":"2022-03-26T09:11:36.082Z","comments":true,"path":"2021/09/14/machine-learning/","link":"","permalink":"https://hxlpub.github.io/2021/09/14/machine-learning/","excerpt":"","text":"","categories":[{"name":"机器学习","slug":"机器学习","permalink":"https://hxlpub.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"ML","slug":"ML","permalink":"https://hxlpub.github.io/tags/ML/"}]},{"title":"vscode extensions离线下载安装","slug":"vscode_extensions","date":"2021-09-14T09:26:07.000Z","updated":"2022-03-26T09:12:24.690Z","comments":true,"path":"2021/09/14/vscode_extensions/","link":"","permalink":"https://hxlpub.github.io/2021/09/14/vscode_extensions/","excerpt":"","text":"1.windows step1 ：下载扩展包，https://marketplace.visualstudio.com/search?term=go&amp;target=VSCode&amp;category=All%20categories&amp;sortBy=Relevance ,并放到vscode bin 下 step2：安装，bin下右键打开命令行工具，执行 1code --install-extension *.vsix step3: 显示安装完成 Extension ‘yzhang.markdown-all-in-one-1.4.0.vsix’ was successfully installed!","categories":[{"name":"开发工具","slug":"开发工具","permalink":"https://hxlpub.github.io/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"vscode_extensions","slug":"vscode-extensions","permalink":"https://hxlpub.github.io/tags/vscode-extensions/"}]},{"title":"go_linux编译运行环境搭建","slug":"go_compile","date":"2021-09-13T14:29:54.000Z","updated":"2022-03-26T08:25:20.274Z","comments":true,"path":"2021/09/13/go_compile/","link":"","permalink":"https://hxlpub.github.io/2021/09/13/go_compile/","excerpt":"","text":"1.最直接的方式​ 官网提供了第一手资料，十分全面，可以根据自己的系统（windows、linux、mac）选择自己的下载和安装方式 点击进入官网 2.源码编译方式2.1 准备 交叉编译工具链： 交叉编译：是A机器上编译生成，运行在B机器上。两个机子有不同的机器指令。 工具链：一般由编译器、连接器、解释器和调试器组成。 构建交叉工具链方法： 方法一：分步编译和安装交叉编译工具链所需要的库和源代码，最终生成交叉编译工具链。该方法相对比较困难，适合想深入学习构建交叉工具链的读者。如果只是想使用交叉工具链，建议使用下列的方法二构建交叉工具链。 方法二 通过Crosstool脚本工具来实现一次编译，生成交叉编译工具链，该方法相对于方法一要简单许多，并且出错的机会也非常少，建议大多数情况下使用该方法构建交叉编译工具链。 方法三 直接通过网上下载已经制作好的交叉编译工具链。该方法的优点不用多说，当然是简单省事，但该方法有一定的弊端就是局限性太大，因为毕竟是别人构建好的，也就是固定的，没有灵活性，所以构建所用的库以及编译器的版本也许并不适合你要编译的程序，同时也许会在使用时出现许多莫名其妙的错误，建议读者慎用此方法。 2.2 安装编译工具链3.编译参数","categories":[{"name":"golang","slug":"golang","permalink":"https://hxlpub.github.io/categories/golang/"}],"tags":[{"name":"golang","slug":"golang","permalink":"https://hxlpub.github.io/tags/golang/"}]},{"title":"golang之fan-out模式","slug":"go_fan-out","date":"2021-09-13T14:29:54.000Z","updated":"2022-03-26T08:25:14.339Z","comments":true,"path":"2021/09/13/go_fan-out/","link":"","permalink":"https://hxlpub.github.io/2021/09/13/go_fan-out/","excerpt":"","text":"Go 语言在构建微服务、特别是有使用 gRPC 的应用中，非常地流行，其实在构建命令行程序时也是特别地好用。为了学习扇出模式，我会基于我们公司使用 ETL 的例子，来介绍这个模式。 ## ETL ETL（提取（Extract），转换（Transform），加载（Load））通常都需要处理大量的数据。在这样的场景下，有一个好的并发策略对于 ETL 来说，能够带来巨大的性能提升。 ETL 中有两个最重要的部分是提取（extracting）和加载（Load），通常它们都跟数据库有关，瓶颈通常也属于老生常谈的话题：网络带宽，查询性能等等。基于我们要处理的数据以及瓶颈所在，两种模式对于处理数据或者处理输入流的编码和解码过程中，非常有用。 ## 扇入扇出模式（Fan-in, fan-out pattern） 扇入和扇出模式在并发场景中能得到较大的好处。这里将对它们逐个做专门的介绍（review）： 扇出，在 GO 博客中这样定义： 多个函数能够同时从相同的 channel 中读数据，直到 channel 关闭。 这种模式在快速输入流到分布式数据处理中，有一定的优势： 扇入，在 Google 这样定义： 一个函数可以从多个输入中读取，并继续操作，直到所有 channel 所关联的输入端，都已经关闭。 这种模式，在有多个输入源，且需要快速地数据处理中，有一定的优势： ## 在实际中使用扇出模式（Fan-out in action） 在我们的项目中，我们需要处理存储在 CSV 文件的大量数据，它们加载后，将在 elastic 中被检索。输入的处理必须快，否则（阻塞加载）加载就会变得很慢。因此，我们需要比输入生成器更多的数据处理器。扇出模式在这个例子中，看起来非常适合： 下面是我们的伪代码： bash Variables: data chan Start: // a goroutine will parse the CSV and will send it to the channel ParseCSV(data&lt;-) // a goroutine is started for each workers, defined as command line arguments For each worker in workers Start goroutine For each value in &lt;-data Insert the value in database by chunk of 50 Wait for the workers Stop 输入和加载程序是并发执行的，我们不需要等到解析完成后再开始启动数据处理程序。 这种模式让我们可以单独考虑业务逻辑的同时，还可以使用（Go)并发的特性。几个工作器之间原生的分布式负载能力，有助于我们解决此类过程中的峰值负载问题。","categories":[{"name":"golang","slug":"golang","permalink":"https://hxlpub.github.io/categories/golang/"}],"tags":[{"name":"golang","slug":"golang","permalink":"https://hxlpub.github.io/tags/golang/"}]},{"title":"golang之内建函数","slug":"go_func_builtin","date":"2021-09-13T14:29:54.000Z","updated":"2022-03-26T08:25:43.812Z","comments":true,"path":"2021/09/13/go_func_builtin/","link":"","permalink":"https://hxlpub.github.io/2021/09/13/go_func_builtin/","excerpt":"","text":"1、new and make :https://www.jb51.net/article/126703.htm","categories":[{"name":"golang","slug":"golang","permalink":"https://hxlpub.github.io/categories/golang/"}],"tags":[{"name":"golang","slug":"golang","permalink":"https://hxlpub.github.io/tags/golang/"}]},{"title":"import rules","slug":"go_import_rules","date":"2021-09-13T14:29:54.000Z","updated":"2022-03-26T08:26:16.178Z","comments":true,"path":"2021/09/13/go_import_rules/","link":"","permalink":"https://hxlpub.github.io/2021/09/13/go_import_rules/","excerpt":"","text":"https://www.cnblogs.com/f-ck-need-u/p/9847554.html","categories":[{"name":"golang","slug":"golang","permalink":"https://hxlpub.github.io/categories/golang/"}],"tags":[{"name":"golang","slug":"golang","permalink":"https://hxlpub.github.io/tags/golang/"}]},{"title":"golang标准包packages","slug":"go_packages","date":"2021-09-13T14:29:54.000Z","updated":"2022-03-26T08:27:50.697Z","comments":true,"path":"2021/09/13/go_packages/","link":"","permalink":"https://hxlpub.github.io/2021/09/13/go_packages/","excerpt":"","text":"","categories":[{"name":"golang","slug":"golang","permalink":"https://hxlpub.github.io/categories/golang/"}],"tags":[{"name":"golang","slug":"golang","permalink":"https://hxlpub.github.io/tags/golang/"}]},{"title":"notes","slug":"love","date":"2021-09-12T09:05:23.000Z","updated":"2022-03-26T08:48:12.204Z","comments":true,"path":"2021/09/12/love/","link":"","permalink":"https://hxlpub.github.io/2021/09/12/love/","excerpt":"","text":"ps:宝宝，爱你！！！","categories":[{"name":"startup","slug":"startup","permalink":"https://hxlpub.github.io/categories/startup/"}],"tags":[{"name":"love","slug":"love","permalink":"https://hxlpub.github.io/tags/love/"}]}],"categories":[{"name":"Linux","slug":"Linux","permalink":"https://hxlpub.github.io/categories/Linux/"},{"name":"Python","slug":"Python","permalink":"https://hxlpub.github.io/categories/Python/"},{"name":"分布式异步存储系统","slug":"分布式异步存储系统","permalink":"https://hxlpub.github.io/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E5%BC%82%E6%AD%A5%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F/"},{"name":"startup","slug":"startup","permalink":"https://hxlpub.github.io/categories/startup/"},{"name":"设计模式","slug":"设计模式","permalink":"https://hxlpub.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"golang","slug":"golang","permalink":"https://hxlpub.github.io/categories/golang/"},{"name":"编译","slug":"编译","permalink":"https://hxlpub.github.io/categories/%E7%BC%96%E8%AF%91/"},{"name":"c","slug":"c","permalink":"https://hxlpub.github.io/categories/c/"},{"name":"cplusplus","slug":"cplusplus","permalink":"https://hxlpub.github.io/categories/cplusplus/"},{"name":"Hexo","slug":"Hexo","permalink":"https://hxlpub.github.io/categories/Hexo/"},{"name":"算法","slug":"算法","permalink":"https://hxlpub.github.io/categories/%E7%AE%97%E6%B3%95/"},{"name":"计算机视觉CV","slug":"计算机视觉CV","permalink":"https://hxlpub.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89CV/"},{"name":"数据库","slug":"数据库","permalink":"https://hxlpub.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"深度学习","slug":"深度学习","permalink":"https://hxlpub.github.io/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"},{"name":"开发工具","slug":"开发工具","permalink":"https://hxlpub.github.io/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"},{"name":"机器学习","slug":"机器学习","permalink":"https://hxlpub.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"systemd","slug":"systemd","permalink":"https://hxlpub.github.io/tags/systemd/"},{"name":"python","slug":"python","permalink":"https://hxlpub.github.io/tags/python/"},{"name":"分布式存储","slug":"分布式存储","permalink":"https://hxlpub.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8/"},{"name":"love more","slug":"love-more","permalink":"https://hxlpub.github.io/tags/love-more/"},{"name":"设计模式","slug":"设计模式","permalink":"https://hxlpub.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"golang","slug":"golang","permalink":"https://hxlpub.github.io/tags/golang/"},{"name":"Makefile","slug":"Makefile","permalink":"https://hxlpub.github.io/tags/Makefile/"},{"name":"c","slug":"c","permalink":"https://hxlpub.github.io/tags/c/"},{"name":"cplusplus","slug":"cplusplus","permalink":"https://hxlpub.github.io/tags/cplusplus/"},{"name":"Hexo","slug":"Hexo","permalink":"https://hxlpub.github.io/tags/Hexo/"},{"name":"排序算法","slug":"排序算法","permalink":"https://hxlpub.github.io/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"},{"name":"编译","slug":"编译","permalink":"https://hxlpub.github.io/tags/%E7%BC%96%E8%AF%91/"},{"name":"cv","slug":"cv","permalink":"https://hxlpub.github.io/tags/cv/"},{"name":"postgres","slug":"postgres","permalink":"https://hxlpub.github.io/tags/postgres/"},{"name":"pg","slug":"pg","permalink":"https://hxlpub.github.io/tags/pg/"},{"name":"DL","slug":"DL","permalink":"https://hxlpub.github.io/tags/DL/"},{"name":"版本管理","slug":"版本管理","permalink":"https://hxlpub.github.io/tags/%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86/"},{"name":"Linux","slug":"Linux","permalink":"https://hxlpub.github.io/tags/Linux/"},{"name":"linux","slug":"linux","permalink":"https://hxlpub.github.io/tags/linux/"},{"name":"shell","slug":"shell","permalink":"https://hxlpub.github.io/tags/shell/"},{"name":"open_sites","slug":"open-sites","permalink":"https://hxlpub.github.io/tags/open-sites/"},{"name":"编译FAQ","slug":"编译FAQ","permalink":"https://hxlpub.github.io/tags/%E7%BC%96%E8%AF%91FAQ/"},{"name":"ML","slug":"ML","permalink":"https://hxlpub.github.io/tags/ML/"},{"name":"vscode_extensions","slug":"vscode-extensions","permalink":"https://hxlpub.github.io/tags/vscode-extensions/"},{"name":"love","slug":"love","permalink":"https://hxlpub.github.io/tags/love/"}]}