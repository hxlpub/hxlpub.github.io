{"meta":{"title":"Hongxun's Blog","subtitle":"","description":"沉淀技术","author":"Hongxun","url":"https://hxlpub.github.io","root":"/"},"pages":[{"title":"关于","date":"2023-05-27T11:21:31.095Z","updated":"2023-05-27T11:21:31.095Z","comments":false,"path":"about/index.html","permalink":"https://hxlpub.github.io/about/index.html","excerpt":"","text":"个人详细介绍"},{"title":"Hi，there","date":"2023-05-27T11:32:54.061Z","updated":"2023-05-27T11:32:54.061Z","comments":false,"path":"home/index.html","permalink":"https://hxlpub.github.io/home/index.html","excerpt":"","text":"Let’s learn something interesting and make it work!!!"},{"title":"标签","date":"2022-03-13T09:25:23.619Z","updated":"2022-03-13T09:25:23.619Z","comments":false,"path":"tags/index.html","permalink":"https://hxlpub.github.io/tags/index.html","excerpt":"","text":""},{"title":"书单","date":"2022-03-13T09:28:04.918Z","updated":"2022-03-13T09:28:04.918Z","comments":false,"path":"books/index.html","permalink":"https://hxlpub.github.io/books/index.html","excerpt":"","text":""},{"title":"Categories","date":"2023-05-27T10:23:38.465Z","updated":"2023-05-27T10:23:38.465Z","comments":false,"path":"categories/index.html","permalink":"https://hxlpub.github.io/categories/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2022-03-13T09:14:18.985Z","updated":"2022-03-12T13:59:18.462Z","comments":false,"path":"repository/index.html","permalink":"https://hxlpub.github.io/repository/index.html","excerpt":"","text":""}],"posts":[{"title":"【分布式对象存储】从0搭建框架：单机","slug":"build-distributed-objstor-system-frame-from-zero","date":"2022-12-03T04:10:07.000Z","updated":"2023-05-28T10:18:10.736Z","comments":true,"path":"2022/12/03/build-distributed-objstor-system-frame-from-zero/","link":"","permalink":"https://hxlpub.github.io/2022/12/03/build-distributed-objstor-system-frame-from-zero/","excerpt":"","text":"1.什么是对象存储？对象存储也称为基于对象的存储，是一种计算机数据存储架构，旨在处理大量非结构化数据。与其他架构不同，它将数据指定为不同的单元，并捆绑元数据和唯一标识符，用于查找和访问每个数据单元。 这些单元（或对象）可以存储在本地，但通常存储在云端，以便于从任何地方轻松访问数据。由于对象存储具有横向扩容能力，它的可伸缩性几乎没有限制，并且存储大量数据的成本也低于块存储等其他存储方法。 如今的许多数据都是非结构化的，无法很好地存储在传统数据库中，包括电子邮件、媒体和音频文件、网页、传感器数据和其他类型的数字内容。因此，寻找高效且经济实惠的方法来存储和管理这类数据成为了一个难点。越来越多的企业将对象存储作为存储静态内容、数据架构和备份的首选方法。 对象存储定义 对象存储是用于存储非结构化数据的数据存储架构，它将数据划分为单元（对象），并存储在结构扁平的数据环境中。每个对象都包含数据以及应用可用于轻松访问和检索对象的元数据和唯一标识符。 工作原理 在对象存储中，一个文件的数据块被共同保存为一个对象，并连同其相关的元数据和自定义标识符放入被称为存储池的扁平数据环境中。 当您需要访问数据时，对象存储系统将使用唯一标识符和元数据来查找所需的对象，例如图片或音频文件。您还可以自定义元数据，从而添加可用于其他用途（例如用于数据分析的检索）的上下文。 您可以使用 RESTful API、HTTP 和 HTTPS 查询对象元数据，以查找和访问对象。由于对象存储在全局存储池中，因此您可以快速轻松地找到所需的确切数据。此外，扁平环境使您能够快速扩容，即便是 PB 或 EB 级负载也毫不费力。存储池可以分布在多个对象存储设备和地理位置中，因此规模不受限制。随着数据量的增长，您只需向池中添加更多存储设备即可。 对象存储的优势（例如弹性和可伸缩性）使其成为管理云基础架构中非结构化数据的理想选择。那么，什么是云对象存储呢？顾名思义，也就是作为按需云服务提供的基于对象的存储。事实上，对于大多数大型云服务提供商而言，云对象存储是主要的存储格式。 2.传统的网络存储网络存储（Network Storage）是数据存储的一种方式，网络存储结构大致分为三种：直连式存储（DAS：Direct Attached Storage）、网络附加存储（NAS：Network Attached Storage）和存储区域网（SAN：Storage Area Network）。由于NAS对于普通消费者而言较为熟悉，所以一般网络存储都指NAS。 网络存储被定义为一种特殊的专用数据存储服务器，包括存储器件（例如磁盘阵列、CD/DVD驱动器、磁带驱动器或可移动的存储介质）和内嵌系统软件，可提供跨平台文件共享功能。网络存储通常在一个LAN上占有自己的节点，无需应用服务器的干预，允许用户在网络上存取数据，在这种配置中，网络存储集中管理和处理网络上的所有数据，将负载从应用或企业服务器上卸载下来，有效降低总拥有成本，保护用户投资。 NAS（Network Attached Storage-网络附着存储），是一个可提供存储功能和文件系统的网络服务器，客户端可访问NAS上的文件系统，还可上传下载文件，客户端和服务端之间使用的协议有SMB、NFS以及AFS等网络文件系统协议。即将存储设备通过标准的网络拓扑结构（例如以太网）连接到一群计算机上。NAS是部件级的存储方法，它的重点在于帮助解决迅速增加存储容量的需求。 SAN(Storage Area Network存储区域网络)通过光纤通道连接到一群计算机上。在该网络中提供了多台主机连接，但并非通过标准的网络拓扑。只提供块存储，而把文件系统的抽象交给客户端来管理。对客户端来说，SAN就是一块磁盘，可以对其格式化、创建文件系统并挂载。客户端和服务端使用的协议有Fibre Channel、iSCSI、ATA over Ethernet(AoE) 和HyperSCSI。 现在的网络存储通常将SAN和NAS混合使用，同时提供文件级别和协议和块级别的协议。 3.对象存储与传统网络存储区别 文件存储 文件存储将数据存储和整理到文件夹中，类似于您保存在办公室的纸质文件系统中的物理文件。如果您需要某个文件中的信息，则需要知道哪个房间、文件柜、抽屉和文件夹包含该特定文件。文件存储使用相同的分层存储结构，文件被命名，以元数据标记，然后放入文件夹中。 要找到某个数据，您需要知道查找该数据的正确路径。随着时间的推移，文件变得越来越多，搜索和检索数据文件可能会变得非常耗时。虽然可伸缩性较为有限，但通过这种方法可以很容易地存储几乎任何类型的少量数据，并且可供多个用户同时访问。 块存储 块存储在文件存储的基础上提升了性能，它将文件拆分为多个单独的块并单独存储。块存储系统会为每个原始数据块分配一个唯一标识符，当您需要访问完整的文件时，系统将使用唯一标识符将数据块重组为完整的文件。块存储不需要单一的数据路径，因此您可以将其存储在最方便的位置，并且在需要时仍然能够快速检索。 块存储非常适合需要处理大量事务型数据或使用任务关键型应用的组织，可提供低延迟和一致的性能。但是，块存储费用高昂，不提供元数据功能，并且需要操作系统才能访问块。 对象存储 如前所述，对象存储将文件存储为扁平数据环境（即存储池）中的独立对象，对象包含全部数据、唯一标识符和详细元数据（元数据包含关于数据、权限、政策和其他应急情况的信息）。对象存储最适合非结构化数据的静态存储，您只写入一次数据，但可能需要多次读取。 虽然对象存储不需要目录、文件夹和其他复杂的分层结构，但却不适合用来存储不断变化的动态数据，因为修改对象需要重写整个对象。根据您的速度和性能要求，在某些情况下文件存储和块存储可能仍然适合您的需求。 访问数据方式 网络文件系统的客户端通过NFS等网络协议访问某个远程服务器上存储的文件； 块存储的客户端通过数据块的地址访问SAN上的数据块。 对象存储则通过REST网络服务访问对象。 4.对象存储的优势 可伸缩性强 您可以轻松横向扩容对象存储的扁平架构，而不会受到文件存储或块存储那样的限制。对象存储基本没有大小限制，因此只需添加新设备，即可将数据扩大到 EB 级。 复杂性低 对象存储没有文件夹或目录，也就不具有层次结构系统的大多数复杂性。由于没有复杂的树或分区，检索文件变得十分轻松，因为您不需要知道确切位置。 易于搜索 元数据是对象的一部分，使您无需借助单独的应用即可轻松搜索和导航。它也更加灵活，并且可以深度自定义。您可以使用各种特性和信息来为对象添加标记，例如用量、费用以及自动删除、保留和分层的政策。 具有弹性 对象存储可以自动复制数据并存储在多个设备和多个地理位置。这有助于防范服务中断和数据丢失，并可为灾难恢复策略提供支持。 成本效益高 对象存储在设计时考虑了成本因素，与基于文件和块的系统相比，能够以更低的价格存储大量数据。使用对象存储时，您只为需要的容量付费，即使存储大量数据，也能很好地控制费用。 5.单机版对象存储架构6.单机版对象存储接口7.代码实现过程8.效果展示","categories":[{"name":"分布式存储","slug":"分布式存储","permalink":"https://hxlpub.github.io/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8/"}],"tags":[{"name":"分布式对象存储","slug":"分布式对象存储","permalink":"https://hxlpub.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AF%B9%E8%B1%A1%E5%AD%98%E5%82%A8/"}]},{"title":"【C】c pointer","slug":"c-pointer","date":"2022-06-25T12:57:55.000Z","updated":"2023-05-28T10:26:55.100Z","comments":true,"path":"2022/06/25/c-pointer/","link":"","permalink":"https://hxlpub.github.io/2022/06/25/c-pointer/","excerpt":"","text":"double pointer12345678910111213141516171819202122232425#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;int change_ptr(int** ptr);int main()&#123; //int local =3; int *p =NULL; //*p = local; //printf(&quot;old *p =%d&quot;,p); printf(&quot;old p =%p\\n&quot;,p); //printf(&quot;old =%p&quot;,p); change_ptr(&amp;p); printf(&quot;*p=%d\\n&quot;,*p); printf(&quot;new p =%p\\n&quot;,p); return 0;&#125;int change_ptr (int **ptr)&#123; int *tmp = NULL; tmp = malloc(sizeof(int)); *tmp = 4 ; *ptr = tmp ; return 0;&#125; Makefile: 1234567make: gcc -g hello_rpms.c -o hello_rpmsclean: rm hello_rpmsinstall: mkdir -p $&#123;DESTDIR&#125;/usr/bin install -m 0755 hello_rpms $&#123;DESTDIR&#125;/usr/bin/hello_rpms","categories":[{"name":"编程语言","slug":"编程语言","permalink":"https://hxlpub.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"C","slug":"C","permalink":"https://hxlpub.github.io/tags/C/"}]},{"title":"How to be a rpms maker","slug":"linux-to-be-rpms-maker","date":"2022-06-25T07:32:23.000Z","updated":"2022-07-09T08:34:09.452Z","comments":true,"path":"2022/06/25/linux-to-be-rpms-maker/","link":"","permalink":"https://hxlpub.github.io/2022/06/25/linux-to-be-rpms-maker/","excerpt":"","text":"Reference: https://bbs.huaweicloud.com/forum/thread-38327-1-1.html Prerequisites1234567On Fedora, CentOS 8, and RHEL 8:$ dnf install gcc rpm-build rpm-devel rpmlint make python bash coreutils diffutilspatch rpmdevtoolsOn CentOS 7 and RHEL 7:$ yum install gcc rpm-build rpm-devel rpmlint make python bash coreutils diffutilspatch rpmdevtools3 My First RPM Package1.spec file with several things skipped and simplified:(put a bash script in /usr/bin) 123456789101112131415161718192021222324252627Name: hello-worldVersion: 1Release: 1Summary: Most simple RPM packageLicense: FIXME%descriptionthis is my first RPM package ,which does nothing.%prep#we have no source ,so nothing here.%buildcat &gt; hello-world.sh &lt;&lt; EOF#!/usr/bin/bash echo hello worldEOF%installmkdir -p %&#123;buildroot&#125;/usr/bininstall -m 755 hello-world.sh %&#123;buildroot&#125;/usr/bin/hello-world.sh%files/usr/bin/hello-world.sh%changelog* Sat Jun 25 2022 root 2.rpmbuild 1rpmbuild -ba rpmbuild/SPECS/hello_world.spec 3.install her 1rpm -ivh rpmbuild/RPMS/x86_64/hello-world-1-1.x86_64.rpm 4.validate her 1234[root@hik ~]# ll /usr/bin/hello-world.sh -rwxr-xr-x. 1 root root 35 Jun 25 19:56 /usr/bin/hello-world.sh[root@hik ~]# /usr/bin/hello-world.sh hello world Preparing Software For Packaging Source codes including Makefile Patch Software Installing arbitrary Artifacts In the context of this guide, an Arbitrary Artifact is anything installed from an RPM to the system. For RPM and for the system it can be a script, a binary compiled from the package’s source code, apre-compiled binary, or any other file. We will explore two popular ways of placing Arbitrary Artifacts in the system: using the installcommand and using the make install command. Using the install command Sometimes using build automation tooling such as GNU make is not optimal - for example, if thepackaged program is simple and does not need extra overhead. In these cases, packagers often usethe install command (provided to the system by coreutils), which places the artifact to thespecified directory in the filesystem with a specified set of permissions. eg. 1$ sudo install -m 0755 bello /usr/bin/bello Using the make install command A popular automated way to install built software to the system is to use the make installcommand. It requires you to specify how to install the arbitrary artifacts to the system in theMakefile.NOTE Usually Makefile is written by the developer and not by the packager.Add the install section to the Makefile: 1234567cello: gcc -g -o cello cello.cclean: rm celloinstall: mkdir -p $(DESTDIR)/usr/bin install -m 0755 cello $(DESTDIR)/usr/bin/cello Preparing Source Code for Packaging My eg. 1234567[root@hik hello_rpm-1.0]# ll total 36-rwxr-xr-x. 1 root root 27560 Jun 25 20:48 hello_rpms-rw-r--r--. 1 root root 411 Jun 25 20:39 hello_rpms.c-rw-r--r--. 1 root root 160 Jun 25 20:47 Makefile[root@hik hello_rpm-1.0]# Makefile: 1234567make: gcc -g hello_rpms.c -o hello_rpmsclean: rm hello_rpmsinstall: mkdir -p $&#123;DESTDIR&#125;/usr/bin install -m 0755 hello_rpms $&#123;DESTDIR&#125;/usr/bin/hello_rpms validate her: 123456789[root@hik hello_rpm-1.0]# makegcc -g hello_rpms.c -o hello_rpms[root@hik hello_rpm-1.0]# make installmkdir -p /usr/bininstall -m 0755 hello_rpms /usr/bin/hello_rpms[root@hik hello_rpm-1.0]# hello_rpms #test for double pointerold p =(nil)*p=4new p =0x11ee6b0 Putting Source Code Into Tarball Prepare the cello project for distribution: 1234561.Put the files into a single directory hello_rpm-1.0 and Create the archive for distribution[root@hik SOURCES]# tar -czvf hello_rpm-1.0.tar.gz hello_rpm-1.0/*hello_rpm-1.0/hello_rpms.chello_rpm-1.0/Makefile2.Move her to ~/rpmbuild/SOURCES/3. Add the patch: (later blog version) Packaging Software1.RPM Packages What is an RPM? An RPM package is simply a file containing other files and information about them needed by thesystem. Specifically, an RPM package consists of the cpio archive, which contains the files, and theRPM header, which contains metadata about the package. The rpm package manager uses thismetadata to determine dependencies, where to install files, and other information.There are two types of RPM packages: • source RPM (SRPM) • binary RPM SRPMs and binary RPMs share the file format and tooling, but have different contents and servedifferent purposes. An SRPM contains source code, optionally patches to it, and a SPEC file, whichdescribes how to build the source code into a binary RPM. A binary RPM contains the binaries builtfrom the sources and patches. RPM Packaging Tools rpmdevtools RPM Packaging Workspace To set up a directory layout that is the RPM packaging workspace, use the rpmdev-setuptree utility: 123456789$ rpmdev-setuptree #生成 目录$ tree ~/rpmbuild/ #查看/home/user/rpmbuild/|-- BUILD|-- RPMS|-- SOURCES|-- SPECS`-- SRPMS5 directories, 0 files The created directories serve these purposes: Directory Purpose BUILD When packages are built, various %buildroot directories are created here. Thisis useful for investigating a failed build if the logs output do not provideenough information. RPMS Binary RPMs are created here, in subdirectories for different architectures, forexample in subdirectories x86_64 and noarch. SOURCES Here, the packager puts compressed source code archives and patches. Therpmbuild command looks for them here. SPECS The packager puts SPEC files here. SRPMS When rpmbuild is used to build an SRPM instead of a binary RPM, the resultingSRPM is created here. What is a SPEC File? A SPEC file can be thought of as the “recipe” that the rpmbuild utility uses to actually build an RPM.It tells the build system what to do by defining instructions in a series of sections. The sections aredefined in the Preamble and the Body. The Preamble contains a series of metadata items that areused in the Body. The Body contains the main part of the instructions. Preamble Items This table lists the items used in the Preamble section of the RPM SPEC file: SPEC Directive Definition Name The base name of the package, which should match the SPEC filename. Version The upstream version number of the software. Release The number of times this version of the software was released.Normally, set the initial value to 1%{?dist}, and increment it witheach new release of the package. Reset to 1 when a new Version ofthe software is built. Summary A brief, one-line summary of the package. License The license of the software being packaged. For packages distributedin community distributions such as Fedora this must be an opensource license abiding by the specific distribution’s licensingguidelines. URL The full URL for more information about the program. Most oftenthis is the upstream project website for the software being packaged. Source0 Path or URL to the compressed archive of the upstream source code(unpatched, patches are handled elsewhere). This should point to anaccessible and reliable storage of the archive, for example, theupstream page and not the packager’s local storage. If needed, moreSourceX directives can be added, incrementing the number eachtime, for example: Source1, Source2, Source3, and so on. Patch0 The name of the first patch to apply to the source code if necessary.If needed, more PatchX directives can be added, incrementing thenumber each time, for example: Patch1, Patch2, Patch3, and so on. BuildArch If the package is not architecture dependent, for example, if writtenentirely in an interpreted programming language, set this toBuildArch: noarch. If not set, the package automatically inherits theArchitecture of the machine on which it is built, for example x86_64. BuildRequires A comma- or whitespace-separated list of packages required forbuilding the program written in a compiled language. There can bemultiple entries of BuildRequires, each on its own line in the SPECfile. Requires A comma- or whitespace-separated list of packages required by thesoftware to run once installed. There can be multiple entries ofRequires, each on its own line in the SPEC file. ExcludeArch If a piece of software can not operate on a specific processorarchitecture, you can exclude that architecture here. RPM package filenames have the NAME-VERSION-RELEASE format: eg.python-2.7.5-34.el7.x86_64 Body Items This table lists the items used in the Body section of the RPM SPEC file: SPEC Directive Definition %description full description of the software packaged in the RPM. This description canspan multiple lines and can be broken into paragraphs. %prep Command or series of commands to prepare the software to be built, forexample, unpacking the archive in Source0. This directive can contain a shellscript. %build Command or series of commands for actually building the software intomachine code (for compiled languages) or byte code (for some interpretedlanguages). %install Command or series of commands for copying the desired build artifacts fromthe %builddir (where the build happens) to the %buildroot directory (whichcontains the directory structure with the files to be packaged). This usuallymeans copying files from ~/rpmbuild/BUILD to ~/rpmbuild/BUILDROOT andcreating the necessary directories in ~/rpmbuild/BUILDROOT. This is only runwhen creating a package, not when the end-user installs the package. SeeWorking with SPEC files for details. %check Command or series of commands to test the software. This normally includesthings such as unit tests. %files The list of files that will be installed in the end user’s system %changelog A record of changes that have happened to the package between differentVersion or Release builds. Advanced items The SPEC file can also contain advanced items. For example, a SPEC file can have scriptlets andtriggers. They take effect at different points during the installation process on the end user’s system(not the build process).See the Scriptlets and Triggers for advanced topics. BuildRoots RPM Macros rpm –eval %{_MACRO} #check for a Macro Macros %{version} %{?dist} distribution tag More on Macros Working with SPEC files FAQ [Found ‘${BUILDROOT}’ in installed files; aborting]: http://adam.younglogic.com/2010/05/found-buildroot-in-installed-files-aborting/","categories":[{"name":"Linux","slug":"Linux","permalink":"https://hxlpub.github.io/categories/Linux/"}],"tags":[{"name":"rpm","slug":"rpm","permalink":"https://hxlpub.github.io/tags/rpm/"}]},{"title":"how to use xmind efficently","slug":"to-use-xmind","date":"2022-06-18T13:00:25.000Z","updated":"2022-06-19T01:52:02.600Z","comments":true,"path":"2022/06/18/to-use-xmind/","link":"","permalink":"https://hxlpub.github.io/2022/06/18/to-use-xmind/","excerpt":"","text":"Here are some simple tips for using xmind . tip1. choose theme u like tip2. choose theme u like tip3. choose theme u like","categories":[{"name":"开发工具","slug":"开发工具","permalink":"https://hxlpub.github.io/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"xmind","slug":"xmind","permalink":"https://hxlpub.github.io/tags/xmind/"}]},{"title":"【C】搭建C知识体系：知识map","slug":"c-learn-roadmap","date":"2022-06-18T11:51:24.000Z","updated":"2023-05-28T10:25:13.504Z","comments":true,"path":"2022/06/18/c-learn-roadmap/","link":"","permalink":"https://hxlpub.github.io/2022/06/18/c-learn-roadmap/","excerpt":"","text":"本文目的： 系统化C知识体系，提效开发，提高生产力。 xmind:","categories":[{"name":"编程语言","slug":"编程语言","permalink":"https://hxlpub.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"C","slug":"C","permalink":"https://hxlpub.github.io/tags/C/"}]},{"title":"linux_coredump","slug":"linux-coredump","date":"2022-06-13T06:30:45.000Z","updated":"2022-06-30T12:14:38.159Z","comments":true,"path":"2022/06/13/linux-coredump/","link":"","permalink":"https://hxlpub.github.io/2022/06/13/linux-coredump/","excerpt":"","text":"from https://www.cnblogs.com/Anker/p/6079580.html linux下core dump【总结】1、前言 一直在从事linux下后台开发，经常与core文件打交道。还记得刚开始从事linux下开发时，程序突然崩溃了，也没有任何日志。我不知所措，同事叫我看看core，我却问什么是core，怎么看。同事鄙视的眼神，我依然在目。后来学会了从core文件中分析原因，通过gdb看出程序挂再哪里，分析前后的变量，找出问题的原因。当时就觉得很神奇，core文件是怎么产生的呢？难道系统会自动产生，可是我在自己的linux系统上面写个非法程序测试，并没有产生core问题？这又是怎么回事呢？今天在ngnix的源码时候，发现可以在程序中设置core dump，又是怎么回事呢？在公司发现生成的core文件都带有进程名称、进程ID、和时间，这又是怎么做到的呢？今天带着这些疑问来说说core文件是如何生成，如何配置。 2、基本概念 当程序运行的过程中异常终止或崩溃，操作系统会将程序当时的内存状态记录下来，保存在一个文件中，这种行为就叫做Core Dump（中文有的翻译成“核心转储”)。我们可以认为 core dump 是“内存快照”，但实际上，除了内存信息之外，还有些关键的程序运行状态也会同时 dump 下来，例如寄存器信息（包括程序指针、栈指针等）、内存管理信息、其他处理器和操作系统状态和信息。core dump 对于编程人员诊断和调试程序是非常有帮助的，因为对于有些程序错误是很难重现的，例如指针异常，而 core dump 文件可以再现程序出错时的情景。 3、开启core dump 可以使用命令ulimit开启，也可以在程序中通过setrlimit系统调用开启。 程序中开启core dump，通过如下API可以查看和设置RLIMIT_CORE 1234#include &lt;sys/resource.h&gt;int getrlimit(int resource, struct rlimit *rlim);int setrlimit(int resource, const struct rlimit *rlim); 参考程序如下所示： 12345678910111213141516171819202122232425262728293031#include &lt;unistd.h&gt;#include &lt;sys/time.h&gt;#include &lt;sys/resource.h&gt;#include &lt;stdio.h&gt;#define CORE_SIZE 1024 * 1024 * 500int main()&#123; struct rlimit rlmt; if (getrlimit(RLIMIT_CORE, &amp;rlmt) == -1) &#123; return -1; &#125; printf(&quot;Before set rlimit CORE dump current is:%d, max is:%d\\n&quot;, (int)rlmt.rlim_cur, (int)rlmt.rlim_max); rlmt.rlim_cur = (rlim_t)CORE_SIZE; rlmt.rlim_max = (rlim_t)CORE_SIZE; if (setrlimit(RLIMIT_CORE, &amp;rlmt) == -1) &#123; return -1; &#125; if (getrlimit(RLIMIT_CORE, &amp;rlmt) == -1) &#123; return -1; &#125; printf(&quot;After set rlimit CORE dump current is:%d, max is:%d\\n&quot;, (int)rlmt.rlim_cur, (int)rlmt.rlim_max); /*测试非法内存，产生core文件*/ int *ptr = NULL; *ptr = 10; return 0;&#125; 执行./main, 生成的core文件如下所示 GDB调试core文件，查看程序挂在位置。当core dump 之后，使用命令 gdb program core 来查看 core 文件，其中 program 为可执行程序名，core 为生成的 core 文件名。 4、参考资料 http://www.cnblogs.com/hazir/p/linxu_core_dump.html http://www.cnblogs.com/niocai/archive/2012/04/01/2428128.html http://baidutech.blog.51cto.com/4114344/904419/","categories":[{"name":"debug","slug":"debug","permalink":"https://hxlpub.github.io/categories/debug/"}],"tags":[{"name":"coredump","slug":"coredump","permalink":"https://hxlpub.github.io/tags/coredump/"}]},{"title":"【C】标准库和常用函数","slug":"c_stanardlib_func_common","date":"2022-06-12T09:26:07.000Z","updated":"2023-05-28T10:28:40.521Z","comments":true,"path":"2022/06/12/c_stanardlib_func_common/","link":"","permalink":"https://hxlpub.github.io/2022/06/12/c_stanardlib_func_common/","excerpt":"","text":"Target: 1.To describe the c standard libs(section 1) and common functions (section 2)to use Section 1 1.https://www.onitroad.com/jc/linux/man-pages/linux/man3/open_memstream.3.html Section 2 字符串函数 func desc instance strlen(s) 获取字符串s的长度 strcmp(s1,s2) 比较字符串;比较的时候会把字符串转换成ASCII码再进行比较,返回结果为0表示s1和s2的ASCII码值相等,返回结果为1表示s1比s2的ASCII码大,返回结果为-1表示s1比s2的ACSII码小; strcpy(s1,s2) 字符串拷贝;s2会取代s1中的内容 strcat(s1,s2) 将s2拼接到s1后面;注意:s1的length要足够才可以 atoi(s1) 将字符串转为整数","categories":[{"name":"编程语言","slug":"编程语言","permalink":"https://hxlpub.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"C","slug":"C","permalink":"https://hxlpub.github.io/tags/C/"}]},{"title":"【C】UNIX API","slug":"c-unix-apis","date":"2022-06-12T08:10:40.000Z","updated":"2023-05-28T10:26:08.345Z","comments":true,"path":"2022/06/12/c-unix-apis/","link":"","permalink":"https://hxlpub.github.io/2022/06/12/c-unix-apis/","excerpt":"","text":"","categories":[{"name":"编程语言","slug":"编程语言","permalink":"https://hxlpub.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"C","slug":"C","permalink":"https://hxlpub.github.io/tags/C/"}]},{"title":"深度解析Lustre体系结构","slug":"hpc_lustre","date":"2022-06-08T07:57:07.000Z","updated":"2022-06-10T03:10:22.527Z","comments":true,"path":"2022/06/08/hpc_lustre/","link":"","permalink":"https://hxlpub.github.io/2022/06/08/hpc_lustre/","excerpt":"","text":"文章转自“Lustre文件系统与DDN” Lustre架构是一种集群存储体系结构，其核心组件就是Lustre文件系统。该文件系统可在Linux操作系统上运行，并提供了符合POSIX标准的UNIX文件系统接口。 Lustre文件系统是什么 Lustre架构用于许多不同种类的集群。众所周知，它服务于许多全球最大的高性能计算(HPC)集群，提供了数以万计的客户端，PB级存储和每秒数百GB的吞吐量。许多HPC站点使用Lustre文件系统作为全站范围的全局文件系统，为数十个群集提供服务。 Lustre文件系统具有按需扩展容量和性能的能力，降低了部署多个独立文件系统的必要性(如每个计算群集部署一个文件系统)，从而避免了在计算集群之间复制数据，简化了存储管理。Lustre文件系统不仅可将许多服务器的存储容量进行聚合，也可将其I / O吞吐量进行聚合，并通过添置服务器进行扩展。通过动态地添加服务器，轻松实现整个集群的吞吐量和容量的提升。 虽然Lustre文件系统可以在许多工作环境中运行，但也并非就是所有应用程序的最佳选择。当单个服务器无法提供所需容量时，使用Lustre文件系统集群无疑是最适合的。在某些情况下，由于其强大的锁定和数据一致性，即使在单个服务器环境下Lustre文件系统也比其他文件系统表现得更好。 目前，Lustre文件系统并不特别适用于“端对端”的用户模式。在这种模式下，客户端和服务器在同一节点上运行，每个节点共享少量存储。由于Lustre缺少软件级别的数据副本，如果一个客户端或服务器发生故障，存储在该节点上的数据在该节点重新启动前将不可访问。 Lustre文件系统特性 Lustre文件系统可运行在各种厂商的内核上。一个Lustre文件系统在客户端节点数量、磁盘存储量、带宽上进行扩大或缩小。可扩展性和性能取决于可用磁盘、网络带宽以及系统中服务器的处理能力。 Lustre文件系统可以以多种配置进行部署，这些配置的可扩展性远远超出了迄今所观察到生产系统中的规模和性能。下表中列出了一些Lustre文件系统的可扩展性和性能: 性能增强的ext4文件系统：Lustre文件系统使用改进版的ext4日志文件系统来存储数据和元数据。这个版本被命名为ldiskfs，不仅性能有所提升且提供了Lustre文件系统所需的附加功能。 Lustre 2.4或更高版本中，可使用ZFS作为Lustre的MDT，OST和MGS存储的后备文件系统。这使Lustre能够利用ZFS的可扩展性和数据完整性特性来实现单个存储目标。 符合POSIX标准：通过完整的POSIX测试集，像测试本地文件系统Ext4一样，测试Lustre文件系统客户端，只有极少量例外。在集群中，大多数操作都是原子操作，因此客户端永远不会看到损坏的数据或元数据。 Lustre软件支持mmap()文件I / O操作。 高性能异构网络：Lustre软件支持各种高性能低延迟的网络，可使用远程直接内存访问(RDMA)方式，实现在InfiniBand、Intel OmniPath等高级网络上的快速高效网络传输。可使用Lustre路由桥接多个RDMA网络以获得最佳性能。Lustre软件同时也集成了网络诊断。 高可用性：Lustre文件系统通过OSTs(OSS targets)的共享存储分区实现主动/主动故障切换。 Lustre 2.3或更早版本通过使用MDT(MDS target)的共享存储分区实现主动/被动故障切换。 Lustre文件系统可以与各种高可用性(HA)管理器一起工作，以实现自动故障切换并消除了单点故障(NSPF)。这使得应用程序透明恢复成为可能。多重挂载保护(MMP)提供了对高可用性系统中错误的综合保护，避免导致文件系统损坏。 Lustre 2.4或更高版本中，可配置多个MDT的主动/主动故障切换。这允许了通过添加MDT存储设备和MDS节点来扩展Lustre文件系统的元数据性能。 安全性：默认情况下，TCP连接只允许授权端口通过。 UNIX组成员身份在MDS上进行验证。 访问控制列表(ACL)及扩展属性：Lustre安全模型遵循UNIX文件系统原则，并使用POSIX ACL进行增强。此外还有一些额外功能，如root squash。 互操作性：Lustre文件系统可运行在各种CPU架构和大小端混合的群集上，连续发布的Lustre主要软件版本之间保持互操作性性。 基于对象的体系结构：客户端与磁盘文件结构相互隔离，可在不影响客户端的情况下升级存储体系结构。 字节粒度文件锁和细粒度元数据锁：许多客户端可以同时读取和修改相同的文件或目录。 Lustre分布式锁管理器(LDLM)确保了文件系统中所有客户端和服务器之间的文件是一致的。其中，MDT锁管理器负责管理inode权限和路径名。每个OST都有其自己的锁管理器，用于锁定存储在其上的文件条带，其性能可随着文件系统大小增长而扩展。 配额：用户、组和项目配额(User、Group、Project Quota)可用于Lustre文件系统。 容量增长：通过向群集添加新的OST和MDT，可以在不中断服务的情况下增加Lustre文件系统的大小和集群总带宽。 受控文件布局：可以在每个文件，每个目录或每个文件系统基础上配置跨OST的文件布局。这允许了在单个文件系统中调整文件I/O以适应特定的应用程序要求。 Lustre文件系统使用RAID-0进行条带化并可在OST之间调节空间使用大小。 网络数据完整性保护：从客户端发送到OSS的所有数据的校验和可防止数据在传输期间被损坏。 MPI I/O：Lustre架构具有专用的MPI ADIO层，优化了并行I/O以匹配基础文件系统架构。 NFS和CIFS导出：可以使用NFS(通过Linux knfsd)或CIFS(通过Samba)将Lustre文件重新导出，使其可以与非Linux客户端(如Microsoft Windows和Apple Mac OS X)共享。 灾难恢复工具：Lustre文件系统提供在线分布式文件系统检查(LFSCK)，当发生主要文件系统错误的情况下恢复存储组件之间的一致性。 Lustre文件系统在存在文件系统不一致的情况下也可以运行，而LFSCK可以在文件系统正在使用时运行，因此LFSCK不需要在文件系统恢复生产之前完成。 性能监视：Lustre文件系统提供了多种机制来检查性能和进行调整。 开放源代码：为在Linux操作系统上运行，Lustre软件使用GPL 2.0许可证。 Lustre组件介绍 一个Lustre安装实例包括管理服务器(MGS)和一个或多个与Lustre网络(LNet)互连的Lustre文件系统。Lustre文件系统组件的基本配置如下图所示： 管理服务器(MGS) MGS存储集群中所有Lustre文件系统的配置信息，并将此信息提供给其他Lustre组件。每个Lustre目标(target)通过联系MGS提供信息，而Lustre客户通过联系MGS获取信息。MGS最好有自己的存储空间，以便可以独立管理。但同时，MGS可以与MDS放在一起，并共享存储空间，如上图中所示。 Lustre文件系统组件 **元数据服务器(MDS):**MDS使存储在一个或多个MDT中的元数据可供Lustre客户端使用。每个MDS管理Lustre文件系统中的名称和目录，并为一个或多个本地MDT提供网络请求处理。 **元数据目标(MDT):**在Lustre 2.3或更早版本中，每个文件系统只有一个MDT。 MDT在MDS的附加存储上存储元数据（例如文件名，目录，权限和文件布局）。虽然共享存储目标上的MDT可用于多个MDS，但一次只能有一个MDS可以访问。如果当前MDS发生故障，则备用MDS可以为MDT提供服务，并将其提供给客户端。这被称为MDS故障切换。 在Lustre 2.4中，分布式命名空间环境(DNE)中可支持多个MDT。除保存文件系统根目录的主MDT之外，还可以添加其他MDS节点，每个MDS节点都有自己的MDT，以保存文件系统的子目录树。 在Lustre 2.8中，DNE还允许文件系统将单个目录的文件分布到多个MDT节点。分布在多个MDT上的目录称为条带化目录。 对象存储服务器(OSS)：OSS为一个或多个本地OST提供文件I / O服务和网络请求处理。通常，OSS服务于两个到八个OST，每个最多16TB；在专用节点上配置一个MDT；在每个OSS节点上配置两个或更多OST；而在大量计算节点上配置客户端。 对象存储目标(OST)：用户文件数据存储在一个或多个对象中，每个对象位于Lustre文件系统的单独OST中。每个文件的对象数由用户配置，并可根据工作负载情况调试到最优性能。 Lustre客户端：Lustre客户端是运行Lustre客户端软件的计算、可视化或桌面节点，可挂载Lustre文件系统。 Lustre客户端软件为Linux虚拟文件系统和Lustre服务器之间提供了接口。客户端软件包括一个管理客户端(MGC)，一个元数据客户端(MDC)和多个对象存储客户端(OSC)。每个OSC对应于文件系统中的一个OST。 逻辑对象卷(LOV)通过聚合OSC以提供对所有OST的透明访问。因此，挂载了Lustre文件系统的客户端会看到一个连贯的同步名字空间。多个客户端可以同时写入同一文件的不同部分，而其他客户端可以同时读取文件。 与LOV文件访问方式类似，逻辑元数据卷(LMV)通过聚合MDC提供一种对所有MDT透明的访问。这使得了客户端可将多个MDT上的目录树视为一个单一的连贯名字空间，并将条带化目录合并到客户端形成一个单一目录以便用户和应用程序查看。 Lustre网络 (LNet) Lustre Networking(LNet)是一种定制网络API，提供处理Lustre文件系统服务器和客户端的元数据和文件I/O数据的通信基础设施。 Lustr文件系统 集群 在规模上，一个Lustre文件系统集群可以包含数百个OSS和数千个客户端(如下图所示)。 Lustre集群中可以使用多种类型的网络，OSS之间的共享存储启用故障切换功能。 Lustre文件系统存储与I/O 在 Lustre 2.0 中引入了Lustre文件标识符(FID)来替换用于识别文件或对象的UNIX inode编号。 FID是一个128位的标识符，其中，64位用于存储唯一的序列号，32位用于存储对象标识符(OID)，另外32位用于存储版本号。序列号在文件系统(OST和MDT)中的所有Lustre目标中都是唯一的。这一改变使未来支持多种 MDT 和ZFS(均在Lustre 2.4中引入)成为了可能。 同时，在此版本中也引入了一个名为FID-in-dirent(也称为Dirdata)的ldiskfs功能，FID作为文件名称的一部分存储在父目录中。该功能通过减少磁盘I/O显著提高了ls命令执行的性能。 FID-in-dirent是在创建文件时生成的。 在 Lustre 2.4 中，LFSCK文件系统一致性检查工具提供了对现有文件启用FID-in-dirent的功能。具体如下： 为1.8版本文件系统上现有文件生成IGIF模式的FID。 验证每个文件的FID-in-dirent，如其无效或丢失，则重新生成FID-in-dirent。 验证每个linkEA条目，如其无效或丢失，则重新生成。 linkEA由文件名和父类FID组成，它作为扩展属性存储在文件本身中。因此，linkEA可以用来重建文件的完整路径名。 有关文件数据在OST上的位置信息将作为扩展属性布局EA，存储在由FID标识的MDT对象中(具体如下图所示)。若该文件是普通文件(即不是目录或符号链接)，则MDT对象1对N地指向包含文件数据的OST对象。若该MDT文件指向一个对象，则所有文件数据都存储在该对象中。若该MDT文件指向多个对象，则使用RAID 0将文件数据划分为多个对象，将每个对象存储在不同的OST上。 当客户端读写文件时，首先从文件的MDT对象中获取布局EA，然后使用这个信息在文件上执行I / O，直接与存储对象的OSS节点进行交互。具体过程如下图所示。 Lustre文件系统的可用带宽如下： 网络带宽等于OSS到目标的总带宽。 磁盘带宽等于存储目标(OST)的磁盘带宽总和，受网络带宽限制。 总带宽等于磁盘带宽和网络带宽的最小值。 可用的文件系统空间等于所有OST的可用空间总和。 Lustre文件系统条带化 Lustre文件系统高性能的主要原因之一是能够以轮询方式跨多个OST将数据条带化。用户可根据需要为每个文件配置条带数量，条带大小和OST。当单个文件的总带宽超过单个OST的带宽时，可以使用条带化来提高性能。同时，当单个OST没有足够的可用空间来容纳整个文件时，条带化也能发挥它的作用。 如图下图所示，条带化允许将文件中的数据段或“块”存储在不同的OST中。在Lustre文件系统中，通过RAID 0模式将数据在一定数量的对象上进行条带化。一个文件中处理的对象数称为stripe_count。每个对象包含文件中的一个数据块，当写入特定对象的数据块超过stripe_size时，文件中的下一个数据块将存储在下一个对象上。stripe_count和stripe_size的默认值由为文件系统设置的，其中，stripe_count为1，stripe_size为1MB。用户可以在每个目录或每个文件上更改这些值。 下图中，文件C的stripe_size大于文件A的stripe_size，表明更多的数据被允许存储在文件C的单个条带中。文件A的stripe_count为3，则数据在三个对象上条带化。文件B和文件C的stripe_count是1。OST上没有为未写入的数据预留空间。 最大文件大小不受单个目标大小的限制。在Lustre文件系统中，文件可以跨越多个对象(最多2000个)进行分割，每个对象可使用多达16 TB的ldiskfs，多达256PB的ZFS。也就是说，ldiskfs的最大文件大小为31.25 PB，ZFS的最大文件大小为8EB。Lustre文件系统上的文件大小受且仅受OST上可用空间的限制，Lustre最大可支持2 ^ 63字节(8EB)的文件。 **注意:**Lustre 2.2之前，单个文件的最大条带数为160个OST。尽管一个文件只能被分割成2000个以上的对象，但是Lustre文件系统可以有数千个。 发表于: 2018-06-01 原文链接：https://kuaibao.qq.com/s/20180601A0AHSR00?refer=cp_1026 腾讯「云+社区」是腾讯内容开放平台帐号（企鹅号）传播渠道之一，根据《腾讯内容开放平台服务协议》转载发布内容。 如有侵权，请联系 &#x79;&#117;&#x6e;&#106;&#105;&#x61;&#x5f;&#x63;&#x6f;&#109;&#x6d;&#117;&#x6e;&#105;&#116;&#121;&#x40;&#x74;&#x65;&#x6e;&#99;&#x65;&#x6e;&#116;&#x2e;&#99;&#111;&#x6d; 删除。","categories":[{"name":"HPC","slug":"HPC","permalink":"https://hxlpub.github.io/categories/HPC/"}],"tags":[{"name":"HPC","slug":"HPC","permalink":"https://hxlpub.github.io/tags/HPC/"}]},{"title":"浅谈EC和多副本","slug":"storage_basics","date":"2022-06-08T07:57:07.000Z","updated":"2022-06-08T07:34:39.212Z","comments":true,"path":"2022/06/08/storage_basics/","link":"","permalink":"https://hxlpub.github.io/2022/06/08/storage_basics/","excerpt":"","text":"【摘要】 对于存储用户而言，存储系统的可靠性、性能、成本，是用户非常关注的几个方面。在传统的存储中，大多是采用RAID的方式，来保证数据的高可靠性；而在分布式存储系统中，多副本和EC(Erasure Code)是比较常见的数据保护方法。本文简单介绍多副本和EC概念、原理和优势对比等 前言对于存储用户而言，存储系统的可靠性、性能、成本，是用户非常关注的几个方面。在传统的存储中，大多是采用RAID的方式，来保证数据的高可靠性；而在分布式存储系统中，多副本和EC(Erasure Code)是比较常见的数据保护方法。 那么什么是多副本？又如何理解EC？他们之间的区别和优势又是什么呢？ 多副本简单说，多副本就是一份数据以副本的方式写到多个分布式系统中的存储节点中。这种多副本的数据保护方式，一来实现简单，而来可靠性高。除非所有副本所在的存储节点都故障，才会影响业务；除此之外，可以从未故障的其他副本读取数据以保证业务。但是多副本的空间利用率偏低，以三副本为例，存储空间利用率未33%，这也增加了企业级用户的存储成本。 ECEC是一种技术。是指将n份原始数据，增加m份数据，并能通过n+m份中的任意n份数据，还原为原始数据。如果把n+m份数据分布在存储系统的不同节点上，那么任意小于等于m个节点故障（m份数据失效），都可以通过其他剩余的数据还原出原始数据，从而达到不影响业务的目的。EC算法可以灵活配置，比如系统要满足支持2个节点同时故障，则m=2即可。从空间利用率上，EC是优于多副本的，以4+2为例，空间利用率为4/（4+2）=67%。这个利用率相当于三副本的2倍。而可靠性上，与三副本一样可以满足支持2个节点同时故障。 疑问：n份数据是数据分摊吗？m份数据是校验的？怎么生成的m份数据？ 对比分析在满足同等可靠性要求的前提下，从以下方面对EC和多副本进行对比分析，如下： 空间利用率 硬件成本 多副本 低 高 EC 高 低 本文转载自华为云社区https://bbs.huaweicloud.com/blogs/115216，作者：[风中有朵犇犇云](https://bbs.huaweicloud.com/community/usersnew/id_1513588727908205) 发表于 2019/04/25 14:32:21","categories":[{"name":"存储-basics","slug":"存储-basics","permalink":"https://hxlpub.github.io/categories/%E5%AD%98%E5%82%A8-basics/"}],"tags":[{"name":"存储","slug":"存储","permalink":"https://hxlpub.github.io/tags/%E5%AD%98%E5%82%A8/"}]},{"title":"【C】内存管理：malloc、free","slug":"c-funcs-malloc-free","date":"2022-06-07T00:38:07.000Z","updated":"2023-05-28T10:25:16.639Z","comments":true,"path":"2022/06/07/c-funcs-malloc-free/","link":"","permalink":"https://hxlpub.github.io/2022/06/07/c-funcs-malloc-free/","excerpt":"","text":"http://bbs.byr.cn/pc/pccon.php?id=315&amp;nid=68136 版权说明：转自bc-cn C语言论坛 写程序时用malloc竟然出现段错误，而且明显那块没有用错，肯定是别的地方有内存泄漏的问题，导致最后内存泄漏了。需要好好查一查原因了。但程序中很多地方都用来malloc，内存全是随便用的，要改起来估计十分麻烦。。。。 下面找了点malloc与free的介绍，先看下，然后赶紧改代码。 在C语言的学习中，对内存管理这部分的知识掌握尤其重要！之前对C中的malloc()和free()两个函数的了解甚少，只知道大概该怎么用——就是malloc然后free就一切OK了。当然现在对这两个函数的体会也不见得多，不过对于本文章第三部分的内容倒是有了转折性的认识，所以 写下这篇文章作为一个对知识的总结。这篇文章之所以命名中有个“浅谈”的字眼，也就是这个意思了！希望对大家有一点帮助！ 如果不扯得太远的话（比如说操作系统中虚拟内存和物理内存如何运做如何管理之类的知识等），我感觉这篇文章应该是比较全面地谈了一下malloc()和free().这篇文章由浅入深（不见得有多深）分三个部分介绍主要内容。 废话了那么多，下面立刻进入主题================》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》 一、malloc()和free()的基本概念以及基本用法： 1、函数原型及说明： void *malloc(long NumBytes)：该函数分配了NumBytes个字节，并返回了指向这块内存的指针。如果分配失败，则返回一个空指针（NULL）。 关于分配失败的原因，应该有多种，比如说空间不足就是一种。 void free(void *FirstByte)： 该函数是将之前用malloc分配的空间还给程序或者是操作系统，也就是释放了这块内存，让它重新得到自由。 2、函数的用法： 其实这两个函数用起来倒不是很难，也就是malloc()之后觉得用够了就甩了它把它给free()了，举个简单例子： 程序代码： // Code… char *Ptr = NULL; Ptr = (char *)malloc(100 * sizeof(char)); if (NULL == Ptr) { exit (1); } gets(Ptr); ​ // code…​ free(Ptr);​ Ptr = NULL;​ // code… 就是这样！当然，具体情况要具体分析以及具体解决。比如说，你定义了一个指针，在一个函数里申请了一块内存然后通过函数返回传递给这个指针，那么也许释放这块内存这项工作就应该留给其他函数了。 3、关于函数使用需要注意的一些地方： A、申请了内存空间后，必须检查是否分配成功。 B、当不需要再使用申请的内存时，记得释放；释放后应该把指向这块内存的指针指向NULL，防止程序后面不小心使用了它。 C、这两个函数应该是配对。如果申请后不释放就是内存泄露；如果无故释放那就是什么也没有做。释放只能一次，如果释放两次及两次以上会 出现错误（释放空指针例外，释放空指针其实也等于啥也没做，所以释放空指针释放多少次都没有问题）。 D、虽然malloc()函数的类型是(void *),任何类型的指针都可以转换成(void *),但是最好还是在前面进行强制类型转换，因为这样可以躲过一 些编译器的检查。 好了！最基础的东西大概这么说！现在进入第二部分： 二、malloc()到底从哪里得来了内存空间： 1、malloc()到底从哪里得到了内存空间？答案是从堆里面获得空间。也就是说函数返回的指针是指向堆里面的一块内存。操作系统中有一个记录空闲内存地址的链表。当操作系统收到程序的申请时，就会遍历该链表，然后就寻找第一个空间大于所申请空间的堆结点，然后就将该结点从空闲结点链表中删除，并将该结点的空间分配给程序。就是这样！ 说到这里，不得不另外插入一个小话题，相信大家也知道是什么话题了。什么是堆？说到堆，又忍不住说到了栈！什么是栈？下面就另外开个小部分专门而又简单地说一下这个题外话： 2、什么是堆：堆是大家共有的空间，分全局堆和局部堆。全局堆就是所有没有分配的空间，局部堆就是用户分配的空间。堆在操作系统对进程 初始化的时候分配，运行过程中也可以向系统要额外的堆，但是记得用完了要还给操作系统，要不然就是内存泄漏。 什么是栈：栈是线程独有的，保存其运行状态和局部自动变量的。栈在线程开始的时候初始化，每个线程的栈互相独立。每个函数都有自己的栈，栈被用来在函数之间传递参数。操作系统在切换线程的时候会自动的切换栈，就是切换SS/ESP寄存器。栈空间不需要在高级语言里面显式的分配和释放。 以上的概念描述是标准的描述，不过有个别语句被我删除，不知道因为这样而变得不标准了^_^. 通过上面对概念的描述，可以知道： 栈是由编译器自动分配释放，存放函数的参数值、局部变量的值等。操作方式类似于数据结构中的栈。 堆一般由程序员分配释放，若不释放，程序结束时可能由OS回收。注意这里说是可能，并非一定。所以我想再强调一次，记得要释放！ 注意它与数据结构中的堆是两回事，分配方式倒是类似于链表。（这点我上面稍微提过） 所以，举个例子，如果你在函数上面定义了一个指针变量，然后在这个函数里申请了一块内存让指针指向它。实际上，这个指针的地址是在栈上，但是它所指向的内容却是在堆上面的！这一点要注意！所以，再想想，在一个函数里申请了空间后，比如说下面这个函数： 程序代码： // code… void Function(void) { char *p = (char *)malloc(100 * sizeof(char)); } 就这个例子，千万不要认为函数返回，函数所在的栈被销毁指针也跟着销毁，申请的内存也就一样跟着销毁了！这绝对是错误的！因为申请的内存在堆上，而函数所在的栈被销毁跟堆完全没有啥关系。所以，还是那句话：记得释放！ 3、free()到底释放了什么 这个问题比较简单，其实我是想和第二大部分的题目相呼应而已！哈哈！free()释放的是指针指向的内存！注意！释放的是内存，不是指针！这点非常非常重要！指针是一个变量，只有程序结束时才被销毁。释放了内存空间后，原来指向这块空间的指针还是存在！只不过现在指针指向的内容的垃圾，是未定义的，所以说是垃圾。因此，前面我已经说过了，释放内存后把指针指向NULL，防止指针在后面不小心又被解引用了。非常重要啊这一点！ 好了！这个“题外话”终于说完了。就这么简单说一次，知道个大概就可以了！下面就进入第三个部分： 三、malloc()以及free()的机制： 这个部分我今天才有了新的认识！而且是转折性的认识！所以，这部分可能会有更多一些认识上的错误！不对的地方请大家帮忙指出！ 事实上，仔细看一下free()的函数原型，也许也会发现似乎很神奇，free()函数非常简单，只有一个参数，只要把指向申请空间的指针传递 给free()中的参数就可以完成释放工作！这里要追踪到malloc()的申请问题了。申请的时候实际上占用的内存要比申请的大。因为超出的空间是用来记录对这块内存的管理信息。先看一下在《UNIX环境高级编程》中第七章的一段话： 大多数实现所分配的存储空间比所要求的要稍大一些，额外的空间用来记录管理信息——分配块的长度，指向下一个分配块的指针等等。这就意味着如果写过一个已分配区的尾端，则会改写后一块的管理信息。这种类型的错误是灾难性的，但是因为这种错误不会很快就暴露出来，所以也就很难发现。将指向分配块的指针向后移动也可能会改写本块的管理信息。 以上这段话已经给了我们一些信息了。malloc()申请的空间实际我觉得就是分了两个不同性质的空间。一个就是用来记录管理信息的空间，另外一个就是可用空间了。而用来记录管理信息的实际上是一个结构体。在C语言中，用结构体来记录同一个对象的不同信息是 天经地义的事！下面看看这个结构体的原型： 程序代码： struct mem_control_block { int is_available; //这是一个标记？ int size; //这是实际空间的大小 }; 对于size,这个是实际空间大小。这里其实我有个疑问，is_available是否是一个标记？因为我看了free()的源代码之后对这个变量感觉有点纳闷（源代码在下面分析）。这里还请大家指出！ 所以，free()就是根据这个结构体的信息来释放malloc()申请的空间！而结构体的两个成员的大小我想应该是操作系统的事了。但是这里有一个问题，malloc()申请空间后返回一个指针应该是指向第二种空间，也就是可用空间！不然，如果指向管理信息空间的话，写入的内容和结构体的类型有可能不一致，或者会把管理信息屏蔽掉，那就没法释放内存空间了，所以会发生错误！（感觉自己这里说的是废话） 好了！下面看看free()的源代码，我自己分析了一下，觉得比起malloc()的源代码倒是容易简单很多。只是有个疑问，下面指出！ 程序代码： // code… void free(void *ptr) { struct mem_control_block *free; free = ptr - sizeof(struct mem_control_block); free-&gt;is_available = 1; return; } 看一下函数第二句，这句非常重要和关键。其实这句就是把指向可用空间的指针倒回去，让它指向管理信息的那块空间，因为这里是在值上减去了一个结构体的大小！后面那一句free-&gt;is_available = 1;我有点纳闷！我的想法是：这里is_available应该只是一个标记而已！因为从这个变量的名称上来看，is_available 翻译过来就是“是可以用”。不要说我土！我觉得变量名字可以反映一个变量的作用，特别是严谨的代码。这是源代码，所以我觉得绝对是严谨的！！这个变量的值是1，表明是可以用的空间！只是这里我想了想，如果把它改为0或者是其他值不知道会发生什么事？！但是有一点我可以肯定，就是释放绝对不会那么顺利进行！因为这是一个标记！ 当然，这里可能还是有人会有疑问，为什么这样就可以释放呢？？我刚才也有这个疑问。后来我想到，释放是操作系统的事，那么就free()这个源代码来看，什么也没有释放，对吧？但是它确实是确定了管理信息的那块内存的内容。所以，free()只是记录了一些信息，然后告诉操作系统那块内存可以去释放，具体怎么告诉操作系统的我不清楚，但我觉得这个已经超出了我这篇文章的讨论范围了。 那么，我之前有个错误的认识，就是认为指向那块内存的指针不管移到那块内存中的哪个位置都可以释放那块内存！但是，这是大错特错！释放是不可以释放一部分的！首先这点应该要明白。而且，从free()的源代码看，ptr只能指向可用空间的首地址，不然，减去结构体大小之后一定不是指向管理信息空间的首地址。所以，要确保指针指向可用空间的首地址！不信吗？自己可以写一个程序然后移动指向可用空间的指针，看程序会有会崩！ 最后可能想到malloc()的源代码看看malloc()到底是怎么分配空间的，这里面涉及到很多其他方面的知识！有兴趣的朋友可以自己去下载源代码去看看。 四、关于其他： 关于C中的malloc()和free()的讨论就写到这里吧！写了三个钟头，感觉有点累！希望对大家有所帮助！有不对的地方欢迎大家指出！最后，谢谢参与这个帖子讨论的所有朋友，帖子：http://www.bc-cn.net/bbs/dispbbs.asp?boardID=5&amp;ID=81781&amp;page=1。也谈到版权问题，如果哪位想转载这篇文章（如果我有这个荣幸的话），最起码请标明“来自bc-cn C语言论坛”这几个字眼，我的ID可以不用写上！谢谢合作！ 五、参考文献：（只写书名） ——《UNIX环境高级编程》 ——《计算机组成原理》 ——《高质量C/C++编程指南》","categories":[{"name":"编程语言","slug":"编程语言","permalink":"https://hxlpub.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"C","slug":"C","permalink":"https://hxlpub.github.io/tags/C/"}]},{"title":"dfs","slug":"daos","date":"2022-05-14T04:10:07.000Z","updated":"2022-08-26T08:53:03.496Z","comments":true,"path":"2022/05/14/daos/","link":"","permalink":"https://hxlpub.github.io/2022/05/14/daos/","excerpt":"","text":"https://www.intel.com/content/www/us/en/developer/articles/training/introduction-to-dfs.html","categories":[{"name":"daos","slug":"daos","permalink":"https://hxlpub.github.io/categories/daos/"}],"tags":[{"name":"分布式对象存储daos","slug":"分布式对象存储daos","permalink":"https://hxlpub.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AF%B9%E8%B1%A1%E5%AD%98%E5%82%A8daos/"}]},{"title":"git_problemsshooting","slug":"git-problemsshooting","date":"2022-05-10T14:19:51.000Z","updated":"2022-05-11T07:51:31.455Z","comments":true,"path":"2022/05/10/git-problemsshooting/","link":"","permalink":"https://hxlpub.github.io/2022/05/10/git-problemsshooting/","excerpt":"","text":"Failed to connect to github.com port 443:connection timed out解决方法： 1git config --global --unset http.proxy &amp;&amp; git config --global --unset https.proxy curl: (56) OpenSSL SSL_read: Connection reset by peer, errno 104解决方法： Running commands in /opt/daos/build/external/release/spdkRUN: git submodule initSubmodule ‘dpdk’ (https://github.com/spdk/dpdk.git) registered for path ‘dpdk’Submodule ‘intel-ipsec-mb’ (https://github.com/spdk/intel-ipsec-mb.git) registered for path ‘intel-ipsec-mb’Submodule ‘isa-l’ (https://github.com/spdk/isa-l.git) registered for path ‘isa-l’Submodule ‘libvfio-user’ (https://github.com/nutanix/libvfio-user.git) registered for path ‘libvfio-user’Submodule ‘ocf’ (https://github.com/Open-CAS/ocf.git) registered for path ‘ocf’RUN: git submodule updateCloning into ‘/opt/daos/build/external/release/spdk/dpdk’…fatal: unable to access ‘https://github.com/spdk/dpdk.git/&#39;: OpenSSL SSL_read: Connection reset by peer, errno 104fatal: clone of ‘https://github.com/spdk/dpdk.git&#39; into submodule path ‘/opt/daos/build/external/release/spdk/dpdk’ failedFailed to clone ‘dpdk’. Retry scheduledCloning into ‘/opt/daos/build/external/release/spdk/intel-ipsec-mb’…Cloning into ‘/opt/daos/build/external/release/spdk/isa-l’…Cloning into ‘/opt/daos/build/external/release/spdk/libvfio-user’…fatal: unable to access ‘https://github.com/nutanix/libvfio-user.git/&#39;: OpenSSL SSL_read: Connection reset by peer, errno 104fatal: clone of ‘https://github.com/nutanix/libvfio-user.git&#39; into submodule path ‘/opt/daos/build/external/release/spdk/libvfio-user’ failedFailed to clone ‘libvfio-user’. Retry scheduledCloning into ‘/opt/daos/build/external/release/spdk/ocf’…fatal: unable to access ‘https://github.com/Open-CAS/ocf.git/&#39;: Failed to connect to github.com port 443: Connection refusedfatal: clone of ‘https://github.com/Open-CAS/ocf.git&#39; into submodule path ‘/opt/daos/build/external/release/spdk/ocf’ failedFailed to clone ‘ocf’. Retry scheduledCloning into ‘/opt/daos/build/external/release/spdk/dpdk’…fatal: unable to access ‘https://github.com/spdk/dpdk.git/&#39;: Failed to connect to github.com port 443: Connection refusedfatal: clone of ‘https://github.com/spdk/dpdk.git&#39; into submodule path ‘/opt/daos/build/external/release/spdk/dpdk’ failedFailed to clone ‘dpdk’ a second time, abortingDownloadFailure: Failed to get /opt/daos/build/external/release/spdk from https://github.com/spdk/spdk.git:","categories":[{"name":"git","slug":"git","permalink":"https://hxlpub.github.io/categories/git/"}],"tags":[{"name":"版本管理","slug":"版本管理","permalink":"https://hxlpub.github.io/tags/%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86/"}]},{"title":"typora激活","slug":"typora-activate","date":"2022-04-30T11:15:26.000Z","updated":"2022-05-14T02:36:34.233Z","comments":true,"path":"2022/04/30/typora-activate/","link":"","permalink":"https://hxlpub.github.io/2022/04/30/typora-activate/","excerpt":"","text":"链接：https://pan.baidu.com/s/19QqJXAf9dTIYDe_kJ4P0fA提取码：nfl7","categories":[{"name":"开发工具","slug":"开发工具","permalink":"https://hxlpub.github.io/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"Typora","slug":"Typora","permalink":"https://hxlpub.github.io/tags/Typora/"}]},{"title":"表、栈、队列","slug":"datastructures_tutorial","date":"2022-04-28T12:11:08.000Z","updated":"2022-05-14T02:29:23.816Z","comments":true,"path":"2022/04/28/datastructures_tutorial/","link":"","permalink":"https://hxlpub.github.io/2022/04/28/datastructures_tutorial/","excerpt":"","text":"参考 本文参考自《数据结构与算法分析C++描述》第三版，作者Mark Allen Weiss 1.表1)链表可以解决什么问题？其一般思想是？ 表的数组实现带来的问题 数组实现printList线性时间，findKth 常数时间，但插入和删除操作在整个表中发生时，时间开销最坏的情况是线性的O(N)，数组就不合适。 链表一般思想 为避免插入和删除带来的线性开销，允许表可以不连续存储，否则表的部分或全部都要整体移动。 下图表示了链表的一般性思想： 以及插入和删除方法的一般性思想： 当删除最后一项时，需要找到最后一项前面的项，才能去更新其next 链接到NULL，需要O(N),如果双向链表则只需要O(1) ​ 2.栈3.队列","categories":[{"name":"数据结构&算法分析","slug":"数据结构-算法分析","permalink":"https://hxlpub.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/"}],"tags":[{"name":"Structures&Algorithm","slug":"Structures-Algorithm","permalink":"https://hxlpub.github.io/tags/Structures-Algorithm/"}]},{"title":"【C】搭建c知识体系：Basics","slug":"c_new","date":"2022-04-23T10:12:50.000Z","updated":"2023-05-28T10:26:44.880Z","comments":true,"path":"2022/04/23/c_new/","link":"","permalink":"https://hxlpub.github.io/2022/04/23/c_new/","excerpt":"","text":"1.本篇目的：搭建并完善C知识体系 2.本篇的结构 第一部分：基础点 第二部分：调试技巧 第一部分：基础点 预处理器 #include指令：文件包含，该指令所在的行都将被替换为由文件名指定的文件的内容，一种将所有声明捆绑在一起的较好的办法，保证所有的源文件有相同的定义与变量声明 #include “文件” ：先在源文件所在位置查找该文件，如果在该位置未找到，再根据相应规则查找 #include &lt;文件&gt; ：根据相应规则查找 #define指令：宏替换，#define 名字 替换文本 宏：将函数定义为宏可避免调用函数时所需的运行时开销 变量存储类别 静态存储方式 程序运行期间分配固定的存储空间的方式。静态存储区中存放了在整个程序执行过程中都存在的变量，如全局变量。 动态存储方式 指在程序运行期间根据需要进行动态的分配存储空间的方式。动态存储区中存放的变量是根据程序运行的需要而建立和释放的，通常包括：函数形式参数；自动变量；函数调用时的现场保护和返回地址等。 类型 作用域 存储位置 生命周期 特点 实例 static静态变量 所在文件（static 外部变量）、 所在函数（static 局部变量） 定义后一直占据存储空间 程序运行期间 只被初始化一次（程序执行前，编译时），初始化表达式是常量表达式，没有初始化表达式的元素被初始化为0或空字符 register 局部变量 、函数形参（局部静态变量不能定义为寄存器变量） 寄存器 程序更小，执行速度更快 外部变量external 外部变量的意义是某函数可以调用在该函数之后定义的变量。 只被初始化一次（程序执行前），初始化表达式必须是常量表达式，没有初始化表达式的元素被初始化为0; #includ &lt;stdio.h&gt; int main() { //定义外部局部变量 extern int x; return 0; } int x=100; 自动变量auto 函数内部 函数被调用期间 每次进入函数或程序块都初始化，没有初始化表达式的元素被初始化为0 函数 函数 形式 说明 内部函数（静态函数） static [数据类型] 函数名（[参数]） 不能被其他源文件调用的函数称为内部函数 ，static是对函数的作用范围的一个限定，限定该函数只能在其所处的源文件中使用，因此在不同文件中出现相同的函数名称的内部函数是没有问题的。 外部函数 extern [数据类型] 函数名([参数]) 能被其他源文件调用的函数称为外部函数，C语言规定，在没有指定函数的作用范围时，系统会默认认为是外部函数，因此当需要定义外部函数时extern也可以省略。 extern可以省略; 指针 运算符&amp;：取地址，只能应用于内存中对象，即变量与数组元素，不能作用与表达式、常量、或register变量 ​ 运算符：间接寻址或间接引用运算符，作用于指针时，将访问指针所指向的对象。 ​ &amp;、优先级高于算术运算符 ​ 指针变量可以相互赋值，指向相同的对象 1）指针与数组 ： 一般，指针编写的程序比用数组下标编写的程序执行速度快 ​ 一个通过数组和下标实现的表达式可等价地通过指针和偏移量实现 char s[] == char *s 、&amp;a[2] == a+2 （a数组） 2）特性 某些情况下对指针进行比较运算（如指针p、q指向同一个数组的成员） 指针可以和整数相加或相减 指针的算术运算具有一致性：所有的指针运算都会自动考虑它所指向的对象的长度 有效的指针运算： 相同类型指针之间赋值运算 指针同整数之间的加法减法 指向相同数组中元素的两个指针间的减法和比较运算 指针赋值为0或指针与0之间的比较运算 3）指针数组、指针的指针 如char *lineptr[10] 初始化：如，static char *name[] = {“xiaoming”,”xiaoqiang”} 指针数组优点：数组的每一个元素的长度可以不同 4)函数指针 K&amp;R P99 运算符优先级 1）优先级1：数组下标[]，圆括号( )，成员选择（对象）.，成员选择（指针）-&gt; 结合方向为左到右 2）优先级2：负号运算符-，强制类型转换，自增运算符++，自减运算符–，取值运算符，取地址运算符&amp;，逻辑非运算符！，按位取反运算符~，长度运算sizeof符，结合方向为右到左 3）优先级3：除/，乘*，余数%，结合方向为左到右 4）优先级4：加+，减-，结合方向为左到右 5）优先级5：左移&lt;&lt;，右移&gt;&gt;，结合方向为左到右 6）优先级6：大于&gt;，大于等于&gt;=，小于&lt;，小于等于&lt;=，结合方向为左到右 7）优先级7：等于==，不等于!=，结合方向为左到右 8）优先级8：级别先后为，按位与&amp;，按位异或^，按位或| ，逻辑与&amp;&amp;，逻辑或|| 条件运算符?:，注意得是条件运算结合方向为右到左 9）优先级9：赋值运算符=，除后赋值/=，乘后赋值*=，取模后赋值%=，加后赋值+=，减后赋值-=，左移后赋值&lt;&lt;=，右移后赋值&gt;&gt;=，按位与后赋值&amp;=，按位异或后赋值^=，按位或后赋值|=，结合方向为右到左 结构 struct point { int x; int y; }; 声明：struct {int x,int y} x,y,z; #分配存储空间 struct point pt; 初始化： struct point maxpt = {320, 200}; 成员：maxpt.x maxpt.y 嵌套： struct rect { struct point pt1; struct point pt2; }; struct rect screen; 成员： screen.pt1.x 合法操作： 1.作为一个整体赋值和赋值 2.通过&amp;取地址 3.访问其成员 结构指针： struct point *ptrstr; ptrstr -&gt; x 结构数组 12345678struct key &#123;char *word;int count;&#125; keytab[] = &#123; &#123; &quot;auto&quot;, 0 &#125;, &#123; &quot;break&quot;, 0 &#125;, &#123; &quot;case&quot;, 0 &#125; &#125; &#125;； 结构指针 关键字统计 自引用结构 K$R P116 ex:统计输入所有单词出现频次（二叉树） 表查找 类型定义（typedef） 联合 位字段 命令行参数 12345678910#include &lt;stdio.h&gt;#include &lt;string.h&gt;int main(int argc, char *argv[] )&#123; #./test -x 注意优先级顺序 printf(&quot;%s\\n&quot;,argv[0]);#./test printf(&quot;%c\\n&quot;,(*++argv)[0]);#- argv指向argv[1] printf(&quot;%c\\n&quot;,*++argv[0]);#x,先与[]结合,所以依然指向argv[1] printf(&quot;%d\\n&quot;,argc);#2&#125; 运算符集合 控制流语句 标准库 输入输出：printf (“%d”,i)、scanf(“%d”,&amp;i) 文件访问： 1.打开文件，返回文件指针 123FILE *fp;FILE *fopen(char *name,char *mode) fp = fopen(name,mode) 123456782.文件读写int getc(FILE *fp)int putc(FILE *fp)#define getchar() getc(stdin)#define putchar(c) putc((c), stdout) 12int fscanf(FILE *fp, char *format, ...)int fprintf(FILE *fp, char *format, ...) 12345678910111213141516171819202122233.关闭文件int fclose (FILE *fp)错误处理stderr 和exitfprintf(stderr, &quot;%s: can&#x27;t open %s\\n&quot;,prog, *argv);int ferror（FILE *fp）#若流fp中出错，则函数返回一个非0值int feof(FILE *fp) #如果指定的文件到达文件结尾，返回一个非0值行输入行输出char *fgets(char *line, int maxline, FILE *fp) #读文件一行到lineint fputs(char *line, FILE *fp)#写line到文件其他函数![字符和字符串操作函数](https://github.com/hxlpub/imgs/blob/master/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AD%97%E7%AC%A6%E7%B1%BB%E5%87%BD%E6%95%B0.png?raw=true&amp;ynotemdtimestamp=1650186921046) 第二部分：调试技巧 12345#gdb 段错误gcc -o a -g a.c a.hgcc ./ar#运行bt#查看seg fault","categories":[{"name":"编程语言","slug":"编程语言","permalink":"https://hxlpub.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"C","slug":"C","permalink":"https://hxlpub.github.io/tags/C/"}]},{"title":"c语言类","slug":"1000codes","date":"2022-04-16T12:42:24.000Z","updated":"2022-06-12T03:11:28.742Z","comments":true,"path":"2022/04/16/1000codes/","link":"","permalink":"https://hxlpub.github.io/2022/04/16/1000codes/","excerpt":"","text":"","categories":[{"name":"codes","slug":"codes","permalink":"https://hxlpub.github.io/categories/codes/"}],"tags":[{"name":"codes","slug":"codes","permalink":"https://hxlpub.github.io/tags/codes/"}]},{"title":"python常见问题","slug":"python-common-problems","date":"2022-04-06T07:44:09.000Z","updated":"2022-04-09T12:36:33.876Z","comments":true,"path":"2022/04/06/python-common-problems/","link":"","permalink":"https://hxlpub.github.io/2022/04/06/python-common-problems/","excerpt":"","text":"“ModuleNotFoundError: No module named ‘xxx’","categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"https://hxlpub.github.io/tags/Python/"}]},{"title":"理解python的if__name","slug":"ifname","date":"2022-04-03T10:16:20.000Z","updated":"2022-05-14T02:33:28.646Z","comments":true,"path":"2022/04/03/ifname/","link":"","permalink":"https://hxlpub.github.io/2022/04/03/ifname/","excerpt":"","text":"1.参考","categories":[{"name":"Python","slug":"Python","permalink":"https://hxlpub.github.io/categories/Python/"}],"tags":[{"name":"python","slug":"python","permalink":"https://hxlpub.github.io/tags/python/"}]},{"title":"linux shortcut","slug":"linux-shortcut","date":"2022-04-03T06:46:36.000Z","updated":"2022-06-30T06:15:23.107Z","comments":true,"path":"2022/04/03/linux-shortcut/","link":"","permalink":"https://hxlpub.github.io/2022/04/03/linux-shortcut/","excerpt":"","text":"跳转到指定行 123:n ---跳到第n行，需要回车ngg或nG ---跳到第n行,无需回车vim +n filename --- 打开文件后跳到文件第n行 多行注释和多行删除 123456789101112131415161718192021222324252627281.多行注释依次进行按下esc -&gt; Ctrl+v -&gt; 上下键选择多行 -&gt; shift+i -&gt; 输入注释//或# -&gt; 按下esc2.删除多行注释Ctrl+v -&gt; 上下键选择多行 -&gt; x 或 d (若// 执行两次，若# 一次即可 )3.多行删除:set nu -&gt; :起始行:终止行 -&gt; 回车若误删，使用 u 恢复4.其他单行删除，：1（待删除行）d多行删除 ，：1,10d光标所在行，dd光标所在行以下的N行，Ndd复制少量行文本的情况，复制第6行（包括）下面的2行数据，放到第9行下面 方法1： 光标放到第6行， 输入：2yy 光标放到第9行， 输入：p 此方法适合复制少量行文本的情况，复制第6行（包括）下面的2行数据，放到第9行下面。 方法2： 命令行模式下输入 6,9 co 12 复制第6行到第9行之间的内容到第12行后面。 shell Shift +Tab #多个shell窗口切换","categories":[{"name":"Linux","slug":"Linux","permalink":"https://hxlpub.github.io/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://hxlpub.github.io/tags/Linux/"}]},{"title":"定义一个systemd service","slug":"define-a-systemd-service","date":"2022-04-01T11:05:53.000Z","updated":"2022-05-14T02:30:32.936Z","comments":true,"path":"2022/04/01/define-a-systemd-service/","link":"","permalink":"https://hxlpub.github.io/2022/04/01/define-a-systemd-service/","excerpt":"","text":"将编译生成的二进制文件 修改/usr/lib/systemd/system/daos_agent.service ExecStart=/usr/local/daos/bin/daos_agent -i -o &lt;’path to agent configuration file/daos_agent.yml’&gt; systemctl daemon-reload systemctl enable daos_agent.service systemctl start daos_agent.service","categories":[{"name":"Linux","slug":"Linux","permalink":"https://hxlpub.github.io/categories/Linux/"}],"tags":[{"name":"systemd","slug":"systemd","permalink":"https://hxlpub.github.io/tags/systemd/"}]},{"title":"python_newer","slug":"python-newer","date":"2022-03-29T10:09:39.000Z","updated":"2022-04-03T10:15:18.190Z","comments":true,"path":"2022/03/29/python-newer/","link":"","permalink":"https://hxlpub.github.io/2022/03/29/python-newer/","excerpt":"","text":"python的特点 相比之下，Python 更易于使用，无论在 Windows、Mac OS X 或 Unix 操作系统上它都会帮助你更快地完成任务 与 Shell 脚本或批处理文件相比，它为编写大型程序提供了更多的结构和支持。 Python 提供了比 C 更多的错误检查，并且作为一门 高级语言，它内置支持高级的数据结构类型，例如：灵活的数组和字典。 Python 允许你将程序分割为不同的模块，以便在其他的 Python 程序中重用。Python 内置提供了大量的标准模块，你可以将其用作程序的基础，或者作为学习 Python 编程的示例。这些模块提供了诸如文件 I/O、系统调用、Socket 支持，甚至类似 Tk 的用户图形界面（GUI）工具包接口 Python 是一门解释型语言，因为无需编译和链接，你可以在程序开发中节省宝贵的时间。Python 解释器可以交互的使用，这使得试验语言的特性、编写临时程序或在自底向上的程序开发中测试方法非常容易。你甚至还可以把它当做一个桌面计算器。 Python 让程序编写的紧凑和可读。用 Python 编写的程序通常比同样的 C、C++ 或 Java 程序更短小，这是因为以下几个原因: 12345* 高级数据结构使你可以在一条语句中表达复杂的操作；* 语句组使用缩进代替开始和结束大括号来组织；* 变量或参数无需声明。 Python 是 可扩展 的：如果你会 C 语言编程便可以轻易地为解释器添加内置函数或模块，或者为了对性能瓶颈作优化，或者将 Python 程序与只有二进制形式的库（比如某个专业的商业图形库）连接起来。一旦你真正掌握了它，你可以将 Python 解释器集成进某个 C 应用程序，并把它当作那个程序的扩展或命令行语言。 ​","categories":[{"name":"Python","slug":"Python","permalink":"https://hxlpub.github.io/categories/Python/"}],"tags":[{"name":"python","slug":"python","permalink":"https://hxlpub.github.io/tags/python/"}]},{"title":"newpc_test_for_hexo_blog","slug":"newpc","date":"2022-01-15T09:05:23.000Z","updated":"2022-03-26T08:50:54.949Z","comments":true,"path":"2022/01/15/newpc/","link":"","permalink":"https://hxlpub.github.io/2022/01/15/newpc/","excerpt":"","text":"ps:new year love more ！！！","categories":[{"name":"startup","slug":"startup","permalink":"https://hxlpub.github.io/categories/startup/"}],"tags":[{"name":"love more","slug":"love-more","permalink":"https://hxlpub.github.io/tags/love-more/"}]},{"title":"设计模式","slug":"system_design_thinking","date":"2022-01-13T02:16:07.000Z","updated":"2022-03-26T08:51:57.827Z","comments":true,"path":"2022/01/13/system_design_thinking/","link":"","permalink":"https://hxlpub.github.io/2022/01/13/system_design_thinking/","excerpt":"","text":"1、异步同步阻塞非阻塞（以下知乎十分有趣） https://www.zhihu.com/question/26393784 老张爱喝茶，废话不说，煮开水。 出场人物：老张，水壶两把（普通水壶，简称水壶；会响的水壶，简称响水壶）。 1)老张把水壶放到火上，立等水开。（同步阻塞） 老张觉得自己有点傻 2)老张把水壶放到火上，去客厅看电视，时不时去厨房看看水开没有。（同步非阻塞） 老张还是觉得自己有点傻，于是变高端了，买了把会响笛的那种水壶。水开之后，能大声发出嘀~~~~的噪音。 3)老张把响水壶放到火上，立等水开。（异步阻塞） 老张觉得这样傻等意义不大 4)老张把响水壶放到火上，去客厅看电视，水壶响之前不再去看它了，响了再去拿壶。（异步非阻塞） 老张觉得自己聪明了。 所谓同步异步，只是对于水壶而言。 普通水壶，同步；响水壶，异步。 虽然都能干活，但响水壶可以在自己完工之后，提示老张水开了。这是普通水壶所不能及的。 同步只能让调用者去轮询自己（情况2中），造成老张效率的低下。所谓阻塞非阻塞，仅仅对于老张而言。 立等的老张，阻塞；看电视的老张，非阻塞。 情况1和情况3中老张就是阻塞的，媳妇喊他都不知道。虽然3中响水壶是异步的，可对于立等的老张没有太大的意义。所以一般异步是配合非阻塞使用的，这样才能发挥异步的效用。 作者：知乎用户链接：https://www.zhihu.com/question/26393784/answer/513257548来源：知乎著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://hxlpub.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://hxlpub.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"golang 搭建知识体系-basics","slug":"go_base","date":"2022-01-09T04:47:30.000Z","updated":"2022-05-14T09:37:08.612Z","comments":true,"path":"2022/01/09/go_base/","link":"","permalink":"https://hxlpub.github.io/2022/01/09/go_base/","excerpt":"","text":"go简介Go 是一个开源的编程语言，它能让构造简单、可靠且高效的软件变得容易。 特色 简洁、快速、安全 并行、有趣、开源 内存管理、数组安全、编译迅速 Go 语言最主要的特性： 自动垃圾回收 更丰富的内置类型 函数多返回值 错误处理 匿名函数和闭包 类型和接口 并发编程 反射 语言交互性 用途 Go 语言被设计成一门应用于搭载 Web 服务器，存储集群或类似用途的巨型中央服务器的系统编程语言。 对于高性能分布式系统领域而言，Go 语言无疑比大多数其它语言有着更高的开发效率。它提供了海量并行的支持，这对于游戏服务端的开发而言是再好不过了。 hello go 123456789101112131415161718package mainimport &quot;fmt&quot;func main()&#123; fmt.Println(&quot;hello go!!!&quot;)&#125;[root@192 go]# go run hello.go #go run 执行hello go!!![root@192 go]# go build hello.go #go build 编译生成二进制[root@192 go]# lltotal 1896-rwxr-xr-x. 1 root root 1937013 Mar 14 10:00 hello-rw-r--r--. 1 root root 70 Mar 14 09:59 hello.go[root@192 go]# ./hello hello go!!! 程序结构 包声明 引入包 函数 变量 语句 &amp; 表达式 注释 12345678package mainimport &quot;fmt&quot;func main() &#123;// 注意&#123; 不能在单独的行上，否则会报错 /* 这是我的第一个简单的程序 */ fmt.Println(&quot;Hello, World!&quot;)&#125; 第一行代码 package main 定义了包名。你必须在源文件中非注释的第一行指明这个文件属于哪个包，如：package main。package main表示一个可独立执行的程序，每个 Go 应用程序都包含一个名为 main 的包。 下一行 import “fmt” 告诉 Go 编译器这个程序需要使用 fmt 包（的函数，或其他元素），fmt 包实现了格式化 IO（输入/输出）的函数。 下一行 func main() 是程序开始执行的函数。main 函数是每一个可执行程序所必须包含的，一般来说都是在启动后第一个执行的函数（如果有 init() 函数则会先执行该函数）。 下一行 /…/ 是注释，在程序执行时将被忽略。单行注释是最常见的注释形式，你可以在任何地方使用以 // 开头的单行注释。多行注释也叫块注释，均已以 /* 开头，并以 */ 结尾，且不可以嵌套使用，多行注释一般用于包的文档描述或注释成块的代码片段。 下一行 fmt.Println(…) 可以将字符串输出到控制台，并在最后自动增加换行字符 \\n。使用 fmt.Print(“hello, world\\n”) 可以得到相同的结果。Print 和 Println 这两个函数也支持使用变量，如：fmt.Println(arr)。如果没有特别指定，它们会以默认的打印格式将变量 arr 输出到控制台。 当标识符（包括常量、变量、类型、函数名、结构字段等等）以一个大写字母开头，如：Group1，那么使用这种形式的标识符的对象就可以被外部包的代码所使用（客户端程序需要先导入这个包），这被称为导出（像面向对象语言中的 public）；标识符如果以小写字母开头，则对包外是不可见的，但是他们在整个包的内部是可见并且可用的（像面向对象语言中的 protected ）。 基础语法 Go 标记 ​ Go 程序可以由多个标记组成，可以是关键字，标识符，常量，字符串，符号。如以下 GO 语句由 6 个标记组成： 1fmt.Println(&quot;Hello, World!&quot;) ​ 6 个标记是(每行一个)： 1234561. fmt2. .3. Println4. (5. &quot;Hello, World!&quot;6. ) 行分隔符 在 Go 程序中，一行代表一个语句结束。每个语句不需要像 C 家族中的其它语言一样以分号 ; 结尾，因为这些工作都将由 Go 编译器自动完成。 如果你打算将多个语句写在同一行，它们则必须使用 ; 人为区分，但在实际开发中我们并不鼓励这种做法。 以下为两个语句： 12fmt.Println(&quot;Hello, World!&quot;)fmt.Println(&quot;菜鸟教程：runoob.com&quot;) 注释 注释不会被编译，每一个包应该有相关注释。 单行注释是最常见的注释形式，你可以在任何地方使用以 // 开头的单行注释。多行注释也叫块注释，均已以 /* 开头，并以 */ 结尾。如： 12345// 单行注释/* Author by 菜鸟教程 我是多行注释 */ 标识符 标识符用来命名变量、类型等程序实体。一个标识符实际上就是一个或是多个字母(AZ和az)数字(0~9)、下划线_组成的序列，但是第一个字符必须是字母或下划线而不能是数字。 以下是有效的标识符： 12mahesh kumar abc move_name a_123myname50 _temp j a23b9 retVal 以下是无效的标识符： 1ab（以数字开头） case（Go 语言的关键字） a+b（运算符是不允许的） 字符串连接 Go 语言的字符串可以通过 + 实现： 实例 12345package mainimport &quot;fmt&quot;func main() &#123; fmt.Println(&quot;Google&quot; + &quot;Runoob&quot;)&#125; 关键字 下面列举了 Go 代码中会使用到的 25 个关键字或保留字： break default func interface select case defer go map struct chan else goto package switch const fallthrough if range type continue for import return var 除了以上介绍的这些关键字，Go 语言还有 36 个预定义标识符： append bool byte cap close complex complex64 complex128 uint16 copy false float32 float64 imag int int8 int16 uint32 int32 int64 iota len make new nil panic uint64 print println real recover string true uint uint8 uintptr 程序一般由关键字、常量、变量、运算符、类型和函数组成。 程序中可能会使用到这些分隔符：括号 ()，中括号 [] 和大括号 {}。 程序中可能会使用到这些标点符号：.、,、;、: 和 …。 Go 语言的空格 Go 语言中变量的声明必须使用空格隔开，如： 1var age int 语句中适当使用空格能让程序更易阅读。 无空格： 1fruit=apples+oranges 在变量与运算符间加入空格，程序看起来更加美观，如： 1fruit = apples + oranges; 格式化字符串 Go 语言中使用 fmt.Sprintf 格式化字符串并赋值给新串： 实例 package main import ( “fmt”) 12345678func main() &#123; // %d 表示整型数字，%s 表示字符串 var stockcode=123 var enddate=&quot;2020-12-31&quot; var url=&quot;Code=%d&amp;endDate=%s&quot; var target_url=fmt.Sprintf(url,stockcode,enddate) fmt.Println(target_url)&#125; 输出结果为： 1Code=123&amp;endDate=2020-12-31 Go 可以使用 fmt.Sprintf 来格式化字符串，格式如下： 1fmt.Sprintf(格式化样式, 参数列表…) 格式化样式：字符串形式，格式化符号以 % 开头， %s 字符串格式，%d 十进制的整数格式。 参数列表：多个参数以逗号分隔，个数必须与格式化样式中的个数一一对应，否则运行时会报错。 Go 字符串格式化符号: 格 式 描 述 %v 按值的本来值输出 %+v 在 %v 基础上，对结构体字段名和值进行展开 %#v 输出 Go 语言语法格式的值 %T 输出 Go 语言语法格式的类型和值 %% 输出 % 本体 %b 整型以二进制方式显示 %o 整型以八进制方式显示 %d 整型以十进制方式显示 %x 整型以十六进制方式显示 %X 整型以十六进制、字母大写方式显示 %U Unicode 字符 %f 浮点数 %p 指针，十六进制方式显示 数据类型在 Go 编程语言中，数据类型用于声明函数和变量。 数据类型的出现是为了把数据分成所需内存大小不同的数据，编程的时候需要用大数据的时候才需要申请大内存，就可以充分利用内存。 Go 语言按类别有以下几种数据类型： 序号 类型和描述 1 布尔型 布尔型的值只可以是常量 true 或者 false。一个简单的例子：var b bool = true。 2 数字类型 整型 int 和浮点型 float32、float64，Go 语言支持整型和浮点型数字，并且支持复数，其中位的运算采用补码。 3 字符串类型: 字符串就是一串固定长度的字符连接起来的字符序列。Go 的字符串是由单个字节连接起来的。Go 语言的字符串的字节使用 UTF-8 编码标识 Unicode 文本。 4 派生类型: 包括：(a) 指针类型（Pointer）(b) 数组类型(c) 结构化类型(struct)(d) Channel 类型(e) 函数类型(f) 切片类型(g) 接口类型（interface）(h) Map 类型 数字类型 Go 也有基于架构的类型，例如：int、uint 和 uintptr。 序号 类型和描述 1 uint8 无符号 8 位整型 (0 到 255) 2 uint16 无符号 16 位整型 (0 到 65535) 3 uint32 无符号 32 位整型 (0 到 4294967295) 4 uint64 无符号 64 位整型 (0 到 18446744073709551615) 5 int8 有符号 8 位整型 (-128 到 127) 6 int16 有符号 16 位整型 (-32768 到 32767) 7 int32 有符号 32 位整型 (-2147483648 到 2147483647) 8 int64 有符号 64 位整型 (-9223372036854775808 到 9223372036854775807) 浮点型 序号 类型和描述 1 float32 IEEE-754 32位浮点型数 2 float64 IEEE-754 64位浮点型数 3 complex64 32 位实数和虚数 4 complex128 64 位实数和虚数 其他数字类型 以下列出了其他更多的数字类型： 序号 类型和描述 1 byte 类似 uint8 2 rune 类似 int32 3 uint 32 或 64 位 4 int 与 uint 一样大小 5 uintptr 无符号整型，用于存放一个指针 变量变量来源于数学，是计算机语言中能储存计算结果或能表示值抽象概念。 变量可以通过变量名访问。 Go 语言变量名由字母、数字、下划线组成，其中首个字符不能为数字。 声明变量的一般形式是使用 var 关键字： 1var identifier type 可以一次声明多个变量： 1var identifier1, identifier2 type 12345678910111213package mainimport &quot;fmt&quot;func main() &#123; var a string = &quot;Runoob&quot; fmt.Println(a) var b, c int = 1, 2 fmt.Println(b, c)&#125;以上实例输出结果为：Runoob1 2 变量声明 第一种，指定变量类型，如果没有初始化，则变量默认为零值。 123456789101112131415161718192021222324var v_name v_typev_name = value零值就是变量没有做初始化时系统默认设置的值。package mainimport &quot;fmt&quot;func main() &#123; // 声明一个变量并初始化 var a = &quot;RUNOOB&quot; fmt.Println(a) // 没有初始化就为零值 var b int fmt.Println(b) // bool 零值为 false var c bool fmt.Println(c)&#125;以上实例执行结果为：RUNOOB0false 数值类型（包括complex64/128）为 0 布尔类型为 false 字符串为 **””**（空字符串） 以下几种类型为 nil： ```govar a *intvar a []intvar a map[string] intvar a chan intvar a func(string) intvar a error // error 是接口package mainimport “fmt”func main() {var i int var f float64 var b bool var s string fmt.Printf(&quot;%v %v %v %q\\n&quot;, i, f, b, s) }输出结果是：0 0 false “”12345**第二种，根据值自行判定变量类型。**```govar v_name = value 123456789package mainimport &quot;fmt&quot;func main() &#123; var d = true fmt.Println(d)&#125;输出结果是：true 第三种，如果变量已经使用 var 声明过了，再使用 *:=* 声明变量，就产生编译错误，格式： 1v_name := value 12var intVal int intVal :=1 // 这时候会产生编译错误，因为 intVal 已经声明，不需要重新声明 直接使用下面的语句即可： 12345intVal := 1 // 此时不会产生编译错误，因为有声明新的变量，因为 := 是一个声明语句intVal := 1 相等于：var intVal int intVal =1 多变量声明 1234567891011121314//类型相同多个变量, 非全局变量var vname1, vname2, vname3 typevname1, vname2, vname3 = v1, v2, v3var vname1, vname2, vname3 = v1, v2, v3 // 和 python 很像,不需要显示声明类型，自动推断vname1, vname2, vname3 := v1, v2, v3 // 出现在 := 左侧的变量不应该是已经被声明过的，否则会导致编译错误// 这种因式分解关键字的写法一般用于声明全局变量var ( vname1 v_type1 vname2 v_type2) 123456789101112131415161718192021package mainvar x, y intvar ( // 这种因式分解关键字的写法一般用于声明全局变量 a int b bool)var c, d int = 1, 2var e, f = 123, &quot;hello&quot;//这种不带声明格式的只能在函数体中出现//g, h := 123, &quot;hello&quot;func main()&#123; g, h := 123, &quot;hello&quot; println(x, y, a, b, c, d, e, f, g, h)&#125;以上实例执行结果为：0 0 0 false 1 2 123 hello 123 hello 简短形式，使用 := 赋值操作符 a := 50 或 b := false。 a 和 b 的类型（int 和 bool）将由编译器自动推断。 这是使用变量的首选形式，但是它只能被用在函数体内，而不可以用于全局变量的声明与赋值。使用操作符 := 可以高效地创建一个新的变量，称之为初始化声明。 注意事项 如果在相同的代码块中，我们不可以再次对于相同名称的变量使用初始化声明，例如：a := 20 就是不被允许的，编译器会提示错误 no new variables on left side of :=，但是 a = 20 是可以的，因为这是给相同的变量赋予一个新的值。 如果你在定义变量 a 之前使用它，则会得到编译错误 undefined: a。 如果你声明了一个局部变量却没有在相同的代码块中使用它，同样会得到编译错误; 但是全局变量是允许声明但不使用的。 同一类型的多个变量可以声明在同一行，如： 1var a, b, c int 多变量可以在同一行进行赋值，如： 123var a, b intvar c stringa, b, c = 5, 7, &quot;abc&quot; 上面这行假设了变量 a，b 和 c 都已经被声明，否则的话应该这样使用： 1a, b, c := 5, 7, &quot;abc&quot; 右边的这些值以相同的顺序赋值给左边的变量，所以 a 的值是 5， b 的值是 7，c 的值是 “abc”。 这被称为 并行 或 同时 赋值。 如果你想要交换两个变量的值，则可以简单地使用 a, b = b, a，两个变量的类型必须是相同。 空白标识符 _ 也被用于抛弃值，如值 5 在：_, b = 5, 7 中被抛弃。 _ 实际上是一个只写变量，你不能得到它的值。这样做是因为 Go 语言中你必须使用所有被声明的变量，但有时你并不需要使用从一个函数得到的所有返回值。 并行赋值也被用于当一个函数返回多个返回值时，比如这里的 val 和错误 err 是通过调用 Func1 函数同时得到：val, err = Func1(var1)。 常量常量是一个简单值的标识符，在程序运行时，不会被修改的量。 常量中的数据类型只可以是布尔型、数字型（整数型、浮点型和复数）和字符串型。 常量的定义格式： 1const identifier [type] = value 你可以省略类型说明符 [type]，因为编译器可以根据变量的值来推断其类型。 显式类型定义： const b string = &quot;abc&quot; 隐式类型定义： const b = &quot;abc&quot; 多个相同类型的声明可以简写为： 1const c_name1, c_name2 = value1, value2 12345678910111213141516171819package mainimport &quot;fmt&quot;func main() &#123; const LENGTH int = 10 const WIDTH int = 5 var area int const a, b, c = 1, false, &quot;str&quot; //多重赋值 area = LENGTH * WIDTH fmt.Printf(&quot;面积为 : %d&quot;, area) println() println(a, b, c) &#125;以上实例运行结果为：面积为 : 501 false str 常量还可以用作枚举： 12345const ( Unknown = 0 Female = 1 Male = 2) 常量可以用len(), cap(), unsafe.Sizeof()函数计算表达式的值。常量表达式中，函数必须是内置函数，否则编译不过： 实例 123456789101112package mainimport &quot;unsafe&quot;const ( a = &quot;abc&quot; b = len(a) c = unsafe.Sizeof(a))func main()&#123; println(a, b, c)&#125; 以上实例运行结果为： 1abc 3 16 iota iota，特殊常量，可以认为是一个可以被编译器修改的常量。 iota 在 const关键字出现时将被重置为 0(const 内部的第一行之前)，const 中每新增一行常量声明将使 iota 计数一次(iota 可理解为 const 语句块中的行索引)。 iota 可以被用作枚举值： 12345const ( a = iota b = iota c = iota) 第一个 iota 等于 0，每当 iota 在新的一行被使用时，它的值都会自动加 1；所以 a=0, b=1, c=2 可以简写为如下形式： 12345const ( a = iota b c) 123456789101112131415161718192021package mainimport &quot;fmt&quot;func main() &#123; const ( a = iota //0 b //1 c //2 d = &quot;ha&quot; //独立值，iota += 1 e //&quot;ha&quot; iota += 1 f = 100 //iota +=1 g //100 iota +=1 h = iota //7,恢复计数 i //8 ) fmt.Println(a,b,c,d,e,f,g,h,i)&#125;以上实例运行结果为：0 1 2 ha ha 100 100 7 8 运算符注意：go没有三目运算符 优先级 分类 运算符 结合性 1 逗号运算符 , 从左到右 2 赋值运算符 =、+=、-=、*=、/=、 %=、 &gt;&gt;=、 &lt;&lt;=、&amp;=、^=、|= 从右到左 3 逻辑或 || 从左到右 4 逻辑与 &amp;&amp; 从左到右 5 按位或 | 从左到右 6 按位异或 ^ 从左到右 7 按位与 &amp; 从左到右 8 相等/不等 ==、!= 从左到右 9 关系运算符 &lt;、&lt;=、&gt;、&gt;= 从左到右 10 位移运算符 &lt;&lt;、&gt;&gt; 从左到右 11 加法/减法 +、- 从左到右 12 乘法/除法/取余 *（乘号）、/、% 从左到右 13 单目运算符 + 、-、 !、 ~、 (type)*、 &amp; sizeof （待确认） 从右到左 14 后缀运算符 ( )、[ ]、-&gt;、.、++、– 从左到右 http://c.biancheng.net/view/5559.html 条件语句Go 语言提供了以下几种条件判断语句： 语句 描述 if 语句 if 语句 由一个布尔表达式后紧跟一个或多个语句组成。 if…else 语句 if 语句 后可以使用可选的 else 语句, else 语句中的表达式在布尔表达式为 false 时执行。 if 嵌套语句 你可以在 if 或 else if 语句中嵌入一个或多个 if 或 else if 语句。 switch 语句 switch 语句用于基于不同条件执行不同动作。 select 语句 select 语句类似于 switch 语句，但是select会随机执行一个可运行的case。如果没有case可运行，它将阻塞，直到有case可运行。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798991001011021031041051061071081091101111121131141151161171181191201211221231241251261271281291301.if if 布尔表达式 &#123; /* 如果条件为 true 则执行以下语句 */ &#125;2.if elseif 布尔表达式 &#123; /* 如果条件为 true 则执行以下语句 */&#125; else &#123; /* 如果条件为 false 则执行以下语句 */ &#125;3.if嵌套 if 布尔表达式1 &#123; /* if 条件语句为 true 执行 */ if 布尔表达式2 &#123; /* if 条件语句为 true 执行 */ &#125; &#125;4.switchswitch var1 &#123; case val1: ... case val2: ... default: ...&#125;/* 定义局部变量 */ var grade string = &quot;B&quot; var marks int = 90 switch marks &#123; case 90: grade = &quot;A&quot; case 80: grade = &quot;B&quot; case 50,60,70 : grade = &quot;C&quot; default: grade = &quot;D&quot; &#125; switch &#123; case grade == &quot;A&quot; : fmt.Printf(&quot;优秀!\\n&quot; ) case grade == &quot;B&quot;, grade == &quot;C&quot; : fmt.Printf(&quot;良好\\n&quot; ) case grade == &quot;D&quot; : fmt.Printf(&quot;及格\\n&quot; ) case grade == &quot;F&quot;: fmt.Printf(&quot;不及格\\n&quot; ) default: fmt.Printf(&quot;差\\n&quot; ); &#125;5.Type Switchswitch 语句还可以被用于 type-switch 来判断某个 interface 变量中实际存储的变量类型。Type Switch 语法格式如下：switch x.(type)&#123; case type: statement(s); case type: statement(s); /* 你可以定义任意个数的case */ default: /* 可选 */ statement(s);&#125;var x interface&#123;&#125; switch i := x.(type) &#123; case nil: fmt.Printf(&quot; x 的类型 :%T&quot;,i) case int: fmt.Printf(&quot;x 是 int 型&quot;) case float64: fmt.Printf(&quot;x 是 float64 型&quot;) case func(int) float64: fmt.Printf(&quot;x 是 func(int) 型&quot;) case bool, string: fmt.Printf(&quot;x 是 bool 或 string 型&quot; ) default: fmt.Printf(&quot;未知型&quot;) &#125; 6.fallthrough使用 fallthrough 会强制执行后面的 case 语句，fallthrough 不会判断下一条 case 的表达式结果是否为 true。func main()&#123; switch &#123; case false: fmt.Println(&quot;1、case 条件语句为 false&quot;) fallthrough case true: fmt.Println(&quot;2、case 条件语句为 true&quot;) fallthrough case false: fmt.Println(&quot;3、case 条件语句为 false&quot;) fallthrough case true: fmt.Println(&quot;4、case 条件语句为 true&quot;) case false: fmt.Println(&quot;5、case 条件语句为 false&quot;) fallthrough default: fmt.Println(&quot;6、默认 case&quot;) &#125;&#125;以上代码执行结果为：2、case 条件语句为 true3、case 条件语句为 false4、case 条件语句为 true从以上代码输出的结果可以看出：switch 从第一个判断表达式为 true 的 case 开始执行，如果 case 带有 fallthrough，程序会继续执行下一条 case，且它不会去判断下一个 case 的表达式是否为 true。7.select select是 Go 中的一个控制结构，类似于用于通信的 switch 语句。每个 case 必须是一个通信操作，要么是发送要么是接收。select 随机执行一个可运行的 case。如果没有 case 可运行，它将阻塞，直到有 case 可运行。一个默认的子句应该总是可运行的。select 语句的语法如下：select &#123; case communication clause : statement(s); case communication clause : statement(s); /* 你可以定义任意数量的 case */ default : /* 可选 */ statement(s);&#125;以下描述了 select 语句的语法：每个 case 都必须是一个通信所有 channel 表达式都会被求值所有被发送的表达式都会被求值如果任意某个通信可以进行，它就执行，其他被忽略。如果有多个 case 都可以运行，Select 会随机公平地选出一个执行。其他不会执行。否则：1.如果有 default 子句，则执行该语句。2.如果没有 default 子句，select 将阻塞，直到某个通信可以运行；Go 不会重新对 channel 或值进行求值。以上代码执行结果为：no communication 循环语句函数匿名函数​ https://www.jianshu.com/p/91140fdd6e91 变量作用域数组指针结构体注意结构体标签如，Age int json:&quot;age,omitempty&quot; https://www.cnblogs.com/liyutian/p/10050320.html 切片Go 语言切片是对数组的抽象。 Go 数组的长度不可改变，在特定场景中这样的集合就不太适用，Go 中提供了一种灵活，功能强悍的内置类型切片(“动态数组”)，与数组相比切片的长度是不固定的，可以追加元素，在追加时可能使切片的容量增大。 定义切片： 你可以声明一个未指定大小的数组来定义切片： 1var identifier []type 切片不需要说明长度。 或使用 make() 函数来创建切片: 123var slice1 []type = make([]type, len)也可以简写为slice1 := make([]type, len) 也可以指定容量，其中 capacity 为可选参数。 1make([]T, length, capacity) 这里 len 是数组的长度并且也是切片的初始长度。 切片初始化 1s :=[] int &#123;1,2,3 &#125; 直接初始化切片，**[]** 表示是切片类型，**{1,2,3}** 初始化值依次是 1,2,3，其 cap=len=3。 1s := arr[:] 初始化切片 s，是数组 arr 的引用。 1s := arr[startIndex:endIndex] 将 arr 中从下标 startIndex 到 endIndex-1 下的元素创建为一个新的切片。 1s := arr[startIndex:] 默认 endIndex 时将表示一直到arr的最后一个元素。 1s := arr[:endIndex] 默认 startIndex 时将表示从 arr 的第一个元素开始。 1s1 := s[startIndex:endIndex] 通过切片 s 初始化切片 s1。 1s :=make([]int,len,cap) 通过内置函数 make() 初始化切片s，**[]int** 标识为其元素类型为 int 的切片。 切片是可索引的，并且可以由 len() 方法获取长度。 切片提供了计算容量的方法 cap() 可以测量切片最长可以达到多少。 以下为具体实例： 实例 12345678910111213package mainimport &quot;fmt&quot;func main() &#123; var numbers = make([]int,3,5) printSlice(numbers)&#125;func printSlice(x []int)&#123; fmt.Printf(&quot;len=%d cap=%d slice=%v**\\n**&quot;,len(x),cap(x),x)&#125; 以上实例运行输出结果为: 1len=3 cap=5 slice=[0 0 0] 空(nil)切片 一个切片在未初始化之前默认为 nil，长度为 0，实例如下： 实例 12345678910111213141516package mainimport &quot;fmt&quot;func main() &#123; var numbers []int printSlice(numbers) if(numbers == nil)&#123; fmt.Printf(&quot;切片是空的&quot;) &#125;&#125;func printSlice(x []int)&#123; fmt.Printf(&quot;len=%d cap=%d slice=%v**\\n**&quot;,len(x),cap(x),x)&#125; 以上实例运行输出结果为: 12len=0 cap=0 slice=[]切片是空的 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package mainimport &quot;fmt&quot;func main() &#123; /* 创建切片 */ numbers := []int&#123;0,1,2,3,4,5,6,7,8&#125; printSlice(numbers) /* 打印原始切片 */ fmt.Println(&quot;numbers ==&quot;, numbers) /* 打印子切片从索引1(包含) 到索引4(不包含)*/ fmt.Println(&quot;numbers[1:4] ==&quot;, numbers[1:4]) /* 默认下限为 0*/ fmt.Println(&quot;numbers[:3] ==&quot;, numbers[:3]) /* 默认上限为 len(s)*/ fmt.Println(&quot;numbers[4:] ==&quot;, numbers[4:]) numbers1 := make([]int,0,5) printSlice(numbers1) /* 打印子切片从索引 0(包含) 到索引 2(不包含) */ number2 := numbers[:2] printSlice(number2) /* 打印子切片从索引 2(包含) 到索引 5(不包含) */ number3 := numbers[2:5] printSlice(number3)&#125;func printSlice(x []int)&#123; fmt.Printf(&quot;len=%d cap=%d slice=%v\\n&quot;,len(x),cap(x),x)&#125;执行以上代码输出结果为：len=9 cap=9 slice=[0 1 2 3 4 5 6 7 8]numbers == [0 1 2 3 4 5 6 7 8]numbers[1:4] == [1 2 3]numbers[:3] == [0 1 2]numbers[4:] == [4 5 6 7 8]len=0 cap=5 slice=[]len=2 cap=9 slice=[0 1]len=3 cap=7 slice=[2 3 4] append() 和 copy() 函数 如果想增加切片的容量，我们必须创建一个新的更大的切片并把原分片的内容都拷贝过来。 下面的代码描述了从拷贝切片的 copy 方法和向切片追加新元素的 append 方法。 1234567891011121314151617181920212223242526272829303132333435363738package mainimport &quot;fmt&quot;func main() &#123; var numbers []int printSlice(numbers) /* 允许追加空切片 */ numbers = append(numbers, 0) printSlice(numbers) /* 向切片添加一个元素 */ numbers = append(numbers, 1) printSlice(numbers) /* 同时添加多个元素 */ numbers = append(numbers, 2,3,4) printSlice(numbers) /* 创建切片 numbers1 是之前切片的两倍容量*/ numbers1 := make([]int, len(numbers), (cap(numbers))*2) /* 拷贝 numbers 的内容到 numbers1 */ copy(numbers1,numbers) printSlice(numbers1) &#125;func printSlice(x []int)&#123; fmt.Printf(&quot;len=%d cap=%d slice=%v\\n&quot;,len(x),cap(x),x)&#125;以上代码执行输出结果为：len=0 cap=0 slice=[]len=1 cap=1 slice=[0]len=2 cap=2 slice=[0 1]len=5 cap=6 slice=[0 1 2 3 4]len=5 cap=12 slice=[0 1 2 3 4] 范围Map（集合）递归函数类型转换接口错误处理并发channel 参考： https://www.runoob.com/w3cnote/go-channel-intro.html Channel是Go中的一个核心类型，你可以把它看成一个管道，通过它并发核心单元就可以发送或者接收数据进行通讯(communication)。 它的操作符是箭头 &lt;- 。 12ch &lt;- v // 发送值v到Channel ch中v := &lt;-ch // 从Channel ch中接收数据，并将数据赋值给v (箭头的指向就是数据的流向) 就像 map 和 slice 数据类型一样, channel必须先创建再使用: 1ch := make(chan int) channel类型 Channel类型的定义格式如下： 1ChannelType = ( &quot;chan&quot; | &quot;chan&quot; &quot;&lt;-&quot; | &quot;&lt;-&quot; &quot;chan&quot; ) ElementType . 它包括三种类型的定义。可选的&lt;-代表channel的方向。如果没有指定方向，那么Channel就是双向的，既可以接收数据，也可以发送数据。 123chan T // 可以接收和发送类型为 T 的数据chan&lt;- float64 // 只可以用来发送 float64 类型的数据&lt;-chan int // 只可以用来接收 int 类型的数据 &lt;-总是优先和最左边的类型结合。 1234chan&lt;- chan int // 等价 chan&lt;- (chan int)chan&lt;- &lt;-chan int // 等价 chan&lt;- (&lt;-chan int)&lt;-chan &lt;-chan int // 等价 &lt;-chan (&lt;-chan int)chan (&lt;-chan int) 使用make初始化Channel,并且可以设置容量: 1make(chan int, 100) 容量(capacity)代表Channel容纳的最多的元素的数量，代表Channel的缓存的大小。如果没有设置容量，或者容量设置为0, 说明Channel没有缓存，只有sender和receiver都准备好了后它们的通讯(communication)才会发生(Blocking)。如果设置了缓存，就有可能不发生阻塞， 只有buffer满了后 send才会阻塞， 而只有缓存空了后receive才会阻塞。一个nil channel不会通信。 可以通过内建的close方法可以关闭Channel。 你可以在多个goroutine从/往 一个channel 中 receive/send 数据, 不必考虑额外的同步措施。 Channel可以作为一个先入先出(FIFO)的队列，接收的数据和发送的数据的顺序是一致的。 channel的 receive支持 multi-valued assignment，如 1v, ok := &lt;-ch 它可以用来检查Channel是否已经被关闭了。 send语句send语句用来往Channel中发送数据， 如ch &lt;- 3。它的定义如下: 12SendStmt = Channel &quot;&lt;-&quot; Expression .Channel = Expression . 在通讯(communication)开始前channel和expression必选先求值出来(evaluated)，比如下面的(3+4)先计算出7然后再发送给channel。 12345c := make(chan int)defer close(c)go func() &#123; c &lt;- 3 + 4 &#125;()i := &lt;-cfmt.Println(i) send被执行前(proceed)通讯(communication)一直被阻塞着。如前所言，无缓存的channel只有在receiver准备好后send才被执行。如果有缓存，并且缓存未满，则send会被执行。 往一个已经被close的channel中继续发送数据会导致run-time panic。 往nil channel中发送数据会一致被阻塞着。 ​ receive 操作符&lt;-ch用来从channel ch中接收数据，这个表达式会一直被block,直到有数据可以接收。 从一个nil channel中接收数据会一直被block。 从一个被close的channel中接收数据不会被阻塞，而是立即返回，接收完已发送的数据后会返回元素类型的零值(zero value)。 如前所述，你可以使用一个额外的返回参数来检查channel是否关闭。 123x, ok := &lt;-chx, ok = &lt;-chvar x, ok = &lt;-ch 如果OK 是false，表明接收的x是产生的零值，这个channel被关闭了或者为空。 blocking 默认情况下，发送和接收会一直阻塞着，直到另一方准备好。这种方式可以用来在gororutine中进行同步，而不必使用显示的锁或者条件变量。 如官方的例子中x, y := &lt;-c, &lt;-c这句会一直等待计算结果发送到channel中。 12345678910111213141516import &quot;fmt&quot;func sum(s []int, c chan int) &#123; sum := 0 for _, v := range s &#123; sum += v &#125; c &lt;- sum // send sum to c&#125;func main() &#123; s := []int&#123;7, 2, 8, -9, 4, 0&#125; c := make(chan int) go sum(s[:len(s)/2], c) go sum(s[len(s)/2:], c) x, y := &lt;-c, &lt;-c // receive from c fmt.Println(x, y, x+y)&#125; Buffered channels Range select timeout Timer and Ticker close 同步 开发工具 其他： 符号… https://blog.csdn.net/jeffrey11223/article/details/79166724 package作用以及定义 https://www.jianshu.com/p/df33ee0d51ce go test 测试","categories":[{"name":"golang","slug":"golang","permalink":"https://hxlpub.github.io/categories/golang/"}],"tags":[{"name":"golang","slug":"golang","permalink":"https://hxlpub.github.io/tags/golang/"}]},{"title":"golang 编码规范","slug":"go_base_coding_rule","date":"2022-01-09T04:47:30.000Z","updated":"2022-05-14T09:37:12.615Z","comments":true,"path":"2022/01/09/go_base_coding_rule/","link":"","permalink":"https://hxlpub.github.io/2022/01/09/go_base_coding_rule/","excerpt":"","text":"","categories":[{"name":"golang","slug":"golang","permalink":"https://hxlpub.github.io/categories/golang/"}],"tags":[{"name":"golang","slug":"golang","permalink":"https://hxlpub.github.io/tags/golang/"}]},{"title":"Makefile","slug":"Makefile","date":"2021-11-09T11:56:07.000Z","updated":"2022-03-26T09:11:58.775Z","comments":true,"path":"2021/11/09/Makefile/","link":"","permalink":"https://hxlpub.github.io/2021/11/09/Makefile/","excerpt":"","text":"​","categories":[{"name":"编译","slug":"编译","permalink":"https://hxlpub.github.io/categories/%E7%BC%96%E8%AF%91/"}],"tags":[{"name":"Makefile","slug":"Makefile","permalink":"https://hxlpub.github.io/tags/Makefile/"}]},{"title":"【c++】构建c++知识体系：basics","slug":"cplusplus","date":"2021-11-06T03:55:07.000Z","updated":"2023-05-28T11:04:01.215Z","comments":true,"path":"2021/11/06/cplusplus/","link":"","permalink":"https://hxlpub.github.io/2021/11/06/cplusplus/","excerpt":"","text":"本文目的回顾并构建c++ 知识体系 语言特性 静态类型的、编译式的、通用的、大小写敏感的、不规则的编程语言，支持过程化编程、面向对象编程和泛型编程。（使用静态类型的编程语言是在编译时执行类型检查，而不是在运行时执行类型检查。） 面向对象的特性： 封装 抽象 继承 多态 标准库 ​ 标准的 C++ 由三个重要部分组成： 核心语言，提供了所有构件块，包括变量、数据类型和常量，等等。 C++ 标准库，提供了大量的函数，用于操作文件、字符串等。 标准模板库（STL），提供了大量的方法，用于操作数据结构等。 C++ 通常用于编写设备驱动程序和其他要求实时性的直接操作硬件的软件。 C++ 广泛用于教学和研究。 任何一个使用苹果电脑或 Windows PC 机的用户都在间接地使用 C++，因为这些系统的主要用户接口是使用 C++ 编写的。 基本语法 C++ 程序可以定义为对象的集合，这些对象通过调用彼此的方法进行交互 对象 - 对象具有状态和行为。例如：一只狗的状态 - 颜色、名称、品种，行为 - 摇动、叫唤、吃。对象是类的实例。 类 - 类可以定义为描述对象行为/状态的模板/蓝图。 方法 - 从基本上说，一个方法表示一种行为。一个类可以包含多个方法。可以在方法中写入逻辑、操作数据以及执行所有的动作。 即时变量 - 每个对象都有其独特的即时变量。对象的状态是由这些即时变量的值创建的。 分号是语句结束符。也就是说，每个语句必须以分号结束。它表明一个逻辑实体的结束。 语句块是一组使用大括号括起来的按逻辑连接的语句。 不以行末作为结束符的标识，因此，您可以在一行上放置多个语句。 1x = y; y = y+1; add(x, y); 标识符 C++ 标识符是用来标识变量、函数、类、模块，或任何其他用户自定义项目的名称。 一个标识符以字母 A-Z 或 a-z 或下划线 _ 开始，后跟零个或多个字母、下划线和数字（0-9）。 C++ 标识符内不允许出现标点字符，比如 @、&amp; 和 %。 大小写敏感 关键字 https://www.runoob.com/w3cnote/cpp-keyword-intro.html asm else new this auto enum operator throw bool explicit private true break export protected try case extern public typedef catch false register typeid char float reinterpret_cast typename class for return union const friend short unsigned const_cast goto signed using continue if sizeof virtual default inline static void delete int static_cast volatile do long struct wchar_t double mutable switch while dynamic_cast namespace template 注释 C++ 注释一般有两种： // - 一般用于单行注释。 /*** … */** - 一般用于多行注释。 数据类型 基本内置类型 类型 关键字 布尔型 bool 字符型 char 整型 int 浮点型 float 双浮点型 double 无类型 void 宽字符型 wchar_t 一些基本类型可以使用一个或多个类型修饰符进行修饰： signed unsigned short long 各种变量类型在内存中存储值时需要占用的内存，以及该类型的变量所能存储的最大值和最小值。 注意：不同系统会有所差异，一字节为 8 位，各种类型的存储大小与系统位数有关。 注意：默认情况下，int、short、long都是带符号的，即 signed。 注意：long int 8 个字节，int 都是 4 个字节，早期的 C 编译器定义了 long int 占用 4 个字节，int 占用 2 个字节，新版的 C/C++ 标准兼容了早期的这一设定。 typedef声明 为已有类型取一个新名字 语法：typedef type newname 例子：typedef int newint; ​ newint a; 枚举类型 派生数据类型，它是由用户定义的若干枚举常量的集合。 如果一个变量只有几种可能的值，可以定义为枚举(enumeration)类型。所谓”枚举”是指将变量的值一一列举出来，变量的值只能在列举出来的值的范围内。 语法： 123456enum 枚举名&#123; 标识符[=整型常数]， 标识符[=整型常数]， ... 标识符[=整型常数]&#125; 枚举变量; 实例： 12345678#定义一个颜色枚举变量cenum color &#123; red, orange, white&#125; c;#赋值 redc = red; 说明： 如果枚举不初始化（=整型常数），默认从第一个开始，第一个名称为0，第二个为1，…依次类推。 默认，后一个名称总比前面一个大1，但给某个名称手动赋值后，其后名称值会顺延,前面按默认值。 例子： 12#red = 0 bule=6enum color &#123; red, green=5, bule&#125;; 变量类型 变量声明 变量声明向编译器保证变量以给定的类型和名称存在，这样编译器在不需要知道变量完整细节的情况下也能继续进一步的编译。 变量声明只在编译时有它的意义，在程序连接时编译器需要实际的变量声明。 当您使用多个文件且只在其中一个文件中定义变量时（定义变量的文件在程序连接时是可用的），变量声明就显得非常有用。您可以使用 extern 关键字在任何地方声明一个变量。 可以在 C++ 程序中多次声明一个变量，但变量只能在某个文件、函数或代码块中被定义一次。 同样的，在函数声明时，提供一个函数名，而函数的实际定义则可以在任何地方进行。 变量定义 告诉编译器在何处创建变量的存储，以及如何创建变量的存储。 变量初始化 指定一个初始值。 不带初始化的定义：带有静态存储持续时间的变量会被隐式初始化为 NULL（所有字节的值都是 0），其他所有变量的初始值是未定义的。 变量作用域 作用域是程序的一个区域，一般来说有三个地方可以定义变量： 在函数或一个代码块内部声明的变量，称为局部变量。 在函数或一个代码块内部声明的变量，称为局部变量。它们只能被函数内部或者代码块内部的语句使用 在函数参数的定义中声明的变量，称为形式参数。 在所有函数外部声明的变量，称为全局变量。 全局变量的值在程序的整个生命周期内都是有效的。全局变量可以被任何函数访问。也就是说，全局变量一旦声明，在整个程序中都是可用的。 在程序中，局部变量和全局变量的名称可以相同，但是在函数内，局部变量的值会覆盖全局变量的值。 初始化 当局部变量被定义时，系统不会对其初始化，您必须自行对其初始化。 定义全局变量时，系统会自动初始化为下列值： 数据类型 初始化默认值 int 0 char ‘\\0’ float 0 double 0 pointer NULL 常量 定义 在 C++ 中，有两种简单的定义常量的方式： 使用 #define 预处理器。 格式：#define identifier value 例子：#define LENGTH 10(把常量定义为大写字母形式，是一个很好的编程实践。) 使用 const 关键字。 修饰符类型 C++ 允许在 char、int 和 double 数据类型前放置修饰符。 修饰符用于改变基本类型的含义，所以它更能满足各种情境的需求。 下面列出了数据类型修饰符： signed （可修饰整型、字符型，也可修饰long\\short） unsigned（可修饰整型、字符型，也可修饰long\\short） long（可修饰双精度型） short（可修饰整型） 允许使用速记符号来声明无符号短整数或无符号长整数。您可以不写 int，只写单词 unsigned、short 或 long，int 是隐含的。 ​ 例子： 12unsigned x;unsigned int y; 类型限定符 限定符 含义 const const 类型的对象在程序执行期间不能被修改改变。 volatile 修饰符 volatile 告诉编译器不需要优化volatile声明的变量，让程序可以直接从内存中读取变量。对于一般的变量编译器会对变量进行优化，将内存中的变量值放在寄存器中以加快读写效率。 restrict 由 restrict 修饰的指针是唯一一种访问它所指向的对象的方式。只有 C99 增加了新的类型限定符 restrict。 存储类 存储类定义 C++ 程序中变量/函数的范围（可见性）和生命周期。这些说明符放置在它们所修饰的类型之前。下面列出 C++ 程序中可用的存储类： auto 自 C++ 11 以来，auto 关键字用于两种情况：声明变量时根据初始化表达式自动推断该变量的类型、声明函数时函数返回值的占位符。 例子： 1234auto f=3.14; //doubleauto s(&quot;hello&quot;); //const char*auto z = new auto(9); // int*auto x1 = 5, x2 = 5.0, x3=&#x27;r&#x27;;//错误，必须是初始化为同一类型 register register 存储类用于定义存储在寄存器中而不是 RAM 中的局部变量。这意味着变量的最大尺寸等于寄存器的大小（通常是一个词），且不能对它应用一元的 ‘&amp;’ 运算符（因为它没有内存位置）。 123&#123; register int miles;&#125; 寄存器只用于需要快速访问的变量，比如计数器。还应注意的是，定义 ‘register’ 并不意味着变量将被存储在寄存器中，它意味着变量可能存储在寄存器中，这取决于硬件和实现的限制。 static static 存储类指示编译器在程序的生命周期内保持局部变量的存在，而不需要在每次它进入和离开作用域时进行创建和销毁。因此，使用 static 修饰局部变量可以在函数调用之间保持局部变量的值。 static 修饰符也可以应用于全局变量。当 static 修饰全局变量时，会使变量的作用域限制在声明它的文件内。 在 C++ 中，当 static 用在类数据成员上时，会导致仅有一个该成员的副本被类的所有对象共享。 extern extern 存储类用于提供一个全局变量的引用，全局变量对所有的程序文件都是可见的。当您使用 ‘extern’ 时，对于无法初始化的变量，会把变量名指向一个之前定义过的存储位置。 当您有多个文件且定义了一个可以在其他文件中使用的全局变量或函数时，可以在其他文件中使用 extern 来得到已定义的变量或函数的引用。可以这么理解，extern 是用来在另一个文件中声明一个全局变量或函数。 extern 修饰符通常用于当有两个或多个文件共享相同的全局变量或函数的时候 mutable mutable 说明符仅适用于类的对象。 它允许对象的成员替代常量。也就是说，mutable 成员可以通过 const 成员函数修改。 thread_local (C++11) 使用 thread_local 说明符声明的变量仅可在它在其上创建的线程上访问。 变量在创建线程时创建，并在销毁线程时销毁。 每个线程都有其自己的变量副本。 thread_local 说明符可以与 static 或 extern 合并。 可以将 thread_local 仅应用于数据声明和定义，thread_local 不能用于函数声明或定义。 以下演示了可以被声明为 thread_local 的变量： 1234567891011thread_local int x; // 命名空间下的全局变量class X&#123; static thread_local std::string s; // 类的static成员变量&#125;;static thread_local std::string X::s; // X::s 是需要定义的 void foo()&#123; thread_local std::vector&lt;int&gt; v; // 本地变量&#125; 从 C++ 17 开始，auto 关键字不再是 C++ 存储类说明符，且 register 关键字被弃用。 运算符 运算符是一种告诉编译器执行特定的数学或逻辑操作的符号。C++ 内置了丰富的运算符，并提供了以下类型的运算符： 算术运算符 运算符 描述 实例 + 把两个操作数相加 A + B 将得到 30 - 从第一个操作数中减去第二个操作数 A - B 将得到 -10 * 把两个操作数相乘 A * B 将得到 200 / 分子除以分母 B / A 将得到 2 % 取模运算符，整除后的余数 B % A 将得到 0 ++ 自增运算符，整数值增加 1 A++ 将得到 11 – 自减运算符，整数值减少 1 A– 将得到 9 关系运算符 运算符 描述 实例 == 检查两个操作数的值是否相等，如果相等则条件为真。 (A == B) 不为真。 != 检查两个操作数的值是否相等，如果不相等则条件为真。 (A != B) 为真。 &gt; 检查左操作数的值是否大于右操作数的值，如果是则条件为真。 (A &gt; B) 不为真。 &lt; 检查左操作数的值是否小于右操作数的值，如果是则条件为真。 (A &lt; B) 为真。 &gt;= 检查左操作数的值是否大于或等于右操作数的值，如果是则条件为真。 (A &gt;= B) 不为真。 &lt;= 检查左操作数的值是否小于或等于右操作数的值，如果是则条件为真。 (A &lt;= B) 为真。 逻辑运算符 运算符 描述 实例 &amp;&amp; 称为逻辑与运算符。如果两个操作数都 true，则条件为 true。 (A &amp;&amp; B) 为 false。 || 称为逻辑或运算符。如果两个操作数中有任意一个 true，则条件为 true。 (A || B) 为 true。 ! 称为逻辑非运算符。用来逆转操作数的逻辑状态，如果条件为 true 则逻辑非运算符将使其为 false。 !(A &amp;&amp; B) 为 true。 位运算符 p q p &amp; q p | q p ^ q 0 0 0 0 0 0 1 0 1 1 1 1 1 1 0 1 0 0 1 1 ~、&lt;&lt;、&gt;&gt;运算，其中 ~ 取反运算符，按二进制位进行”取反”运算。运算规则：~1=-2; ~0=-1; (~A ) 将得到 -61，即为 1100 0011，一个有符号二进制数的补码形式。（此处有错） 赋值运算符 运算符 描述 实例 = 简单的赋值运算符，把右边操作数的值赋给左边操作数 C = A + B 将把 A + B 的值赋给 C += 加且赋值运算符，把右边操作数加上左边操作数的结果赋值给左边操作数 C += A 相当于 C = C + A -= 减且赋值运算符，把左边操作数减去右边操作数的结果赋值给左边操作数 C -= A 相当于 C = C - A *= 乘且赋值运算符，把右边操作数乘以左边操作数的结果赋值给左边操作数 C *= A 相当于 C = C * A /= 除且赋值运算符，把左边操作数除以右边操作数的结果赋值给左边操作数 C /= A 相当于 C = C / A %= 求模且赋值运算符，求两个操作数的模赋值给左边操作数 C %= A 相当于 C = C % A &lt;&lt;= 左移且赋值运算符 C &lt;&lt;= 2 等同于 C = C &lt;&lt; 2 &gt;&gt;= 右移且赋值运算符 C &gt;&gt;= 2 等同于 C = C &gt;&gt; 2 &amp;= 按位与且赋值运算符 C &amp;= 2 等同于 C = C &amp; 2 ^= 按位异或且赋值运算符 C ^= 2 等同于 C = C ^ 2 |= 杂项运算符 运算符 描述 sizeof sizeof 运算符返回变量的大小。例如，sizeof(a) 将返回 4，其中 a 是整数。 Condition ? X : Y 条件运算符。如果 Condition 为真 ? 则值为 X : 否则值为 Y。 , 逗号运算符会顺序执行一系列运算。整个逗号表达式的值是以逗号分隔的列表中的最后一个表达式的值。 .（点）和 -&gt;（箭头） 成员运算符用于引用类、结构和共用体的成员。 Cast 强制转换运算符把一种数据类型转换为另一种数据类型。例如，int(2.2000) 将返回 2。 &amp; 指针运算符 &amp; 返回变量的地址。例如 &a; 将给出变量的实际地址。 * 指针运算符 * 指向一个变量。例如，*var; 将指向变量 var。 优先级 类别 运算符 结合性 后缀 () [] -&gt; . ++ - - 从左到右 一元 + - ! ~ ++ - - (type)* &amp; sizeof 从右到左 乘除 * / % 从左到右 加减 + - 从左到右 移位 &lt;&lt; &gt;&gt; 从左到右 关系 &lt; &lt;= &gt; &gt;= 从左到右 相等 == != 从左到右 位与 AND &amp; 从左到右 位异或 XOR ^ 从左到右 位或 OR | 从左到右 逻辑与 AND &amp;&amp; 从左到右 逻辑或 OR || 从左到右 条件 ?: 从右到左 赋值 = += -= *= /= %=&gt;&gt;= &lt;&lt;= &amp;= ^= |= 从右到左 逗号 , 从左到右 循环 循环类型 描述 while 循环 当给定条件为真时，重复语句或语句组。它会在执行循环主体之前测试条件。 for 循环 多次执行一个语句序列，简化管理循环变量的代码。 do…while 循环 除了它是在循环主体结尾测试条件外，其他与 while 语句类似。 嵌套循环 您可以在 while、for 或 do..while 循环内使用一个或多个循环。 控制语句 描述 break 语句 终止 loop 或 switch 语句，程序流将继续执行紧接着 loop 或 switch 的下一条语句。 continue 语句 引起循环跳过主体的剩余部分，立即重新开始测试条件。 goto 语句 将控制转移到被标记的语句。但是不建议在程序中使用 goto 语句。 判断 语句 描述 if 语句 一个 if 语句 由一个布尔表达式后跟一个或多个语句组成。 if…else 语句 一个 if 语句 后可跟一个可选的 else 语句，else 语句在布尔表达式为假时执行。 嵌套 if 语句 您可以在一个 if 或 else if 语句内使用另一个 if 或 else if 语句。 switch 语句 一个 switch 语句允许测试一个变量等于多个值时的情况。 嵌套 switch 语句 您可以在一个 switch 语句内使用另一个 switch 语句。 ？：运算符 格式：Exp1 ? Exp2 : Exp3; 函数 当调用函数时，有三种向函数传递参数的方式： 调用类型 描述 传值调用 该方法把参数的实际值赋值给函数的形式参数。在这种情况下，修改函数内的形式参数对实际参数没有影响。 指针调用 该方法把参数的地址赋值给形式参数。在函数内，该地址用于访问调用中要用到的实际参数。这意味着，修改形式参数会影响实际参数。 引用调用 该方法把参数的引用赋值给形式参数。在函数内，该引用用于访问调用中要用到的实际参数。这意味着，修改形式参数会影响实际参数。 参数默认值 定义一个函数，可以为参数列表中后边的每一个参数指定默认值。当调用函数时，如果实际参数的值留空，则使用这个默认值。如果指定了值，则会忽略默认值，使用传递的值。 例子： 12345int sum(int a, int b=20) &#123; int result; result = a + b; return (result); &#125;result = sum(a, b);//a+b，a,b均使用传递值cout &lt;&lt; &quot;Total value is :&quot; &lt;&lt; result &lt;&lt; endl;result = sum(a);//a+20cout &lt;&lt; &quot;Total value is :&quot; &lt;&lt; result &lt;&lt; endl; lambda函数表达式 C++11 提供了对匿名函数的支持,称为 Lambda 函数(也叫 Lambda 表达式)。 Lambda 表达式把函数看作对象。Lambda 表达式可以像对象一样使用，比如可以将它们赋给变量和作为参数传递，还可以像函数一样对其求值。 Lambda 表达式本质上与函数声明非常类似。 Lambda 表达式具体形式如下: 12[capture](parameters)-&gt;return-type&#123;body&#125;[capture](parameters)&#123;body&#125;//无返回值，则 例子： 123[](int x, int y)&#123; return x &lt; y ; &#125;//无返回值[]&#123; ++global_x; &#125; //无输入参数和返回值[](int x, int y) -&gt; int &#123; int z = x + y; return z + x; &#125;//既有输入又有返回值 在Lambda表达式内可以访问当前作用域的变量，这是Lambda表达式的闭包（Closure）行为。 与JavaScript闭包不同，C++变量传递有传值和传引用的区别。可以通过前面的[]来指定： 123456[] // 沒有定义任何变量。使用未定义变量会引发错误。[x, &amp;y] // x以传值方式传入（默认），y以引用方式传入。[&amp;] // 任何被使用到的外部变量都隐式地以引用方式加以引用。[=] // 任何被使用到的外部变量都隐式地以传值方式加以引用。[&amp;, x] // x显式地以传值方式加以引用。其余变量以引用方式加以引用。[=, &amp;z] // z显式地以引用方式加以引用。其余变量以传值方式加以引用。 外有一点需要注意。对于[=]或[&amp;]的形式，lambda 表达式可以直接使用 this 指针。但是，对于[]的形式，如果要使用 this 指针，必须显式传入： 1[this]() &#123; this-&gt;someFunc(); &#125;(); 数字 内置数学运算函数，#include 随机数 关于随机数生成器，有两个相关的函数。 一个是 **rand()**，该函数只返回一个伪随机数。 生成随机数之前必须先调用 srand() 函数。#设置种子 1234567891011121314151617181920212223#include &lt;iostream&gt;#include &lt;ctime&gt;#include &lt;cstdlib&gt; using namespace std; int main ()&#123; int i,j; // 设置种子 srand( (unsigned)time( NULL ) ); /* 生成 10 个随机数 */ for( i = 0; i &lt; 10; i++ ) &#123; // 生成实际的随机数 j= rand(); cout &lt;&lt;&quot;随机数： &quot; &lt;&lt; j &lt;&lt; endl; &#125; return 0;&#125; 数组 声明 12type arrayName [ arraySize ];例1：int arr[10]; 初始化 123double balance[5] = &#123;1000.0, 2.0, 3.4, 7.0, 50.0&#125;;//大括号 &#123; &#125; 之间的值的数目不能大于我们在数组声明时在方括号 [ ] 中指定的元素数目。double balance[] = &#123;1000.0, 2.0, 3.4, 7.0, 50.0&#125;;//省略掉了数组的大小，数组的大小则为初始化时元素的个数。balance[4] = 50.0;//单独赋值 访问数组元素 1double salary = balance[9]; 数组详解 概念 描述 多维数组 C++ 支持多维数组。多维数组最简单的形式是二维数组。 指向数组的指针 您可以通过指定不带索引的数组名称来生成一个指向数组中第一个元素的指针。 传递数组给函数 您可以通过指定不带索引的数组名称来给函数传递一个指向数组的指针。 从函数返回数组 C++ 允许从函数返回数组。 字符串 C++ 提供了以下两种类型的字符串表示形式： C 风格字符串 字符串实际上是使用 null 字符 \\0 终止的一维字符数组。因此，一个以 null 结尾的字符串，包含了组成字符串的字符。 1char site[7] = &#123;&#x27;R&#x27;, &#x27;U&#x27;, &#x27;N&#x27;, &#x27;O&#x27;, &#x27;O&#x27;, &#x27;B&#x27;, &#x27;\\0&#x27;&#125;; C++ 中有大量的函数用来操作以 null 结尾的字符串: 序号 函数 &amp; 目的 1 strcpy(s1, s2); 复制字符串 s2 到字符串 s1。 2 strcat(s1, s2); 连接字符串 s2 到字符串 s1 的末尾。连接字符串也可以用 + 号，例如: string str1 = &quot;runoob&quot;; string str2 = &quot;google&quot;; string str = str1 + str2; 3 strlen(s1); 返回字符串 s1 的长度。#字符的数量，不包含后面的’\\0’，而sizeof()是返回字节数 4 strcmp(s1, s2); 如果 s1 和 s2 是相同的，则返回 0；如果 s1&lt;s2 则返回值小于 0；如果 s1&gt;s2 则返回值大于 0。 5 strchr(s1, ch); 返回一个指针，指向字符串 s1 中字符 ch 的第一次出现的位置。 6 strstr(s1, s2); 返回一个指针，指向字符串 s1 中字符串 s2 的第一次出现的位置。 C++ 引入的 string 类类型 C++ 标准库提供了 string 类类型 #include 123456789101112// 复制 str1 到 str3str3 = str1;cout &lt;&lt; &quot;str3 : &quot; &lt;&lt; str3 &lt;&lt; endl; // 连接 str1 和 str2str3 = str1 + str2;cout &lt;&lt; &quot;str1 + str2 : &quot; &lt;&lt; str3 &lt;&lt; endl; // 连接后，str3 的总长度len = str3.size();cout &lt;&lt; &quot;str3.size() : &quot; &lt;&lt; len &lt;&lt; endl; 指针 概念 描述 C++ Null 指针 C++ 支持空指针。NULL 指针是一个定义在标准库中的值为零的常量。 C++ 指针的算术运算 可以对指针进行四种算术运算：++、–、+、- C++ 指针 vs 数组 指针和数组之间有着密切的关系。 C++ 指针数组 可以定义用来存储指针的数组。 C++ 指向指针的指针 C++ 允许指向指针的指针。 C++ 传递指针给函数 通过引用或地址传递参数，使传递的参数在调用函数中被改变。 C++ 从函数返回指针 C++ 允许函数返回指针到局部变量、静态变量和动态内存分配。 引用 引用变量是一个别名，也就是说，它是某个已存在变量的另一个名字。一旦把引用初始化为某个变量，就可以使用该引用名称或变量名称来指向变量。 引用很容易与指针混淆，它们之间有三个主要的不同： 不存在空引用。引用必须连接到一块合法的内存。 一旦引用被初始化为一个对象，就不能被指向到另一个对象。指针可以在任何时候指向到另一个对象。 引用必须在创建时被初始化。指针可以在任何时间被初始化。 创建： 123int i = 17;//为i 声明引用变量rint&amp; r = i;//r是一个初始化为i 的整型引用 引用通常用于函数参数列表和函数返回值。 必须清楚的两个与 C++ 引用相关的重要概念： 概念 描述 把引用作为参数 C++ 支持把引用作为参数传给函数，这比传一般的参数更安全。 把引用作为返回值 可以从 C++ 函数中返回引用，就像返回其他数据类型一样。 日期时间 C++ 标准库没有提供所谓的日期类型。 C++ 继承了 C 语言用于日期和时间操作的结构和函数。 为了使用日期和时间相关的函数和结构，需要在 C++ 程序中引用 头文件。 基本输入输出 C++ 的 I/O 发生在流中，流是字节序列。如果字节流是从设备（如键盘、磁盘驱动器、网络连接等）流向内存，这叫做输入操作。如果字节流是从内存流向设备（如显示屏、打印机、磁盘驱动器、网络连接等），这叫做输出操作。 IO库头文件 头文件 函数和描述 该文件定义了 cin、cout、cerr 和 clog 对象，分别对应于标准输入流、标准输出流、非缓冲标准错误流和缓冲标准错误流。 该文件通过所谓的参数化的流操纵器（比如 setw 和 setprecision），来声明对执行标准化 I/O 有用的服务。 该文件为用户控制的文件处理声明服务。我们将在文件和流的相关章节讨论它的细节。 标准输出流-cout 预定义的对象 cout 是 iostream 类的一个实例。cout 对象”连接”到标准输出设备，通常是显示屏。cout 是与流插入运算符 &lt;&lt; 结合使用的 例子： 12345678910#include &lt;iostream&gt; using namespace std; int main( )&#123; char str[] = &quot;Hello C++&quot;; cout &lt;&lt; &quot;Value of str is : &quot; &lt;&lt; str &lt;&lt; endl;&#125; 标准输入流-cin 预定义的对象 cin 是 iostream 类的一个实例。cin 对象附属到标准输入设备，通常是键盘。cin 是与流提取运算符 &gt;&gt; 结合使用的. 例： 12345678910111213#include &lt;iostream&gt; using namespace std; int main( )&#123; char name[50]; cout &lt;&lt; &quot;请输入您的名称： &quot;; cin &gt;&gt; name; cout &lt;&lt; &quot;您的名称是： &quot; &lt;&lt; name &lt;&lt; endl; &#125; C++ 编译器根据要输入值的数据类型，选择合适的流提取运算符来提取值，并把它存储在给定的变量中。 流提取运算符 &gt;&gt; 在一个语句中可以多次使用，如果要求输入多个数据，可以使用如下语句： 1cin &gt;&gt; name &gt;&gt; age;//相当与cin &gt;&gt; name;cin &gt;&gt; age; 标准错误流 预定义的对象 cerr 是 iostream 类的一个实例。cerr 对象附属到标准输出设备，通常也是显示屏，但是 cerr 对象是非缓冲的，且每个流插入到 cerr 都会立即输出。 cerr 也是与流插入运算符 &lt;&lt; 结合使用的 1234567#include &lt;iostream&gt;using namespace std;int main( )&#123; char str[] = &quot;Unable to read....&quot;; cerr &lt;&lt; &quot;Error message : &quot; &lt;&lt; str &lt;&lt; endl;&#125; 标准日志流 预定义的对象 clog 是 iostream 类的一个实例。clog 对象附属到标准输出设备，通常也是显示屏，但是 clog 对象是缓冲的。这意味着每个流插入到 clog 都会先存储在缓冲区，直到缓冲填满或者缓冲区刷新时才会输出。 clog 也是与流插入运算符 &lt;&lt; 结合使用的 例： 1234567#include &lt;iostream&gt; using namespace std;int main( )&#123; char str[] = &quot;Unable to read....&quot;; clog &lt;&lt; &quot;Error message : &quot; &lt;&lt; str &lt;&lt; endl;&#125; 数据结构 面向对象 类&amp;对象 类定义 定义一个类，本质上是定义一个数据类型的蓝图。这实际上并没有定义任何数据，但它定义了类的名称意味着什么，也就是说，它定义了类的对象包括了什么，以及可以在这个对象上执行哪些操作。 例： 1234567class Box&#123; public: double length; // 盒子的长度 double breadth; // 盒子的宽度 double height; // 盒子的高度&#125;; 对象定义 类提供了对象蓝图。 继承 重载运算符和重载函数 多态 数据抽象 数据封装 接口（抽象类）","categories":[{"name":"编程语言","slug":"编程语言","permalink":"https://hxlpub.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"c++","slug":"c","permalink":"https://hxlpub.github.io/tags/c/"}]},{"title":"hexo搭建博客","slug":"hexo_build_blog","date":"2021-09-15T13:08:37.000Z","updated":"2022-05-14T02:23:59.547Z","comments":true,"path":"2021/09/15/hexo_build_blog/","link":"","permalink":"https://hxlpub.github.io/2021/09/15/hexo_build_blog/","excerpt":"","text":"2021-10-21–评论系统上线啦！！！ 1.点击页面小爱心 2.google 搜索支持 问题1：站点地图一直无法获取 https://orchidflower.oschina.io/2017/02/14/submit-to-search-engine/ 问题2：站点地图可读取，但存在错误,比对但是又没发现什么不对 1234567缺少必要的标记。请添加后重新提交。示例第 9行父标记：url标记：loc.../sitemap 站点地图 2022年5月14日 2022年5月13日 50 项错误 0 但从上面的状态来看是最近的读取时13号，14号提交后并没有读取最新的，猜测：第二天再看一下结果，应该就没问题了。","categories":[{"name":"Hexo","slug":"Hexo","permalink":"https://hxlpub.github.io/categories/Hexo/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://hxlpub.github.io/tags/Hexo/"}]},{"title":"golang tcp协议实现","slug":"go_tcp","date":"2021-09-15T07:42:30.000Z","updated":"2022-05-14T09:37:55.375Z","comments":true,"path":"2021/09/15/go_tcp/","link":"","permalink":"https://hxlpub.github.io/2021/09/15/go_tcp/","excerpt":"","text":"1、client端client.go123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475//tcpclient 为client.go所在的上一层目录package tcpclientimport ( &quot;net&quot; &quot;fmt&quot; //&quot;io/ioutil&quot; &quot;strconv&quot; //&quot;../log&quot; //&quot;strings&quot; //&quot;bytes&quot; //&quot;encoding/xml&quot;)//组装tcp请求func RequestMsg(serialNum string, randomNum string, toAddr string, fromAddr string) string &#123; body := &quot;&lt;?xml version=\\&quot;1.0\\&quot;?&gt;\\r\\n&quot; + &quot;&lt;Config&gt;\\r\\n&quot; + &quot;&lt;CmdType&gt;ACTIVE&lt;/CmdType&gt;\\r\\n&quot; + &quot;&lt;CmdInfo&gt;GetActiveInfo&lt;/CmdInfo&gt;\\r\\n&quot; + &quot;&lt;SerialNumInfo&gt;\\r\\n&quot; + &quot;&lt;SerialNum&gt;&quot; + serialNum + &quot;&lt;/SerialNum&gt;\\r\\n&quot; + &quot;&lt;/SerialNumInfo&gt;\\r\\n&quot; + &quot;&lt;/Config&gt;&quot; head := &quot;HIK-PRODUCT\\r\\n&quot; + &quot;Via:HIKSTOR/1.0/TCP\\r\\n&quot; + &quot;From:&quot; + fromAddr + &quot;\\r\\n&quot; + &quot;To:&quot; + toAddr + &quot;\\r\\n&quot; + &quot;Call-ID:&quot; + randomNum + &quot;\\r\\n&quot; + &quot;Content-Type:xml\\r\\n&quot; + &quot;Content-Length:&quot; + strconv.Itoa(len(body)) + &quot;\\r\\n\\r\\n&quot; return head + body //return body&#125;//向server端发起请求func GetBomInfoFromThirdServ(serialNum string,randomNum string, toAddr string, fromAddr string) (string,error) &#123; //主动发起连接请求 conn,err :=net.Dial(&quot;tcp&quot;,&quot;10.192.44.183:35004&quot;) if err != nil &#123; fmt.Println(&quot;dial err&quot;,err) return &quot;&quot;, err &#125; defer conn.Close() //向服务端发送请求 reqmsg := RequestMsg(serialNum,randomNum,toAddr,fromAddr) _, err = conn.Write([]byte(reqmsg)) if err != nil &#123; fmt.Println(&quot;send err=&quot;, err) //出错退出 return &quot;&quot;,err &#125; //接收响应 buf := make([]byte, 1024) //response, err :=ioutil.ReadAll(conn) //if err != nil &#123; // fmt.Println(&quot;rec err&quot;,err) // return &quot;&quot;, err //&#125; n, err :=conn.Read(buf) //fmt.Println(&quot;n=&quot;, n) if err != nil &#123; fmt.Println(&quot;服务器read err=&quot;, err) //出错退出 return &quot;&quot;,err &#125; return string(buf[:n-1]),nil //return buf,nil &#125; 2、server端server.go","categories":[{"name":"golang","slug":"golang","permalink":"https://hxlpub.github.io/categories/golang/"}],"tags":[{"name":"golang","slug":"golang","permalink":"https://hxlpub.github.io/tags/golang/"}]},{"title":"【数据结构与算法】排序","slug":"algorithm","date":"2021-09-14T09:26:07.000Z","updated":"2023-05-28T10:03:47.091Z","comments":true,"path":"2021/09/14/algorithm/","link":"","permalink":"https://hxlpub.github.io/2021/09/14/algorithm/","excerpt":"","text":"1.二分排序 K&amp;R P99","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://hxlpub.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"排序","slug":"排序","permalink":"https://hxlpub.github.io/tags/%E6%8E%92%E5%BA%8F/"}]},{"title":"构建python知识体系-basics","slug":"Python","date":"2021-09-14T09:26:07.000Z","updated":"2022-08-26T08:51:05.795Z","comments":true,"path":"2021/09/14/Python/","link":"","permalink":"https://hxlpub.github.io/2021/09/14/Python/","excerpt":"","text":"环境配置import 时找不到模块，修改python sys.path import syssys.path.append(‘/home/daos/site_scons’) 基础语法 编码 默认情况下，Python 3 源码文件以 UTF-8 编码，所有字符串都是 unicode 字符串。 当然你也可以为源码文件指定不同的编码： 1# -*- coding: cp-1252 -*- 标识符 第一个字符必须是字母表中字母或下划线 _ 。 标识符的其他的部分由字母、数字和下划线组成。 标识符对大小写敏感。 在 Python 3 中，可以用中文作为变量名，非 ASCII 标识符也是允许的了。 保留字(关键字) 保留字即关键字，我们不能把它们用作任何标识符名称。Python 的标准库提供了一个 keyword 模块，可以输出当前版本的所有关键字： 12345&gt;&gt;&gt; import keyword&gt;&gt;&gt; keyword.kwlist[&#x27;False&#x27;, &#x27;None&#x27;, &#x27;True&#x27;, &#x27;__peg_parser__&#x27;, &#x27;and&#x27;, &#x27;as&#x27;, &#x27;assert&#x27;, &#x27;async&#x27;, &#x27;await&#x27;, &#x27;break&#x27;, &#x27;class&#x27;, &#x27;continue&#x27;, &#x27;def&#x27;, &#x27;del&#x27;, &#x27;elif&#x27;, &#x27;else&#x27;, &#x27;except&#x27;, &#x27;finally&#x27;, &#x27;for&#x27;, &#x27;from&#x27;, &#x27;global&#x27;, &#x27;if&#x27;, &#x27;import&#x27;, &#x27;in&#x27;, &#x27;is&#x27;, &#x27;lambda&#x27;, &#x27;nonlocal&#x27;, &#x27;not&#x27;, &#x27;or&#x27;, &#x27;pass&#x27;, &#x27;raise&#x27;, &#x27;return&#x27;, &#x27;try&#x27;, &#x27;while&#x27;, &#x27;with&#x27;, &#x27;yield&#x27;]&gt;&gt;&gt; 注释 12345678910111213 ```# 单行注释 # print (&quot;Hello, Python!&quot;) # 第二个注释、 # 多行注释 &#x27;&#x27;&#x27;&#x27;注释内容&#x27;&#x27;&#x27; 和&quot;&quot;&quot;注释内容&quot;&quot;&quot; &#x27;&#x27;&#x27; 第三注释 第四注释 &#x27;&#x27;&#x27; &quot;&quot;&quot; 第五注释 第六注释 &quot;&quot;&quot; 行与缩进 python最具特色的就是使用缩进来表示代码块，不需要使用大括号 {} 。 缩进的空格数是可变的，但是同一个代码块的语句必须包含相同的缩进空格数。 123456789101112131415 ```if True: print (&quot;Answer&quot;) print (&quot;True&quot;) else: print (&quot;Answer&quot;) print (&quot;False&quot;) # 缩进不一致，会导致运行错误 root@192 python]# python test.py File &quot;/home/tests/python/test.py&quot;, line 14 print (&quot;False&quot;) ^ IndentationError: unindent does not match any outer indentation level 多行语句 Python 通常是一行写完一条语句，但如果语句很长，我们可以使用反斜杠 ** 来实现多行语句，例如： 12345 ```total = item_one + \\ item_two + \\ item_three 在 [], {}, 或 () 中的多行语句，不需要使用反斜杠 ****，例如： 12total = [&#x27;item_one&#x27;, &#x27;item_two&#x27;, &#x27;item_three&#x27;, &#x27;item_four&#x27;, &#x27;item_five&#x27;] 数字类型 int (整数), 如 1, 只有一种整数类型 int，表示为长整型，没有 python2 中的 Long。 bool (布尔), 如 True。 float (浮点数), 如 1.23、3E-2 complex (复数), 如 1 + 2j、 1.1 + 2.2j 字符串 Python 中单引号 ‘ 和双引号 “ 使用完全相同。 使用三引号(‘’’ 或 “””)可以指定一个多行字符串。 转义符 ****。 反斜杠可以用来转义，使用 r 可以让反斜杠不发生转义。 如 r”this is a line with \\n” 则 \\n 会显示，并不是换行。 按字面意义级联字符串，如 “this “ “is “ “string” 会被自动转换为 this is string。 字符串可以用 + 运算符连接在一起，用 ***** 运算符重复。 Python 中的字符串有两种索引方式，从左往右以 0 开始，从右往左以 -1 开始。 Python 中的字符串不能改变。 Python 没有单独的字符类型，一个字符就是长度为 1 的字符串。 字符串的截取的语法格式如下：变量[头下标:尾下标:步长] 12345678910111213141516171819202122232425262728293031323334word = &#x27;字符串&#x27; sentence = &quot;这是一个句子。&quot; paragraph = &quot;&quot;&quot;这是一个段落， 可以由多行组成&quot;&quot;&quot; #!/usr/bin/python3 str=&#x27;123456789&#x27; print(str) # 输出字符串 print(str[0:-1]) # 输出第一个到倒数第二个的所有字符 print(str[0]) # 输出字符串第一个字符 print(str[2:5]) # 输出从第三个开始到第五个的字符 print(str[2:]) # 输出从第三个开始后的所有字符 print(str[1:5:2]) # 输出从第二个开始到第五个且每隔一个的字符（步长为2） print(str * 2) # 输出字符串两次 print(str + &#x27;你好&#x27;) # 连接字符串 print(&#x27;------------------------------&#x27;) print(&#x27;hello\\nrunoob&#x27;) # 使用反斜杠(\\)+n转义特殊字符 print(r&#x27;hello\\nrunoob&#x27;) # 在字符串前面添加一个 r，表示原始字符串，不会发生转义 123456789 12345678 1 345 3456789 24 123456789123456789 123456789你好 ------------------------------ hello runoob hello\\nrunoob 空行 函数之间或类的方法之间用空行分隔，表示一段新的代码的开始。类和函数入口之间也用一行空行分隔，以突出函数入口的开始。 空行与代码缩进不同，空行并不是 Python 语法的一部分。书写时不插入空行，Python 解释器运行也不会出错。但是空行的作用在于分隔两段不同功能或含义的代码，便于日后代码的维护或重构。 记住：空行也是程序代码的一部分。 等待用户输入 123456789101112131415161718192021 input(&quot;\\n\\n按下 enter 键后退出。&quot;) [root@192 python]# python test.py True​ ​ press enter to exit​ ​ ```​ - 同一行显示多条语句 在同一行中使用多条语句，语句之间使用分号 **;** 分割 ```python import sys; x = &#x27;runoob&#x27;; sys.stdout.write(x + &#x27;\\n&#x27;) 多个语句构成代码组 缩进相同的一组语句构成一个代码块，我们称之代码组。 像if、while、def和class这样的复合语句，首行以关键字开始，以冒号( : )结束，该行之后的一行或多行代码构成代码组。 我们将首行及后面的代码组称为一个子句(clause)。 1234567if expression : suite elif expression : suite else : suite print print 默认输出是换行的，如果要实现不换行需要在变量末尾加上 **end=””**： 12345678910111213141516171819#!/usr/bin/python3 x=&quot;a&quot; y=&quot;b&quot; # 换行输出 print( x ) print( y ) print(&#x27;---------&#x27;) # 不换行输出 print( x, end=&quot; &quot; ) print( y, end=&quot; &quot; ) print() a b --------- a b ​ import 与 from … import 在 python 用 import 或者 from…import 来导入相应的模块。 将整个模块(somemodule)导入，格式为： import somemodule 从某个模块中导入某个函数,格式为： from somemodule import somefunction 从某个模块中导入多个函数,格式为： from somemodule import firstfunc, secondfunc, thirdfunc 将某个模块中的全部函数导入，格式为： from somemodule import * 123456789101112#导入sys 模块 import sys print(&#x27;================Python import mode==========================&#x27;) print (&#x27;命令行参数为:&#x27;) for i in sys.argv: print (i) print (&#x27;\\n python 路径为&#x27;,sys.path) #导入sys模块的argv 和path成员 from sys import argv,path # 导入特定的成员 print(&#x27;================python from import===================================&#x27;) print(&#x27;path:&#x27;,path) # 因为已经导入path成员，所以此处引用时不需要加sys.path 命令行参数 稍后补充 基本数据类型 变量不需要声明。每个变量在使用前都必须赋值，变量赋值以后该变量才会被创建。 变量就是变量，它没有类型，我们所说的”类型”是变量所指的内存中对象的类型。 12345678#!/usr/bin/python3counter = 100 # 整型变量miles = 1000.0 # 浮点型变量name = &quot;runoob&quot; # 字符串print (counter)print (miles)print (name) 多变量赋值 12a = b = c = 1a, b, c = 1, 2, &quot;hello&quot; 标准数据类型 python3 中有6中标准数据类型： Number（数字） String（字符串） List（列表） Tuple（元组） Set（集合） Dictionary（字典） 不可变数据（3 个）：Number（数字）、String（字符串）、Tuple（元组）； 可变数据（3 个）：List（列表）、Dictionary（字典）、Set（集合）。 Number Python3 支持 int、float、bool、complex（复数）。 内置的 type() 函数可以用来查询变量所指的对象类型。 123&gt;&gt;&gt; a, b, c, d = 20, 5.5, True, 4+3j&gt;&gt;&gt; print(type(a), type(b), type(c), type(d))&lt;class &#x27;int&#x27;&gt; &lt;class &#x27;float&#x27;&gt; &lt;class &#x27;bool&#x27;&gt; &lt;class &#x27;complex&#x27;&gt; 还可以用 isinstance 来判断： 1234&gt;&gt;&gt; a = 111&gt;&gt;&gt; isinstance(a, int)True&gt;&gt;&gt; isinstance 和 type 的区别在于： type()不会认为子类是一种父类类型。 isinstance()会认为子类是一种父类类型。 123456789101112131415161718192021222324252627282930&gt;&gt;&gt; class A:... pass... &gt;&gt;&gt; class B(A):... pass... &gt;&gt;&gt; isinstance(A(), A)True&gt;&gt;&gt; type(A()) == A True&gt;&gt;&gt; isinstance(B(), A)True&gt;&gt;&gt; type(B()) == AFalse注意：Python3 中，bool 是 int 的子类，True 和 False 可以和数字相加， True==1、False==0 会返回 True，但可以通过 is 来判断类型。&gt;&gt;&gt; issubclass(bool, int) True&gt;&gt;&gt; True==1True&gt;&gt;&gt; False==0True&gt;&gt;&gt; True+12&gt;&gt;&gt; False+11&gt;&gt;&gt; 1 is TrueFalse&gt;&gt;&gt; 0 is FalseFalse 使用del语句删除单个或多个对象。例如： 12del vardel var_a, var_b 数值运算 1234567891011121314&gt;&gt;&gt; 5 + 4 # 加法9&gt;&gt;&gt; 4.3 - 2 # 减法2.3&gt;&gt;&gt; 3 * 7 # 乘法21&gt;&gt;&gt; 2 / 4 # 除法，得到一个浮点数0.5&gt;&gt;&gt; 2 // 4 # 除法，得到一个整数0&gt;&gt;&gt; 17 % 3 # 取余2&gt;&gt;&gt; 2 ** 5 # 乘方32 String 使用单引号’’或双引号””将字符串括起来，并使用\\转义特殊字符 反斜杠()可以作为续行符，表示下一行是上一行的延续。也可以使用 “””…””” 或者 ‘’’…’’’ 跨越多行 字符串的截取格式：变量[头下标:尾下标] 从前索引：索引值从0开始 从后索引：索引值从-1开始 +：字符串连接符 *数字：复制当前字符串，数字是复制的次数 实例 12345678910111213141516171819202122# -*- coding: utf-8 -*-#!/usr/bin/python3.6str = &#x27;string&#x27;print(str) print(str[0:-1]) #打印第一个到倒数第二个字符print(str[0]) print(str[2:5]) #第三个到第五个，注意与上面的[0:-1]有区别print(str*2) print(str+&#x27;TEST&#x27;)print(&#x27;stri\\ng&#x27;)print(r&#x27;stri\\ng&#x27;)[root@192 python]# python data_type.py stringstrinsrinstringstringstringTESTstrigstri\\ng List 使用最频繁的数据类型 列表中元素的类型可以不相同，它支持数字，字符串甚至可以包含列表（所谓嵌套）。 1、List写在方括号之间，元素用逗号隔开。 2、和字符串一样，list可以被索引和切片。 3、List可以使用+操作符进行拼接。 4、List中的元素是可以改变的。 123变量[头下标:尾下标] 也可以 变量[头下标:尾下标:步长]索引值以 0 为开始值，-1 为从末尾的开始位置。 实例1 1234567891011121314151617181920212223242526272829list = [&#x27;a&#x27;, 1, 2.3, 4.56]tinylist = [&#x27;123&#x27;, &#x27;tinylist&#x27;]print(list)print(list[0])print(list[1:3])print(list[2:])print(tinylist*2)print(list+tinylist)list[0] = 9print(list)list[1:3] = [8, 7]print(list)list[3:]=[]print(list)list.append(6)print(list)print(list[0:3:2])[root@192 python]# python data_type.py [&#x27;a&#x27;, 1, 2.3, 4.56]a[1, 2.3][2.3, 4.56][&#x27;123&#x27;, &#x27;tinylist&#x27;, &#x27;123&#x27;, &#x27;tinylist&#x27;][&#x27;a&#x27;, 1, 2.3, 4.56, &#x27;123&#x27;, &#x27;tinylist&#x27;][9, 1, 2.3, 4.56][9, 8, 7, 4.56][9, 8, 7][9, 8, 7, 6][9, 7] List 内置了很多方法，如append()、pop()等 实例2 字符翻转 123456789101112def reverserWords(input): inputWords = input.split(&#x27; &#x27;) inputWords = inputWords[-1::-1] output = &#x27; &#x27;.join(inputWords) return outputif __name__ == &quot;__main__&quot;: input = &#x27;I like you&#x27; rw = reverserWords(input) print(rw) 元组 1、与字符串一样，元组的元素不能修改。 虽然tuple的元素不可改变，但它可以包含可变的对象，比如list列表。 2、元组也可以被索引和切片，方法一样。 3、注意构造包含 0 或 1 个元素的元组的特殊语法规则。 12tup1 = () # 空元组tup2 = (20,) # 一个元素，需要在元素后添加逗号 4、元组也可以使用+操作符进行拼接。 5、 Set 集合 集合（set）是由一个或数个形态各异的大小整体组成的，构成集合的事物或对象称作元素或是成员。 基本功能是进行成员关系测试和删除重复元素。 创建格式：注意创建一个空集，必须用set() 而不能用{}（因为{}是用来创建一个空字典） 123parame = &#123;value1, value2, ...&#125;或者set(value) 实例 1234567891011121314151617181920212223242526#setsites = &#123;&#x27;google&#x27;, &#x27;baidu&#x27;, &#x27;ali&#x27;&#125;print(sites)if &#x27;ali&#x27; in sites: print(&#x27;ali in sites&#x27;)else: print(&#x27;ali not in sites &#x27;)#set 集合运算a=set(&#x27;abracadabra&#x27;)b=set(&#x27;alacazam&#x27;)print(a)print(a - b) #差集print(a | b) #并集print(a &amp; b) #交集print(a ^ b) #a和b中不同时存在的元素输出：set([&#x27;baidu&#x27;, &#x27;google&#x27;, &#x27;ali&#x27;])ali in sitesset([&#x27;a&#x27;, &#x27;r&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;])set([&#x27;r&#x27;, &#x27;b&#x27;, &#x27;d&#x27;])set([&#x27;a&#x27;, &#x27;c&#x27;, &#x27;b&#x27;, &#x27;d&#x27;, &#x27;m&#x27;, &#x27;l&#x27;, &#x27;r&#x27;, &#x27;z&#x27;])set([&#x27;a&#x27;, &#x27;c&#x27;])set([&#x27;b&#x27;, &#x27;d&#x27;, &#x27;m&#x27;, &#x27;l&#x27;, &#x27;r&#x27;, &#x27;z&#x27;]) Dictionary 1、非常有用的内置数据类型 2、字典是一种映射类型，它的元素是键值对。一个无序的 键(key) : 值(value) 的集合 3、字典的关键字必须为不可变类型，且不能重复。 4、创建空字典使用 { }。 5、在同一个字典中，键(key)必须是唯一的 6、构造函数 dict() 可以直接从键值对序列中构建字典 7、字典类型也有一些内置的函数，例如 clear()、keys()、values() 等。 实例1 12345678910111213141516dict = &#123;&#125;dict[&#x27;one&#x27;] = &#x27;you&#x27;dict[2] = &#x27;me&#x27;tinydict = &#123;&#x27;one&#x27;:&#x27;you&#x27;, &#x27;two&#x27;:&#x27;and&#x27;, &#x27;three&#x27;:&#x27;me&#x27;&#125;print(dict[&#x27;one&#x27;])print(dict[2])print(tinydict.keys())print(tinydict.values())输出：youme[&#x27;three&#x27;, &#x27;two&#x27;, &#x27;one&#x27;][&#x27;me&#x27;, &#x27;and&#x27;, &#x27;you&#x27;] 实例2 123456&gt;&gt;&gt; dict([(&#x27;Runoob&#x27;, 1), (&#x27;Google&#x27;, 2), (&#x27;Taobao&#x27;, 3)])&#123;&#x27;Runoob&#x27;: 1, &#x27;Google&#x27;: 2, &#x27;Taobao&#x27;: 3&#125;&gt;&gt;&gt; &#123;x: x**2 for x in (2, 4, 6)&#125;&#123;2: 4, 4: 16, 6: 36&#125;&gt;&gt;&gt; dict(Runoob=1, Google=2, Taobao=3)&#123;&#x27;Runoob&#x27;: 1, &#x27;Google&#x27;: 2, &#x27;Taobao&#x27;: 3&#125; 数据类型转换Python 数据类型转换可以分为两种： 隐式类型转换 - 自动完成 较低数据类型（整数）就会转换为较高数据类型（浮点数）以避免数据丢失。 显式类型转换 - 需要使用类型函数来转换 在显式类型转换中，用户将对象的数据类型转换为所需的数据类型。 我们使用 int()、float()、str() 等预定义函数来执行显式类型转换。 整型和字符串类型进行运算，就可以用强制类型转换来完成 常用的几个内置函数： 函数 描述 [int(x ,base]) 将x转换为一个整数 float(x) 将x转换到一个浮点数 [complex(real ,imag]) 创建一个复数 str(x) 将对象 x 转换为字符串 repr(x) 将对象 x 转换为表达式字符串 eval(str) 用来计算在字符串中的有效Python表达式,并返回一个对象 tuple(s) 将序列 s 转换为一个元组 list(s) 将序列 s 转换为一个列表 set(s) 转换为可变集合 dict(d) 创建一个字典。d 必须是一个 (key, value)元组序列。 frozenset(s) 转换为不可变集合 chr(x) 将一个整数转换为一个字符 ord(x) 将一个字符转换为它的整数值 hex(x) 将一个整数转换为一个十六进制字符串 oct(x) 推导式Python 推导式是一种独特的数据处理方式，可以从一个数据序列构建另一个新的数据序列的结构体。 Python 支持各种数据结构的推导式： 列表(list)推导式 字典(dict)推导式 集合(set)推导式 元组(tuple)推导式 列表推导式 ​ 推导式格式： 123456789[表达式 for 变量 in 列表] [out_exp_res for out_exp in input_list]或者 [表达式 for 变量 in 列表 if 条件][out_exp_res for out_exp in input_list if condition]说明out_exp_res：列表生成元素表达式，可以是有返回值的函数。for out_exp in input_list：迭代 input_list 将 out_exp 传入到 out_exp_res 表达式中。if condition：条件语句，可以过滤列表中不符合条件的值。 实例1：过滤掉长度小于或等于3的字符串列表，并将剩下的转换成大写字母： 1234&gt;&gt;&gt; names = [&#x27;Bob&#x27;,&#x27;Tom&#x27;,&#x27;alice&#x27;,&#x27;Jerry&#x27;,&#x27;Wendy&#x27;,&#x27;Smith&#x27;]&gt;&gt;&gt; new_names = [name.upper()for name in names if len(name)&gt;3]&gt;&gt;&gt; print(new_names)[&#x27;ALICE&#x27;, &#x27;JERRY&#x27;, &#x27;WENDY&#x27;, &#x27;SMITH&#x27;] 实例2：计算 30 以内可以被 3 整除的整数 12multiples = [i for i in range(30) if i % 3 == 0]print(multiples) 字典推导式 ​ 格式： 123&#123; key_expr: value_expr for value in collection &#125;或&#123; key_expr: value_expr for value in collection if condition &#125; 实例1：使用字符串及其长度创建字典 12345list =[&#x27;beijing&#x27;, &#x27;shanghai&#x27;, &#x27;guangzhou&#x27;,&#x27;shenzhen&#x27;]dic = &#123;key:len(key) for key in list&#125;print(dic)输出：&#123;&#x27;beijing&#x27;: 7, &#x27;shanghai&#x27;: 8, &#x27;guangzhou&#x27;: 9, &#x27;shenzhen&#x27;: 8&#125; 实例2：将三个整数及其平方值作为键值对创建字典 1234dic = &#123;i : i**2 for i in (1,2,3)&#125;print(dic)输出：&#123;1: 1, 2: 4, 3: 9&#125; 集合推导式 ​ 格式： 123&#123; expression for item in Sequence &#125;或&#123; expression for item in Sequence if conditional &#125; 实例1：计算1，2，3平方 1set = &#123;x**2 for x in (1,2,3)&#125; 实例2：判断不是abc的字母并输出 1a = &#123;x for x in &#x27;abclsm&#x27; if x not in &#x27;abc&#x27;&#125; 元组推导式 ​ 元组推导式可以利用 range 区间、元组、列表、字典和集合等数据类型，快速生成一个满足指定需求的元组。 ​ 元组推导式和列表推导式的用法也完全相同，只是元组推导式是用 () 圆括号将各部分括起来，而列表推导式用的是中括号 **[]**，另外元组推导式返回的结果是一个生成器对象。 ​ 格式： 123(expression for item in Sequence )或(expression for item in Sequence if conditional ) 实例1：生成一个包含数字 1~9 的元组： 123456&gt;&gt;&gt; a = (x for x in range(1,10))&gt;&gt;&gt; a&lt;generator object &lt;genexpr&gt; at 0x7faf6ee20a50&gt; # 返回的是生成器对象&gt;&gt;&gt; tuple(a) # 使用 tuple() 函数，可以直接将生成器对象转换成元组(1, 2, 3, 4, 5, 6, 7, 8, 9) 解释器python 的二进制文件 交互式编程 脚本式编程 注释确保对模块, 函数, 方法和行内注释使用正确的风格。 Python 中的注释有单行注释和多行注释。 Python 中单行注释以 # 开头，例如： # 这是一个注释 print(“Hello, World!”) 多行注释用三个单引号 ‘’’ 或者三个双引号 “”” 将注释括起来，例如: 单引号（’’’） #!/usr/bin/python3 ‘’’ 这是多行注释，用三个单引号 这是多行注释，用三个单引号 这是多行注释，用三个单引号 ‘’’ print(“Hello, World!”) 双引号（”””） #!/usr/bin/python3 “”” 这是多行注释，用三个双引号 这是多行注释，用三个双引号 这是多行注释，用三个双引号 “”” print(“Hello, World!”) 运算符Python 语言支持以下类型的运算符: 算术运算符 比较（关系）运算符 赋值运算符 逻辑运算符 位运算符 成员运算符 身份运算符 运算符优先级 以下表格列出了从最高到最低优先级的所有运算符： 运算符 描述 ** 指数 (最高优先级) ~ + - 按位翻转, 一元加号和减号 (最后两个的方法名为 +@ 和 -@) * / % // 乘，除，求余数和取整除 + - 加法减法 &gt;&gt; &lt;&lt; 右移，左移运算符 &amp; 位 ‘AND’ ^ | 位运算符 &lt;= &lt; &gt; &gt;= 比较运算符 == != 等于运算符 = %= /= //= -= += *= **= 赋值运算符 is is not 身份运算符 in not in 成员运算符 not and or 逻辑运算符 数字查看 字符串注：只记录新的东西，使用与 C 中 sprintf 函数一样的语法，不同的是后面的变量前面有个% 字符串格式化： 如 print (“我叫 %s 今年 %d 岁!” % (‘小明’, 10)) 新的格式化方式 str.format() 通过 {} 和 **.**来代替以前的 % 。 123456789101112131415161718192021222324252627&gt;&gt;&gt;&quot;&#123;&#125; &#123;&#125;&quot;.format(&quot;hello&quot;, &quot;world&quot;) # 不设置指定位置，按默认顺序&#x27;hello world&#x27; &gt;&gt;&gt; &quot;&#123;0&#125; &#123;1&#125;&quot;.format(&quot;hello&quot;, &quot;world&quot;) # 设置指定位置&#x27;hello world&#x27; &gt;&gt;&gt; &quot;&#123;1&#125; &#123;0&#125; &#123;1&#125;&quot;.format(&quot;hello&quot;, &quot;world&quot;) # 设置指定位置&#x27;world hello world&#x27;也可设置参数#!/usr/bin/python# -*- coding: UTF-8 -*- print(&quot;网站名：&#123;name&#125;, 地址 &#123;url&#125;&quot;.format(name=&quot;菜鸟教程&quot;, url=&quot;www.runoob.com&quot;)) # 通过字典设置参数site = &#123;&quot;name&quot;: &quot;菜鸟教程&quot;, &quot;url&quot;: &quot;www.runoob.com&quot;&#125;print(&quot;网站名：&#123;name&#125;, 地址 &#123;url&#125;&quot;.format(**site)) # 通过列表索引设置参数my_list = [&#x27;菜鸟教程&#x27;, &#x27;www.runoob.com&#x27;]print(&quot;网站名：&#123;0[0]&#125;, 地址 &#123;0[1]&#125;&quot;.format(my_list)) # &quot;0&quot; 是必须的# 向str.format() 传入对象 不明白这里class AssignValue(object): def __init__(self, value): self.value = valuemy_value = AssignValue(6)print(&#x27;value 为: &#123;0.value&#125;&#x27;.format(my_value)) # &quot;0&quot; 是可选的 数字格式化 12&gt;&gt;&gt; print(&quot;&#123;:.2f&#125;&quot;.format(3.1415926))3.14 列表一些列表操作： 更新列表 12&gt;&gt;&gt; list = []&gt;&gt;&gt; list.append(&#x27;test&#x27;) 删除列表元素 123&gt;&gt;&gt; del list[0]&gt;&gt;&gt; print list[] 操作符 1234567891011121314#len(list)&gt;&gt;&gt; list.append(&#x27;test&#x27;)&gt;&gt;&gt; len(list)1# + 组合列表 -&gt; 新列表&gt;&gt;&gt; [1] + list[1, &#x27;test&#x27;]# * 重复列表 -&gt; 新列表&gt;&gt;&gt; list * 2[&#x27;test&#x27;, &#x27;test&#x27;]# in 检查成员&gt;&gt;&gt; &#x27;test&#x27; in listTrue# for x in [1,2,3]: print x 函数和方法 序号 函数 1 cmp(list1, list2) 比较两个列表的元素 2 len(list) 列表元素个数 3 max(list) 返回列表元素最大值 4 min(list) 返回列表元素最小值 5 list(seq) 将元组转换为列表 序号 方法 1 list.append(obj) 在列表末尾添加新的对象 2 list.count(obj) 统计某个元素在列表中出现的次数 3 list.extend(seq) 在列表末尾一次性追加另一个序列中的多个值（用新列表扩展原来的列表） 4 list.index(obj) 从列表中找出某个值第一个匹配项的索引位置 5 list.insert(index, obj) 将对象插入列表 6 [list.pop(index=-1]) 移除列表中的一个元素（默认最后一个元素），并且返回该元素的值 7 list.remove(obj) 移除列表中某个值的第一个匹配项 8 list.reverse() 反向列表中元素 9 list.sort(cmp=None, key=None, reverse=False) 对原列表进行排序 ​ 元组 创建 tup1 = (‘physics’, ‘chemistry’, 1997, 2000) tup2 = (1, 2, 3, 4, 5 ) tup3 = “a”, “b”, “c”, “d” 创建空元组 1tup1 = () 元组中只包含一个元素时，需要在元素后面添加逗号 1tup1 = (50,) 元组与字符串类似，下标索引从0开始，可以进行截取，组合等。 访问 索引或切片 修改 元组中的元素值是不允许修改的，但我们可以对元组进行连接组合 tup1 = (12, 34.56) tup2 = (‘abc’, ‘xyz’) # 以下修改元组元素操作是非法的。 # tup1[0] = 100 # 创建一个新的元组 tup3 = tup1 + tup2 print tup3 输出(12, 34.56, ‘abc’, ‘xyz’) 删除 del tup 运算符 Python 表达式 结果 描述 len((1, 2, 3)) 3 计算元素个数 (1, 2, 3) + (4, 5, 6) (1, 2, 3, 4, 5, 6) 连接 (‘Hi!’,) * 4 (‘Hi!’, ‘Hi!’, ‘Hi!’, ‘Hi!’) 复制 3 in (1, 2, 3) True 元素是否存在 for x in (1, 2, 3): print x, 1 2 3 迭代 任意无符号的对象，以逗号隔开，默认为元组 123456print &#x27;abc&#x27;, -4.24e93, 18+6.6j, &#x27;xyz&#x27;x, y = 1, 2print &quot;Value of x , y : &quot;, x,yabc -4.24e+93 (18+6.6j) xyzValue of x , y : 1 2 内置 函数 序号 方法及描述 1 cmp(tuple1, tuple2) 比较两个元组元素。 2 len(tuple) 计算元组元素个数。 3 max(tuple) 返回元组中元素最大值。 4 min(tuple) 返回元组中元素最小值。 5 tuple(seq) 将列表转换为元组。 字典 创建字典 1234567891011121314tinydict1 = &#123; &#x27;abc&#x27;: 456 &#125;tinydict2 = &#123; &#x27;abc&#x27;: 123, 98.6: 37 &#125;# 使用大括号 &#123;&#125; 来创建空字典emptyDict = &#123;&#125; # 打印字典print(emptyDict) # 查看字典的数量print(&quot;Length:&quot;, len(emptyDict)) # 查看类型print(type(emptyDict))# 使用dict() 创建emptyDict = dict() 访问 123tinydict = &#123;&#x27;Name&#x27;: &#x27;Runoob&#x27;, &#x27;Age&#x27;: 7, &#x27;Class&#x27;: &#x27;First&#x27;&#125;print (&quot;tinydict[&#x27;Name&#x27;]: &quot;, tinydict[&#x27;Name&#x27;])print (&quot;tinydict[&#x27;Age&#x27;]: &quot;, tinydict[&#x27;Age&#x27;]) 修改 12345tinydict = &#123;&#x27;Name&#x27;: &#x27;Runoob&#x27;, &#x27;Age&#x27;: 7, &#x27;Class&#x27;: &#x27;First&#x27;&#125;tinydict[&#x27;Age&#x27;] = 8 # 更新 Agetinydict[&#x27;School&#x27;] = &quot;菜鸟教程&quot; # 添加信息print (&quot;tinydict[&#x27;Age&#x27;]: &quot;, tinydict[&#x27;Age&#x27;])print (&quot;tinydict[&#x27;School&#x27;]: &quot;, tinydict[&#x27;School&#x27;]) 删除元素 12345del tinydict[&#x27;Name&#x27;] # 删除键 &#x27;Name&#x27;tinydict.clear() # 清空字典del tinydict # 删除字典print (&quot;tinydict[&#x27;Age&#x27;]: &quot;, tinydict[&#x27;Age&#x27;])print (&quot;tinydict[&#x27;School&#x27;]: &quot;, tinydict[&#x27;School&#x27;]) 键特性 两个重要的点需要记住： 1）不允许同一个键出现两次。创建时如果同一个键被赋值两次，后一个值会被记住 2）键必须不可变，所以可以用数字，字符串或元组充当，而用列表就不行 内置函数和方法 号 函数及描述 实例 1 len(dict) 计算字典元素个数，即键的总数。 &gt;&gt;&gt; tinydict = &#123;&#39;Name&#39;: &#39;Runoob&#39;, &#39;Age&#39;: 7, &#39;Class&#39;: &#39;First&#39;&#125; &gt;&gt;&gt; len(tinydict) 3 2 str(dict) 输出字典，可以打印的字符串表示。 &gt;&gt;&gt; tinydict = &#123;&#39;Name&#39;: &#39;Runoob&#39;, &#39;Age&#39;: 7, &#39;Class&#39;: &#39;First&#39;&#125; &gt;&gt;&gt; str(tinydict) &quot;&#123;&#39;Name&#39;: &#39;Runoob&#39;, &#39;Class&#39;: &#39;First&#39;, &#39;Age&#39;: 7&#125;&quot; 3 type(variable) 返回输入的变量类型，如果变量是字典就返回字典类型。 &gt;&gt;&gt; tinydict = &#123;&#39;Name&#39;: &#39;Runoob&#39;, &#39;Age&#39;: 7, &#39;Class&#39;: &#39;First&#39;&#125; &gt;&gt;&gt; type(tinydict) &lt;class &#39;dict&#39;&gt; 序号 函数及描述 1 dict.clear() 删除字典内所有元素 2 dict.copy() 返回一个字典的浅复制 3 dict.fromkeys() 创建一个新字典，以序列seq中元素做字典的键，val为字典所有键对应的初始值 4 dict.get(key, default=None) 返回指定键的值，如果键不在字典中返回 default 设置的默认值 5 key in dict 如果键在字典dict里返回true，否则返回false 6 dict.items() 以列表返回一个视图对象 7 dict.keys() 返回一个视图对象 8 dict.setdefault(key, default=None) 和get()类似, 但如果键不存在于字典中，将会添加键并将值设为default 9 dict.update(dict2) 把字典dict2的键/值对更新到dict里 10 dict.values() 返回一个视图对象 11 [pop(key,default]) 删除字典给定键 key 所对应的值，返回值为被删除的值。key值必须给出。 否则，返回default值。 12 popitem() 返回并删除字典中的最后一对键和值。 ​ 集合一个无序的不重复元素序列。 创建 12345678910parame = &#123;value01,value02,...&#125;或者set(value)&gt;&gt;&gt; basket = &#123;&#x27;apple&#x27;, &#x27;orange&#x27;, &#x27;apple&#x27;, &#x27;pear&#x27;, &#x27;orange&#x27;, &#x27;banana&#x27;&#125;&gt;&gt;&gt; print(basket) # 这里演示的是去重功能&#123;&#x27;orange&#x27;, &#x27;banana&#x27;, &#x27;pear&#x27;, &#x27;apple&#x27;&#125;&gt;&gt;&gt; &#x27;orange&#x27; in basket # 快速判断元素是否在集合内True&gt;&gt;&gt; &#x27;crabgrass&#x27; in basketFalse 添加元素 123456789s.add( x ) #将元素 x 添加到集合 s 中，如果元素已存在，则不进行任何操作s.update( x ) #参数可以是列表，元组，字典等&gt;&gt;&gt; thisset = set((&quot;Google&quot;, &quot;Runoob&quot;, &quot;Taobao&quot;))&gt;&gt;&gt; thisset.update(&#123;1,3&#125;)&gt;&gt;&gt; print(thisset)&#123;1, 3, &#x27;Google&#x27;, &#x27;Taobao&#x27;, &#x27;Runoob&#x27;&#125;&gt;&gt;&gt; thisset.update([1,4],[5,6]) &gt;&gt;&gt; print(thisset)&#123;1, 3, 4, 5, 6, &#x27;Google&#x27;, &#x27;Taobao&#x27;, &#x27;Runoob&#x27;&#125; 删除元素 123s.remove( x ) #将元素 x 从集合 s 中移除，如果元素不存在，则会发生错误s.discard( x ) #如果元素不存在，不会发生错误s.pop() #随机删除集合中的一个元素，set 集合的 pop 方法会对集合进行无序的排列，然后将这个无序排列集合的左面第一个元素进行删除 计算元素个数 1len(s) 清空集合 1s.clear() 判断元素是否存在 1x in s 内置方法 方法 描述 add() 为集合添加元素 clear() 移除集合中的所有元素 copy() 拷贝一个集合 difference() 返回多个集合的差集 difference_update() 移除集合中的元素，该元素在指定的集合也存在。 discard() 删除集合中指定的元素 intersection() 返回集合的交集 intersection_update() 返回集合的交集。 isdisjoint() 判断两个集合是否包含相同的元素，如果没有返回 True，否则返回 False。 issubset() 判断指定集合是否为该方法参数集合的子集。 issuperset() 判断该方法的参数集合是否为指定集合的子集 pop() 随机移除元素 remove() 移除指定元素 symmetric_difference() 返回两个集合中不重复的元素集合。 symmetric_difference_update() 移除当前集合中在另外一个指定集合相同的元素，并将另外一个指定集合中不同的元素插入到当前集合中。 union() 返回两个集合的并集 update() 给集合添加元素 条件控制 if 1、每个条件后面要使用冒号 **:**，表示接下来是满足条件后要执行的语句块。 2、使用缩进来划分语句块，相同缩进数的语句在一起组成一个语句块。 3、在Python中没有switch – case语句。 if-elif-else : python 中无else if 而使用elif if 嵌套 循环语句Python 中的循环语句有 for 和 while,同样需要注意冒号和缩进。另外，在 Python 中没有 do..while 循环 while 12while 判断条件(condition)： 执行语句(statements)…… while else 1234while &lt;expr&gt;: &lt;statement(s)&gt;else: &lt;additional_statement(s)&gt; 简单语句组 类似if语句的语法，如果你的while循环体中只有一条语句，你可以将该语句与while写在同一行中 1flag = 1 while (flag): print (&#x27;欢迎访问菜鸟教程!&#x27;) print (&quot;Good bye!&quot;) for for 循环可以遍历任何可迭代对象，如一个列表或者一个字符串 1234for &lt;variable&gt; in &lt;sequence&gt;: &lt;statements&gt; else: &lt;statements&gt; range() 遍历数字序列，可以使用内置range()函数。它会生成数列 结合range()和len()函数以遍历一个序列的索引 使用range()函数来创建一个列表 12345678910111213141516171819202122232425&gt;&gt;&gt;for i in range(5):... print(i)...01234&gt;&gt;&gt;for i in range(0, 10, 3) : print(i)0369&gt;&gt;&gt;a = [&#x27;Google&#x27;, &#x27;Baidu&#x27;, &#x27;Runoob&#x27;, &#x27;Taobao&#x27;, &#x27;QQ&#x27;]&gt;&gt;&gt; for i in range(len(a)):... print(i, a[i])... 0 Google1 Baidu2 Runoob3 Taobao4 QQ&gt;&gt;&gt;list(range(5))[0, 1, 2, 3, 4] pass pass是空语句，是为了保持程序结构的完整性,不做任何事情，一般用做占位语句 迭代器与生成器 迭代器 迭代是Python最强大的功能之一，是访问集合元素的一种方式。 迭代器是一个可以记住遍历的位置的对象。 迭代器对象从集合的第一个元素开始访问，直到所有的元素被访问完结束。迭代器只能往前不会后退。 迭代器有两个基本的方法：iter() 和 **next()**。 12345678910111213#字符串，列表或元组对象都可用于创建迭代器&gt;&gt;&gt; list=[1,2,3,4]&gt;&gt;&gt; it = iter(list) # 创建迭代器对象&gt;&gt;&gt; print (next(it)) # 输出迭代器的下一个元素1&gt;&gt;&gt; print (next(it))2#迭代器对象可以使用常规for语句进行遍历：list=[1,2,3,4]it = iter(list) # 创建迭代器对象for x in it: print (x, end=&quot; &quot;)1 2 3 4 创建 把一个类作为一个迭代器使用需要在类中实现两个方法__ iter() 与__ next() __ iter() 方法返回一个特殊的迭代器对象， 这个迭代器对象实现了 next() 方法并通过 StopIteration 异常标识迭代的完成。 __ next() 方法（Python 2 里是 next()）会返回下一个迭代器对象。 123456789101112131415161718192021222324252627282930313233343536373839404142class MyNumbers: def __iter__(self): self.a = 1 return self def __next__(self): x = self.a self.a += 1 return x myclass = MyNumbers()myiter = iter(myclass) print(next(myiter))print(next(myiter))print(next(myiter))print(next(myiter))print(next(myiter))12345#StopIteration 异常用于标识迭代的完成，防止出现无限循环的情况，在 __next__() 方法中我们可以设置在完成指定循环次数后触发 StopIteration 异常来结束迭代。class MyNumbers: def __iter__(self): self.a = 1 return self def __next__(self): if self.a &lt;= 20: x = self.a self.a += 1 return x else: raise StopIteration myclass = MyNumbers()myiter = iter(myclass) for x in myiter: print(x) 生成器 在 Python 中，使用了 yield 的函数被称为生成器（generator）。 跟普通函数不同的是，生成器是一个返回迭代器的函数，只能用于迭代操作，更简单点理解生成器就是一个迭代器。 在调用生成器运行的过程中，每次遇到 yield 时函数会暂停并保存当前所有的运行信息，返回 yield 的值, 并在下一次执行 next() 方法时从当前位置继续运行。 调用一个生成器函数，返回的是一个迭代器对象。 123456789101112131415161718import sys def fibonacci(n): # 生成器函数 - 斐波那契 a, b, counter = 0, 1, 0 while True: if (counter &gt; n): return yield a a, b = b, a + b counter += 1f = fibonacci(10) # f 是一个迭代器，由生成器返回生成 while True: try: print (next(f), end=&quot; &quot;) except StopIteration: sys.exit() 0 1 1 2 3 5 8 13 21 34 55 函数 函数代码块以 def 关键词开头，后接函数标识符名称和圆括号 **()**。 任何传入参数和自变量必须放在圆括号中间，圆括号之间可以用于定义参数。 函数的第一行语句可以选择性地使用文档字符串—用于存放函数说明。 函数内容以冒号 : 起始，并且缩进。 return [表达式] 结束函数，选择性地返回一个值给调用方，不带表达式的 return 相当于返回 None。 格式： 12def 函数名（参数列表）: 函数体 参数传递 在 python 中，类型属于对象，对象有不同类型的区分，变量是没有类型的 123a=[1,2,3]a=&quot;Runoob&quot; 以上代码中，**[1,2,3]** 是 List 类型，**”Runoob”** 是 String 类型，而变量 a 是没有类型，她仅仅是一个对象的引用（一个指针），可以是指向 List 类型对象，也可以是指向 String 类型对象。 可更改(mutable)与不可更改(immutable)对象 在 python 中，strings, tuples, 和 numbers 是不可更改的对象，而 list,dict 等则是可以修改的对象。 不可变类型：变量赋值 a=5 后再赋值 a=10，这里实际是新生成一个 int 值对象 10，再让 a 指向它，而 5 被丢弃，不是改变 a 的值，相当于新生成了 a。 可变类型：变量赋值 la=[1,2,3,4] 后再赋值 la[2]=5 则是将 list la 的第三个元素值更改，本身la没有动，只是其内部的一部分值被修改了。 python 函数的参数传递： 不可变类型：类似 C++ 的值传递，如整数、字符串、元组。如 fun(a)，传递的只是 a 的值，没有影响 a 对象本身。如果在 fun(a) 内部修改 a 的值，则是新生成一个 a 的对象。 可变类型：类似 C++ 的引用传递，如 列表，字典。如 fun(la)，则是将 la 真正的传过去，修改后 fun 外部的 la 也会受影响 python 中一切都是对象，严格意义我们不能说值传递还是引用传递，我们应该说传不可变对象和传可变对象。 1234567891011121314151617181920212223242526#传不可变对象 通过 id() 函数来查看内存地址变化：def change(a): print(id(a)) # 指向的是同一个对象 a=10 print(id(a)) # 一个新对象 a=1print(id(a))change(a)437936913643793691364379369424#传可变对象 通过 id() 函数来查看内存地址变化：# 可写函数说明def changeme( mylist ): &quot;修改传入的列表&quot; mylist.append([1,2,3,4]) print (&quot;函数内取值: &quot;, mylist) return # 调用changeme函数mylist = [10,20,30]changeme( mylist )print (&quot;函数外取值: &quot;, mylist)函数内取值: [10, 20, 30, [1, 2, 3, 4]]函数外取值: [10, 20, 30, [1, 2, 3, 4]] 参数 必需参数 必需参数须以正确的顺序传入函数。调用时的数量必须和声明时的一样。 关键字参数 关键字参数和函数调用关系紧密，函数调用使用关键字参数来确定传入的参数值。 使用关键字参数允许函数调用时参数的顺序与声明时不一致，因为 Python 解释器能够用参数名匹配参数值。 12345678910111213141516#可写函数说明def printme( str ): &quot;打印任何传入的字符串&quot; print (str) return#调用printme函数printme( str = &quot;菜鸟教程&quot;)#不需要使用指定顺序#可写函数说明def printinfo( name, age ): &quot;打印任何传入的字符串&quot; print (&quot;名字: &quot;, name) print (&quot;年龄: &quot;, age) return#调用printinfo函数printinfo( age=50, name=&quot;runoob&quot; ) 默认参数 调用函数时，如果没有传递参数，则会使用默认参数。以下实例中如果没有传入 age 参数，则使用默认值： 12345678910#可写函数说明def printinfo( name, age = 35 ): &quot;打印任何传入的字符串&quot; print (&quot;名字: &quot;, name) print (&quot;年龄: &quot;, age) return#调用printinfo函数printinfo( age=50, name=&quot;runoob&quot; )print (&quot;------------------------&quot;)printinfo( name=&quot;runoob&quot; ) 不定长参数 你可能需要一个函数能处理比当初声明时更多的参数。这些参数叫做不定长参数，和上述 2 种参数不同，声明时不会命名。基本语法如下： 12345def functionname([formal_args,] *var_args_tuple ): &quot;函数_文档字符串&quot; function_suite return [expression]加了星号 * 的参数会以元组(tuple)的形式导入，存放所有未命名的变量参数。 1234567891011# 可写函数说明def printinfo( arg1, *vartuple ): &quot;打印任何传入的参数&quot; print (&quot;输出: &quot;) print (arg1) print (vartuple)# 调用printinfo 函数printinfo( 70, 60, 50 )输出: 70(60, 50) 还有一种就是参数带两个星号 ******基本语法如下： 12345def functionname([formal_args,] **var_args_dict ): &quot;函数_文档字符串&quot; function_suite return [expression]加了两个星号 ** 的参数会以字典的形式导入 12345678910111213# 可写函数说明def printinfo( arg1, **vardict ): &quot;打印任何传入的参数&quot; print (&quot;输出: &quot;) print (arg1) print (vardict) # 调用printinfo 函数printinfo(1, a=2,b=3)输出: 1&#123;&#x27;a&#x27;: 2, &#x27;b&#x27;: 3&#125; 声明函数时，参数中星号 ***** 可以单独出现，例如: 1234567891011def f(a,b,*,c): return a+b+c&gt;&gt;&gt; def f(a,b,*,c):... return a+b+c... &gt;&gt;&gt; f(1,2,3) # 报错Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;TypeError: f() takes 2 positional arguments but 3 were given&gt;&gt;&gt; f(1,2,c=3) # 正常6 匿名函数 Python 使用 lambda 来创建匿名函数。 所谓匿名，意即不再使用 def 语句这样标准的形式定义一个函数。 lambda 只是一个表达式，函数体比 def 简单很多。 lambda 的主体是一个表达式，而不是一个代码块。仅仅能在 lambda 表达式中封装有限的逻辑进去。 lambda 函数拥有自己的命名空间，且不能访问自己参数列表之外或全局命名空间里的参数。 虽然 lambda 函数看起来只能写一行，却不等同于 C 或 C++ 的内联函数，后者的目的是调用小函数时不占用栈内存从而增加运行效率。 lambda 函数的语法只包含一个语句，如下： 1lambda [arg1 [,arg2,.....argn]]:expression 123456789#一个参数x = lambda a : a + 10print(x(5))#多个参数# 可写函数说明sum = lambda arg1, arg2: arg1 + arg2# 调用sum函数print (&quot;相加后的值为 : &quot;, sum( 10, 20 ))print (&quot;相加后的值为 : &quot;, sum( 20, 20 )) 可以将匿名函数封装在一个函数内，这样可以使用同样的代码来创建多个匿名函数。 12345678def myfunc(n): return lambda a : a * n mydoubler = myfunc(2)mytripler = myfunc(3) print(mydoubler(11))print(mytripler(11)) 数据结构参考菜鸟教程 模块Python 提供了一个办法，把这些定义存放在文件中，为一些脚本或者交互式的解释器实例使用，这个文件被称为模块。 模块是一个包含所有你定义的函数和变量的文件，其后缀名是.py。模块可以被别的程序引入，以使用该模块中的函数等功能。这也是使用 python 标准库的方法。 1、import sys 引入 python 标准库中的 sys.py 模块；这是引入某一模块的方法。 2、sys.argv 是一个包含命令行参数的列表。 3、sys.path 包含了一个 Python 解释器自动查找所需模块的路径的列表。 深入模块 输入输出 输出格式美化 Python两种输出值的方式: 表达式语句和 print() 函数。 第三种方式是使用文件对象的 write() 方法，标准输出文件可以用 sys.stdout 引用。 如果你希望输出的形式更加多样，可以使用 str.format() 函数来格式化输出值。 如果你希望将输出的值转成字符串，可以使用 repr() 或 str() 函数来实现。 str()： 函数返回一个用户易读的表达形式。 repr()： 产生一个解释器易读的表达形式。 1234567891011121314151617181920&gt;&gt;&gt; s = &#x27;Hello, Runoob&#x27;&gt;&gt;&gt; str(s)&#x27;Hello, Runoob&#x27;&gt;&gt;&gt; repr(s)&quot;&#x27;Hello, Runoob&#x27;&quot;&gt;&gt;&gt; str(1/7)&#x27;0.14285714285714285&#x27;&gt;&gt;&gt; x = 10 * 3.25&gt;&gt;&gt; y = 200 * 200&gt;&gt;&gt; s = &#x27;x 的值为： &#x27; + repr(x) + &#x27;, y 的值为：&#x27; + repr(y) + &#x27;...&#x27;&gt;&gt;&gt; print(s)x 的值为： 32.5, y 的值为：40000...&gt;&gt;&gt; # repr() 函数可以转义字符串中的特殊字符... hello = &#x27;hello, runoob\\n&#x27;&gt;&gt;&gt; hellos = repr(hello)&gt;&gt;&gt; print(hellos)&#x27;hello, runoob\\n&#x27;&gt;&gt;&gt; # repr() 的参数可以是 Python 的任何对象... repr((x, y, (&#x27;Google&#x27;, &#x27;Runoob&#x27;)))&quot;(32.5, 40000, (&#x27;Google&#x27;, &#x27;Runoob&#x27;))&quot; str.format() #括号及其里面的字符 (称作格式化字段) 将会被 format() 中的参数替换 &gt;&gt;&gt; print(‘{}网址： “{}!”‘.format(‘菜鸟教程’, ‘www.runoob.com&#39;))菜鸟教程网址： “www.runoob.com!&quot; #在括号中的数字用于指向传入对象在 format() 中的位置 &gt;&gt;&gt; print(‘{0} 和 {1}’.format(‘Google’, ‘Runoob’))Google 和 Runoob&gt;&gt;&gt; print(‘{1} 和 {0}’.format(‘Google’, ‘Runoob’))Runoob 和 Google #如果在 format() 中使用了关键字参数, 那么它们的值会指向使用该名字的参数 &gt;&gt;&gt; print(‘{name}网址： {site}’.format(name=’菜鸟教程’, site=’www.runoob.com&#39;))菜鸟教程网址： www.runoob.com #位置及关键字参数可以任意的结合 &gt;&gt;&gt; print(‘站点列表 {0}, {1}, 和 {other}。’.format(‘Google’, ‘Runoob’, other=’Taobao’))站点列表 Google, Runoob, 和 Taobao。 #!a (使用 ascii()), !s (使用 str()) 和 !r (使用 repr()) 可以用于在格式化某个值之前对其进行转化: 12345&gt;&gt;&gt; import math&gt;&gt;&gt; print(&#x27;常量 PI 的值近似为： &#123;&#125;。&#x27;.format(math.pi))常量 PI 的值近似为： 3.141592653589793。&gt;&gt;&gt; print(&#x27;常量 PI 的值近似为： &#123;!r&#125;。&#x27;.format(math.pi))常量 PI 的值近似为： 3.141592653589793。 #可选项 : 和格式标识符可以跟着字段名。 这就允许对值进行更好的格式化。 下面的例子将 Pi 保留到小数点后三位： 123&gt;&gt;&gt; import math&gt;&gt;&gt; print(&#x27;常量 PI 的值近似为 &#123;0:.3f&#125;。&#x27;.format(math.pi))常量 PI 的值近似为 3.142。 #在 : 后传入一个整数, 可以保证该域至少有这么多的宽度。 用于美化表格时很有用 1234567&gt;&gt;&gt; table = &#123;&#x27;Google&#x27;: 1, &#x27;Runoob&#x27;: 2, &#x27;Taobao&#x27;: 3&#125;&gt;&gt;&gt; for name, number in table.items():... print(&#x27;&#123;0:10&#125; ==&gt; &#123;1:10d&#125;&#x27;.format(name, number))...Google ==&gt; 1Runoob ==&gt; 2Taobao ==&gt; 3 旧式字符串格式化 % 操作符也可以实现字符串格式化。 它将左边的参数作为类似 sprintf() 式的格式化字符串, 而将右边的代入, 然后返回格式化后的字符串. 但是因为这种旧式的格式化最终会从该语言中移除, 应该更多的使用 str.format(). 123&gt;&gt;&gt; import math&gt;&gt;&gt; print(&#x27;常量 PI 的值近似为：%5.3f。&#x27; % math.pi)常量 PI 的值近似为：3.142。 读取键盘输入 使用input()内置函数从标准输入读入一行文本，默认的标准输入是键盘 123#!/usr/bin/python3str = input(&quot;请输入：&quot;);print (&quot;你输入的内容是: &quot;, str) 读写文件 open() 将会返回一个 file 对象： 123open(filename, mode)filename：包含了你要访问的文件名称的字符串值。mode：决定了打开文件的模式：只读，写入，追加等。所有可取值见如下的完全列表。这个参数是非强制的，默认文件访问模式为只读(r)。 实例 12345# 打开一个文件f = open(&quot;/tmp/foo.txt&quot;, &quot;w&quot;)f.write( &quot;Python 是一个非常好的语言。\\n是的，的确非常好!!\\n&quot; )# 关闭打开的文件f.close() 不同模式打开文件的完全列表： 模式 描述 r 以只读方式打开文件。文件的指针将会放在文件的开头。这是默认模式。 rb 以二进制格式打开一个文件用于只读。文件指针将会放在文件的开头。 r+ 打开一个文件用于读写。文件指针将会放在文件的开头。 rb+ 以二进制格式打开一个文件用于读写。文件指针将会放在文件的开头。 w 打开一个文件只用于写入。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。 wb 以二进制格式打开一个文件只用于写入。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。 w+ 打开一个文件用于读写。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。 wb+ 以二进制格式打开一个文件用于读写。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。 a 打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。 ab 以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。 a+ 打开一个文件用于读写。如果该文件已存在，文件指针将会放在文件的结尾。文件打开时会是追加模式。如果该文件不存在，创建新文件用于读写。 ab+ 以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。如果该文件不存在，创建新文件用于读写。 模式 r r+ w w+ a a+ 读 + + + + 写 + + + + + 创建 + + + + 覆盖 + + 指针在开始 + + + + 指针在结尾 + + 文件对象方法 f.read() #调用 f.read(size), 这将读取一定数目的数据, 然后作为字符串或字节对象返回。size 是一个可选的数字类型的参数。 当 size 被忽略了或者为负, 那么该文件的所有内容都将被读取并且返回。 实例 12345678910#!/usr/bin/python3# 打开一个文件f = open(&quot;/tmp/foo.txt&quot;, &quot;r&quot;)str = f.read()print(str)# 关闭打开的文件f.close()Python 是一个非常好的语言。是的，的确非常好!! f.readline() #f.readline() 会从文件中读取单独的一行。换行符为 ‘\\n’。f.readline() 如果返回一个空字符串, 说明已经已经读取到最后一行。 实例 12345678# 打开一个文件f = open(&quot;/tmp/foo.txt&quot;, &quot;r&quot;)str = f.readline()print(str)# 关闭打开的文件f.close()Python 是一个非常好的语言。 f.readlines() #返回该文件中包含的所有行。 #如果设置可选参数 sizehint, 则读取指定长度的字节, 并且将这些字节按行分割。 实例1 123456789#!/usr/bin/python3# 打开一个文件f = open(&quot;/tmp/foo.txt&quot;, &quot;r&quot;)str = f.readlines()print(str)# 关闭打开的文件f.close()输出[&#x27;Python 是一个非常好的语言。\\n&#x27;, &#x27;是的，的确非常好!!\\n&#x27;] 实例2 迭代一个文件对象然后读取每行: 123456789# 打开一个文件f = open(&quot;/tmp/foo.txt&quot;, &quot;r&quot;)for line in f: print(line, end=&#x27;&#x27;)# 关闭打开的文件f.close()执行以上程序，输出结果为：Python 是一个非常好的语言。是的，的确非常好!! f.write() f.write(string) 将 string 写入到文件中, 然后返回写入的字符数。 123456789#!/usr/bin/python3# 打开一个文件f = open(&quot;/tmp/foo.txt&quot;, &quot;w&quot;)num = f.write( &quot;Python 是一个非常好的语言。\\n是的，的确非常好!!\\n&quot; )print(num)# 关闭打开的文件f.close()执行以上程序，输出结果为：29 如果要写入一些不是字符串的东西, 那么将需要先进行转换: 1234567891011#!/usr/bin/python3# 打开一个文件f = open(&quot;/tmp/foo1.txt&quot;, &quot;w&quot;)value = (&#x27;www.runoob.com&#x27;, 14)s = str(value)f.write(s)# 关闭打开的文件f.close()执行以上程序，打开 foo1.txt 文件：$ cat /tmp/foo1.txt (&#x27;www.runoob.com&#x27;, 14) f.tell() f.tell() 返回文件对象当前所处的位置, 它是从文件开头开始算起的字节数。 f.seek() 如果要改变文件当前的位置, 可以使用 f.seek(offset, from_what) 函数。 from_what 的值, 如果是 0 表示开头, 如果是 1 表示当前位置, 2 表示文件的结尾，例如： seek(x,0) ： 从起始位置即文件首行首字符开始移动 x 个字符 seek(x,1) ： 表示从当前位置往后移动x个字符 seek(-x,2)：表示从文件的结尾往前移动x个字符 from_what 值为默认为0，即文件开头。下面给出一个完整的例子： 1234567891011&gt;&gt;&gt; f = open(&#x27;/tmp/foo.txt&#x27;, &#x27;rb+&#x27;)&gt;&gt;&gt; f.write(b&#x27;0123456789abcdef&#x27;)16&gt;&gt;&gt; f.seek(5) # 移动到文件的第六个字节5&gt;&gt;&gt; f.read(1)b&#x27;5&#x27;&gt;&gt;&gt; f.seek(-3, 2) # 移动到文件的倒数第三字节13&gt;&gt;&gt; f.read(1)b&#x27;d&#x27; f.close() 当你处理完一个文件后, 调用 f.close() 来关闭文件并释放系统的资源，如果尝试再调用该文件，则会抛出异常。 12345&gt;&gt;&gt; f.close()&gt;&gt;&gt; f.read()Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in ?ValueError: I/O operation on closed file 当处理一个文件对象时, 使用 with 关键字是非常好的方式。在结束后, 它会帮你正确的关闭文件。 而且写起来也比 try - finally 语句块要简短: 1234&gt;&gt;&gt; with open(&#x27;/tmp/foo.txt&#x27;, &#x27;r&#x27;) as f:... read_data = f.read()&gt;&gt;&gt; f.closedTrue pickle 模块 python的pickle模块实现了基本的数据序列和反序列化。 通过pickle模块的序列化操作我们能够将程序中运行的对象信息保存到文件中去，永久存储。 通过pickle模块的反序列化操作，我们能够从文件中创建上一次程序保存的对象。 基本接口： 1pickle.dump(obj, file, [,protocol]) 有了 pickle 这个对象, 就能对 file 以读取的形式打开: 1x = pickle.load(file) 注解：从 file 中读取一个字符串，并将它重构为原来的python对象。 file: 类文件对象，有read()和readline()接口。 12345678910111213141516171819import pickle# 使用pickle模块将数据对象保存到文件data1 = &#123;&#x27;a&#x27;: [1, 2.0, 3, 4+6j], &#x27;b&#x27;: (&#x27;string&#x27;, u&#x27;Unicode string&#x27;), &#x27;c&#x27;: None&#125;selfref_list = [1, 2, 3]selfref_list.append(selfref_list)output = open(&#x27;data.pkl&#x27;, &#x27;wb&#x27;)# Pickle dictionary using protocol 0.pickle.dump(data1, output)# Pickle the list using the highest protocol available.pickle.dump(selfref_list, output, -1)output.close() 123456789101112import pprint, pickle#使用pickle模块从文件中重构python对象pkl_file = open(&#x27;data.pkl&#x27;, &#x27;rb&#x27;)data1 = pickle.load(pkl_file)pprint.pprint(data1)data2 = pickle.load(pkl_file)pprint.pprint(data2)pkl_file.close() File open()方法 Python open() 方法用于打开一个文件，并返回文件对象，在对文件进行处理过程都需要使用到这个函数，如果该文件无法被打开，会抛出 OSError。 注意：使用 open() 方法一定要保证关闭文件对象，即调用 close() 方法。 open() 函数常用形式是接收两个参数：文件名(file)和模式(mode)。 1open(file, mode=&#x27;r&#x27;) 完整的语法格式为： 1open(file, mode=&#x27;r&#x27;, buffering=-1, encoding=None, errors=None, newline=None, closefd=True, opener=None) 参数说明: file: 必需，文件路径（相对或者绝对路径）。 mode: 可选，文件打开模式 buffering: 设置缓冲 encoding: 一般使用utf8 errors: 报错级别 newline: 区分换行符 closefd: 传入的file参数类型 opener: 设置自定义开启器，开启器的返回值必须是一个打开的文件描述符。 mode 参数有： 模式 描述 t 文本模式 (默认)。 x 写模式，新建一个文件，如果该文件已存在则会报错。 b 二进制模式。 + 打开一个文件进行更新(可读可写)。 U 通用换行模式（Python 3 不支持）。 r 以只读方式打开文件。文件的指针将会放在文件的开头。这是默认模式。 rb 以二进制格式打开一个文件用于只读。文件指针将会放在文件的开头。这是默认模式。一般用于非文本文件如图片等。 r+ 打开一个文件用于读写。文件指针将会放在文件的开头。 rb+ 以二进制格式打开一个文件用于读写。文件指针将会放在文件的开头。一般用于非文本文件如图片等。 w 打开一个文件只用于写入。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。 wb 以二进制格式打开一个文件只用于写入。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。一般用于非文本文件如图片等。 w+ 打开一个文件用于读写。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。 wb+ 以二进制格式打开一个文件用于读写。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。一般用于非文本文件如图片等。 a 打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。 ab 以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。 a+ 打开一个文件用于读写。如果该文件已存在，文件指针将会放在文件的结尾。文件打开时会是追加模式。如果该文件不存在，创建新文件用于读写。 ab+ 以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。如果该文件不存在，创建新文件用于读写。 默认为文本模式，如果要以二进制模式打开，加上 b 。 file 对象 file 对象使用 open 函数来创建，下表列出了 file 对象常用的函数： 序号 方法及描述 1 file.close()关闭文件。关闭后文件不能再进行读写操作。 2 file.flush()刷新文件内部缓冲，直接把内部缓冲区的数据立刻写入文件, 而不是被动的等待输出缓冲区写入。 3 file.fileno()返回一个整型的文件描述符(file descriptor FD 整型), 可以用在如os模块的read方法等一些底层操作上。 4 file.isatty()如果文件连接到一个终端设备返回 True，否则返回 False。 5 file.next()Python 3 中的 File 对象不支持 next() 方法。返回文件下一行。 6 [file.read(size])从文件读取指定的字节数，如果未给定或为负则读取所有。 7 [file.readline(size])读取整行，包括 “\\n” 字符。 8 [file.readlines(sizeint])读取所有行并返回列表，若给定sizeint&gt;0，返回总和大约为sizeint字节的行, 实际读取值可能比 sizeint 较大, 因为需要填充缓冲区。 9 [file.seek(offset, whence])移动文件读取指针到指定位置 10 file.tell()返回文件当前位置。 11 [file.truncate(size])从文件的首行首字符开始截断，截断文件为 size 个字符，无 size 表示从当前位置截断；截断之后后面的所有字符被删除，其中 windows 系统下的换行代表2个字符大小。 12 file.write(str)将字符串写入文件，返回的是写入的字符长度。 13 file.writelines(sequence)向文件写入一个序列字符串列表，如果需要换行则要自己加入每行的换行符。 OSos 模块提供了非常丰富的方法用来处理文件和目录。常用的方法如下表所示： 序号 方法及描述 1 os.access(path, mode) 检验权限模式 2 os.chdir(path) 改变当前工作目录 3 os.chflags(path, flags) 设置路径的标记为数字标记。 4 os.chmod(path, mode) 更改权限 5 os.chown(path, uid, gid) 更改文件所有者 6 os.chroot(path) 改变当前进程的根目录 7 os.close(fd) 关闭文件描述符 fd 8 os.closerange(fd_low, fd_high) 关闭所有文件描述符，从 fd_low (包含) 到 fd_high (不包含), 错误会忽略 9 os.dup(fd) 复制文件描述符 fd 10 os.dup2(fd, fd2) 将一个文件描述符 fd 复制到另一个 fd2 11 os.fchdir(fd) 通过文件描述符改变当前工作目录 12 os.fchmod(fd, mode) 改变一个文件的访问权限，该文件由参数fd指定，参数mode是Unix下的文件访问权限。 13 os.fchown(fd, uid, gid) 修改一个文件的所有权，这个函数修改一个文件的用户ID和用户组ID，该文件由文件描述符fd指定。 14 os.fdatasync(fd) 强制将文件写入磁盘，该文件由文件描述符fd指定，但是不强制更新文件的状态信息。 15 [os.fdopen(fd, mode[, bufsize]]) 通过文件描述符 fd 创建一个文件对象，并返回这个文件对象 16 os.fpathconf(fd, name) 返回一个打开的文件的系统配置信息。name为检索的系统配置的值，它也许是一个定义系统值的字符串，这些名字在很多标准中指定（POSIX.1, Unix 95, Unix 98, 和其它）。 17 os.fstat(fd) 返回文件描述符fd的状态，像stat()。 18 os.fstatvfs(fd) 返回包含文件描述符fd的文件的文件系统的信息，Python 3.3 相等于 statvfs()。 19 os.fsync(fd) 强制将文件描述符为fd的文件写入硬盘。 20 os.ftruncate(fd, length) 裁剪文件描述符fd对应的文件, 所以它最大不能超过文件大小。 21 os.getcwd() 返回当前工作目录 22 os.getcwdb() 返回一个当前工作目录的Unicode对象 23 os.isatty(fd) 如果文件描述符fd是打开的，同时与tty(-like)设备相连，则返回true, 否则False。 24 os.lchflags(path, flags) 设置路径的标记为数字标记，类似 chflags()，但是没有软链接 25 os.lchmod(path, mode) 修改连接文件权限 26 os.lchown(path, uid, gid) 更改文件所有者，类似 chown，但是不追踪链接。 27 os.link(src, dst) 创建硬链接，名为参数 dst，指向参数 src 28 os.listdir(path) 返回path指定的文件夹包含的文件或文件夹的名字的列表。 29 os.lseek(fd, pos, how) 设置文件描述符 fd当前位置为pos, how方式修改: SEEK_SET 或者 0 设置从文件开始的计算的pos; SEEK_CUR或者 1 则从当前位置计算; os.SEEK_END或者2则从文件尾部开始. 在unix，Windows中有效 30 os.lstat(path) 像stat(),但是没有软链接 31 os.major(device) 从原始的设备号中提取设备major号码 (使用stat中的st_dev或者st_rdev field)。 32 os.makedev(major, minor) 以major和minor设备号组成一个原始设备号 33 [os.makedirs(path, mode]) 递归文件夹创建函数。像mkdir(), 但创建的所有intermediate-level文件夹需要包含子文件夹。 34 os.minor(device) 从原始的设备号中提取设备minor号码 (使用stat中的st_dev或者st_rdev field )。 35 [os.mkdir(path, mode]) 以数字mode的mode创建一个名为path的文件夹.默认的 mode 是 0777 (八进制)。 36 [os.mkfifo(path, mode]) 创建命名管道，mode 为数字，默认为 0666 (八进制) 37 [os.mknod(filename, mode=0600, device]) 创建一个名为filename文件系统节点（文件，设备特别文件或者命名pipe）。 38 [os.open(file, flags, mode]) 打开一个文件，并且设置需要的打开选项，mode参数是可选的 39 os.openpty() 打开一个新的伪终端对。返回 pty 和 tty的文件描述符。 40 os.pathconf(path, name) 返回相关文件的系统配置信息。 41 os.pipe() 创建一个管道. 返回一对文件描述符(r, w) 分别为读和写 42 [os.popen(command, mode[, bufsize]]) 从一个 command 打开一个管道 43 os.read(fd, n) 从文件描述符 fd 中读取最多 n 个字节，返回包含读取字节的字符串，文件描述符 fd对应文件已达到结尾, 返回一个空字符串。 44 os.readlink(path) 返回软链接所指向的文件 45 os.remove(path) 删除路径为path的文件。如果path 是一个文件夹，将抛出OSError; 查看下面的rmdir()删除一个 directory。 46 os.removedirs(path) 递归删除目录。 47 os.rename(src, dst) 重命名文件或目录，从 src 到 dst 48 os.renames(old, new) 递归地对目录进行更名，也可以对文件进行更名。 49 os.rmdir(path) 删除path指定的空目录，如果目录非空，则抛出一个OSError异常。 50 os.stat(path) 获取path指定的路径的信息，功能等同于C API中的stat()系统调用。 51 [os.stat_float_times(newvalue]) 决定stat_result是否以float对象显示时间戳 52 os.statvfs(path) 获取指定路径的文件系统统计信息 53 os.symlink(src, dst) 创建一个软链接 54 os.tcgetpgrp(fd) 返回与终端fd（一个由os.open()返回的打开的文件描述符）关联的进程组 55 os.tcsetpgrp(fd, pg) 设置与终端fd（一个由os.open()返回的打开的文件描述符）关联的进程组为pg。 56 os.tempnam([dir[, prefix]]) Python3 中已删除。返回唯一的路径名用于创建临时文件。 57 os.tmpfile() Python3 中已删除。返回一个打开的模式为(w+b)的文件对象 .这文件对象没有文件夹入口，没有文件描述符，将会自动删除。 58 os.tmpnam() Python3 中已删除。为创建一个临时文件返回一个唯一的路径 59 os.ttyname(fd) 返回一个字符串，它表示与文件描述符fd 关联的终端设备。如果fd 没有与终端设备关联，则引发一个异常。 60 os.unlink(path) 删除文件路径 61 os.utime(path, times) 返回指定的path文件的访问和修改的时间。 62 [os.walk(top[, topdown=True[, onerror=None[, followlinks=False]]])](https://www.runoob.com/python3/python3-os-walk.html) 输出在文件夹中的文件名通过在树中游走，向上或者向下。 63 os.write(fd, str) 写入字符串到文件描述符 fd中. 返回实际写入的字符串长度 64 os.path 模块 获取文件的属性信息。 65 os.pardir() 获取当前目录的父目录，以字符串形式显示目录名。 错误与异常处理 语法错误 - 语法分析器检测到错误 异常 -运行期检测到的错误 异常处理 try/except 以下例子中，让用户输入一个合法的整数，但是允许用户中断这个程序（使用 Control-C 或者操作系统提供的方法）。用户中断的信息会引发一个 KeyboardInterrupt 异常。 123456while True: try: x = int(input(&quot;请输入一个数字: &quot;)) break except ValueError: print(&quot;您输入的不是数字，请再次尝试输入！&quot;) try 语句按照如下方式工作； 首先，执行 try 子句（在关键字 try 和关键字 except 之间的语句）。 如果没有异常发生，忽略 except 子句，try 子句执行后结束。 如果在执行 try 子句的过程中发生了异常，那么 try 子句余下的部分将被忽略。如果异常的类型和 except 之后的名称相符，那么对应的 except 子句将被执行。 如果一个异常没有与任何的 except 匹配，那么这个异常将会传递给上层的 try 中。 一个 try 语句可能包含多个except子句，分别来处理不同的特定的异常。最多只有一个分支会被执行。 处理程序将只针对对应的 try 子句中的异常进行处理，而不是其他的 try 的处理程序中的异常。 一个except子句可以同时处理多个异常，这些异常将被放在一个括号里成为一个元组，例如: 12except (RuntimeError, TypeError, NameError): pass 最后一个except子句可以忽略异常的名称，它将被当作通配符使用。你可以使用这种方法打印一个错误信息，然后再次把异常抛出。 12345678910111213import systry: f = open(&#x27;myfile.txt&#x27;) s = f.readline() i = int(s.strip())except OSError as err: print(&quot;OS error: &#123;0&#125;&quot;.format(err))except ValueError: print(&quot;Could not convert data to an integer.&quot;)except: print(&quot;Unexpected error:&quot;, sys.exc_info()[0]) raise try/except…else try/except 语句还有一个可选的 else 子句，如果使用这个子句，那么必须放在所有的 except 子句之后。 else 子句将在 try 子句没有发生任何异常的时候执行。 12345678for arg in sys.argv[1:]: try: f = open(arg, &#x27;r&#x27;) except IOError: print(&#x27;cannot open&#x27;, arg) else: print(arg, &#x27;has&#x27;, len(f.readlines()), &#x27;lines&#x27;) f.close() 使用 else 子句比把所有的语句都放在 try 子句里面要好，这样可以避免一些意想不到，而 except 又无法捕获的异常。 异常处理并不仅仅处理那些直接发生在 try 子句中的异常，而且还能处理子句中调用的函数（甚至间接调用的函数）里抛出的异常。例如: 12345678&gt;&gt;&gt; def this_fails(): x = 1/0&gt;&gt;&gt; try: this_fails() except ZeroDivisionError as err: print(&#x27;Handling run-time error:&#x27;, err) Handling run-time error: int division or modulo by zero try-finally try-finally 语句无论是否发生异常都将执行最后的代码。 123456789101112try: runoob()except AssertionError as error: print(error)else: try: with open(&#x27;file.log&#x27;) as file: read_data = file.read() except FileNotFoundError as fnf_error: print(fnf_error)finally: print(&#x27;这句话，无论异常是否发生都会执行。&#x27;) ​ 抛出异常 Python 使用 raise 语句抛出一个指定的异常。 raise语法格式如下： 1raise [Exception [, args [, traceback]]] 123456789x = 10if x &gt; 5: raise Exception(&#x27;x 不能大于 5。x 的值为: &#123;&#125;&#x27;.format(x))执行以上代码会触发异常：Traceback (most recent call last): File &quot;test.py&quot;, line 3, in &lt;module&gt; raise Exception(&#x27;x 不能大于 5。x 的值为: &#123;&#125;&#x27;.format(x))Exception: x 不能大于 5。x 的值为: 10 raise 唯一的一个参数指定了要被抛出的异常。它必须是一个异常的实例或者是异常的类（也就是 Exception 的子类）。 如果你只想知道这是否抛出了一个异常，并不想去处理它，那么一个简单的 raise 语句就可以再次把它抛出。 1234567891011&gt;&gt;&gt; try: raise NameError(&#x27;HiThere&#x27;) except NameError: print(&#x27;An exception flew by!&#x27;) raise An exception flew by!Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 2, in ?NameError: HiThere 理解： 用户自定义异常 创建一个新的异常类来拥有自己的异常。异常类继承自 Exception 类，可以直接继承，或者间接继承，例如: 12345678910111213141516&gt;&gt;&gt; class MyError(Exception): def __init__(self, value): self.value = value def __str__(self): return repr(self.value) &gt;&gt;&gt; try: raise MyError(2*2) except MyError as e: print(&#x27;My exception occurred, value:&#x27;, e.value) My exception occurred, value: 4&gt;&gt;&gt; raise MyError(&#x27;oops!&#x27;)Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in ?__main__.MyError: &#x27;oops!&#x27; 当创建一个模块有可能抛出多种不同的异常时，一种通常的做法是为这个包建立一个基础异常类，然后基于这个基础类为不同的错误情况创建不同的子类: 123456789101112131415161718192021222324252627282930class Error(Exception): &quot;&quot;&quot;Base class for exceptions in this module.&quot;&quot;&quot; passclass InputError(Error): &quot;&quot;&quot;Exception raised for errors in the input. Attributes: expression -- input expression in which the error occurred message -- explanation of the error &quot;&quot;&quot; def __init__(self, expression, message): self.expression = expression self.message = messageclass TransitionError(Error): &quot;&quot;&quot;Raised when an operation attempts a state transition that&#x27;s not allowed. Attributes: previous -- state at beginning of transition next -- attempted new state message -- explanation of why the specific transition is not allowed &quot;&quot;&quot; def __init__(self, previous, next, message): self.previous = previous self.next = next self.message = message 定义清理行为 try 语句还有另外一个可选的子句，它定义了无论在任何情况下都会执行的清理行为。 例如: 123456789&gt;&gt;&gt; try:... raise KeyboardInterrupt... finally:... print(&#x27;Goodbye, world!&#x27;)...Goodbye, world!Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 2, in &lt;module&gt;KeyboardInterrupt 以上例子不管 try 子句里面有没有发生异常，finally 子句都会执行。 如果一个异常在 try 子句里（或者在 except 和 else 子句里）被抛出，而又没有任何的 except 把它截住，那么这个异常会在 finally 子句执行后被抛出。 12345678910111213141516171819202122&gt;&gt;&gt; def divide(x, y): try: result = x / y except ZeroDivisionError: print(&quot;division by zero!&quot;) else: print(&quot;result is&quot;, result) finally: print(&quot;executing finally clause&quot;) &gt;&gt;&gt; divide(2, 1)result is 2.0executing finally clause&gt;&gt;&gt; divide(2, 0)division by zero!executing finally clause&gt;&gt;&gt; divide(&quot;2&quot;, &quot;1&quot;)executing finally clauseTraceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in ? File &quot;&lt;stdin&gt;&quot;, line 3, in divideTypeError: unsupported operand type(s) for /: &#x27;str&#x27; and &#x27;str&#x27; 预定义的清理行为 一些对象定义了标准的清理行为，无论系统是否成功的使用了它，一旦不需要它了，那么这个标准的清理行为就会执行。 这面这个例子展示了尝试打开一个文件，然后把内容打印到屏幕上: 12for line in open(&quot;myfile.txt&quot;): print(line, end=&quot;&quot;) 以上这段代码的问题是，当执行完毕后，文件会保持打开状态，并没有被关闭。 关键词 with 语句就可以保证诸如文件之类的对象在使用完之后一定会正确的执行他的清理方法: 123with open(&quot;myfile.txt&quot;) as f: for line in f: print(line, end=&quot;&quot;) 以上这段代码执行完毕后，就算在处理过程中出问题了，文件 f 总是会关闭。 面向对象 类(Class): 用来描述具有相同的属性和方法的对象的集合。它定义了该集合中每个对象所共有的属性和方法。对象是类的实例。 方法：类中定义的函数。 类变量：类变量在整个实例化的对象中是公用的。类变量定义在类中且在函数体之外。类变量通常不作为实例变量使用。 数据成员：类变量或者实例变量用于处理类及其实例对象的相关的数据。 方法重写：如果从父类继承的方法不能满足子类的需求，可以对其进行改写，这个过程叫方法的覆盖（override），也称为方法的重写。 局部变量：定义在方法中的变量，只作用于当前实例的类。 实例变量：在类的声明中，属性是用变量来表示的，这种变量就称为实例变量，实例变量就是一个用 self 修饰的变量。 继承：即一个派生类（derived class）继承基类（base class）的字段和方法。继承也允许把一个派生类的对象作为一个基类对象对待。例如，有这样一个设计：一个Dog类型的对象派生自Animal类，这是模拟”是一个（is-a）”关系（例图，Dog是一个Animal）。 实例化：创建一个类的实例，类的具体对象。 对象：通过类定义的数据结构实例。对象包括两个数据成员（类变量和实例变量）和方法。 和其它编程语言相比，Python 在尽可能不增加新的语法和语义的情况下加入了类机制。 Python中的类提供了面向对象编程的所有基本功能：类的继承机制允许多个基类，派生类可以覆盖基类中的任何方法，方法中可以调用基类中的同名方法。 对象可以包含任意数量和类型的数据。 类定义 123456class ClassName: &lt;statement-1&gt; . . . &lt;statement-N&gt; 类实例化后，可以使用其属性，实际上，创建一个类之后，可以通过类名访问其属性。 类对象 类对象支持两种操作：属性引用和实例化。 属性引用使用和 Python 中所有的属性引用一样的标准语法：obj.name。 类对象创建后，类命名空间中所有的命名都是有效属性名。所以如果类定义是这样: 1234567891011121314#!/usr/bin/python3 class MyClass: &quot;&quot;&quot;一个简单的类实例&quot;&quot;&quot; i = 12345 def f(self): return &#x27;hello world&#x27; # 实例化类x = MyClass() # 访问类的属性和方法print(&quot;MyClass 类的属性 i 为：&quot;, x.i)print(&quot;MyClass 类的方法 f 输出为：&quot;, x.f()) 类有一个名为 init() 的特殊方法（构造方法），该方法在类实例化时会自动调用，像下面这样： 12def __init__(self): self.data = [] self是类的一个实例，而非类 类的方法与普通的函数只有一个特别的区别——它们必须有一个额外的第一个参数名称, 按照惯例它的名称是 self。 1234567891011class Test: def prt(self): print(self) print(self.__class__) t = Test()t.prt()以上实例执行结果为：&lt;__main__.Test instance at 0x100771878&gt;__main__.Test 从执行结果可以很明显的看出，self 代表的是类的实例，代表当前对象的地址，而 self.class 则指向类。 self 不是 python 关键字，我们把他换成 runoob 也是可以正常执行的: 123456class Test: def prt(runoob): print(runoob) print(runoob.__class__) t = Test() t.prt() 以上实例执行结果为： 12&lt;__main__.Test instance at 0x100771878&gt;__main__.Test 类方法 在类的内部，使用 def 关键字来定义一个方法，与一般函数定义不同，类方法必须包含参数 self, 且为第一个参数，self 代表的是类的实例。 123456789101112131415161718192021#类定义class people: #定义基本属性 name = &#x27;&#x27; age = 0 #定义私有属性,私有属性在类外部无法直接进行访问 __weight = 0 #定义构造方法 def __init__(self,n,a,w): self.name = n self.age = a self.__weight = w def speak(self): print(&quot;%s 说: 我 %d 岁。&quot; %(self.name,self.age)) # 实例化类p = people(&#x27;runoob&#x27;,10,30)p.speak()执行以上程序输出结果为：runoob 说: 我 10 岁。 继承 Python 同样支持类的继承，如果一种语言不支持继承，类就没有什么意义。派生类的定义如下所示: 123456class DerivedClassName(BaseClassName): &lt;statement-1&gt; . . . &lt;statement-N&gt; 子类（派生类 DerivedClassName）会继承父类（基类 BaseClassName）的属性和方法。 BaseClassName（实例中的基类名）必须与派生类定义在一个作用域内。除了类，还可以用表达式，基类定义在另一个模块中时这一点非常有用: 1class DerivedClassName(modname.BaseClassName): 1234567891011121314151617181920212223242526272829303132333435#!/usr/bin/python3 #类定义class people: #定义基本属性 name = &#x27;&#x27; age = 0 #定义私有属性,私有属性在类外部无法直接进行访问 __weight = 0 #定义构造方法 def __init__(self,n,a,w): self.name = n self.age = a self.__weight = w def speak(self): print(&quot;%s 说: 我 %d 岁。&quot; %(self.name,self.age)) #单继承示例class student(people): grade = &#x27;&#x27; def __init__(self,n,a,w,g): #调用父类的构函 people.__init__(self,n,a,w) self.grade = g #覆写父类的方法 def speak(self): print(&quot;%s 说: 我 %d 岁了，我在读 %d 年级&quot;%(self.name,self.age,self.grade)) s = student(&#x27;ken&#x27;,10,60,3)s.speak()执行以上程序输出结果为：ken 说: 我 10 岁了，我在读 3 年级 多继承 Python同样有限的支持多继承形式。多继承的类定义形如下例: 123456class DerivedClassName(Base1, Base2, Base3): &lt;statement-1&gt; . . . &lt;statement-N&gt; 需要注意圆括号中父类的顺序，若是父类中有相同的方法名，而在子类使用时未指定，python从左至右搜索 即方法在子类中未找到时，从左到右查找父类中是否包含方法。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#类定义class people: #定义基本属性 name = &#x27;&#x27; age = 0 #定义私有属性,私有属性在类外部无法直接进行访问 __weight = 0 #定义构造方法 def __init__(self,n,a,w): self.name = n self.age = a self.__weight = w def speak(self): print(&quot;%s 说: 我 %d 岁。&quot; %(self.name,self.age)) #单继承示例class student(people): grade = &#x27;&#x27; def __init__(self,n,a,w,g): #调用父类的构函 people.__init__(self,n,a,w) self.grade = g #覆写父类的方法 def speak(self): print(&quot;%s 说: 我 %d 岁了，我在读 %d 年级&quot;%(self.name,self.age,self.grade)) #另一个类，多重继承之前的准备class speaker(): topic = &#x27;&#x27; name = &#x27;&#x27; def __init__(self,n,t): self.name = n self.topic = t def speak(self): print(&quot;我叫 %s，我是一个演说家，我演讲的主题是 %s&quot;%(self.name,self.topic)) #多重继承class sample(speaker,student): a =&#x27;&#x27; def __init__(self,n,a,w,g,t): student.__init__(self,n,a,w,g) speaker.__init__(self,n,t) test = sample(&quot;Tim&quot;,25,80,4,&quot;Python&quot;)test.speak() #方法名同，默认调用的是在括号中参数位置排前父类的方法执行以上程序输出结果为：我叫 Tim，我是一个演说家，我演讲的主题是 Python 方法重写 如果你的父类方法的功能不能满足你的需求，你可以在子类重写你父类的方法，实例如下： 12345678910111213141516#!/usr/bin/python3 class Parent: # 定义父类 def myMethod(self): print (&#x27;调用父类方法&#x27;) class Child(Parent): # 定义子类 def myMethod(self): print (&#x27;调用子类方法&#x27;) c = Child() # 子类实例c.myMethod() # 子类调用重写方法super(Child,c).myMethod() #用子类对象调用父类已被覆盖的方法执行以上程序输出结果为：调用子类方法调用父类方法 类属性与方法 私有属性 __private_attrs：两个下划线开头，声明该属性为私有，不能在类的外部被使用或直接访问。在类内部的方法中使用时 self.__private_attrs。 12345678910111213141516171819202122232425#!/usr/bin/python3 class JustCounter: __secretCount = 0 # 私有变量 publicCount = 0 # 公开变量 def count(self): self.__secretCount += 1 self.publicCount += 1 print (self.__secretCount) counter = JustCounter()counter.count()counter.count()print (counter.publicCount)print (counter.__secretCount) # 报错，实例不能访问私有变量执行以上程序输出结果为：122Traceback (most recent call last): File &quot;test.py&quot;, line 16, in &lt;module&gt; print (counter.__secretCount) # 报错，实例不能访问私有变量AttributeError: &#x27;JustCounter&#x27; object has no attribute &#x27;__secretCount&#x27; 类的方法 在类的内部，使用 def 关键字来定义一个方法，与一般函数定义不同，类方法必须包含参数 self，且为第一个参数，self 代表的是类的实例。 self 的名字并不是规定死的，也可以使用 this，但是最好还是按照约定使用 self。 私有方法 __private_method：两个下划线开头，声明该方法为私有方法，只能在类的内部调用 ，不能在类的外部调用。self.__private_methods。 123456789101112131415161718192021class Site: def __init__(self, name, url): self.name = name # public self.__url = url # private def who(self): print(&#x27;name : &#x27;, self.name) print(&#x27;url : &#x27;, self.__url) def __foo(self): # 私有方法 print(&#x27;这是私有方法&#x27;) def foo(self): # 公共方法 print(&#x27;这是公共方法&#x27;) self.__foo() x = Site(&#x27;菜鸟教程&#x27;, &#x27;www.runoob.com&#x27;)x.who() # 正常输出x.foo() # 正常输出x.__foo() # 报错 专有方法 1234567891011121314__init__ : 构造函数，在生成对象时调用__del__ : 析构函数，释放对象时使用__repr__ : 打印，转换__setitem__ : 按照索引赋值__getitem__: 按照索引获取值__len__: 获得长度__cmp__: 比较运算__call__: 函数调用__add__: 加运算__sub__: 减运算__mul__: 乘运算__truediv__: 除运算__mod__: 求余运算__pow__: 乘方 运算符重载 1234567891011121314151617class Vector: def __init__(self, a, b): self.a = a self.b = b def __str__(self): return &#x27;Vector (%d, %d)&#x27; % (self.a, self.b) def __add__(self,other): return Vector(self.a + other.a, self.b + other.b) v1 = Vector(2,10)v2 = Vector(5,-2)print (v1 + v2)以上代码执行结果如下所示:Vector(7,8) 命名空间/作用域命名空间(Namespace)是从名称到对象的映射，大部分的命名空间都是通过 Python 字典来实现的。 命名空间提供了在项目中避免名字冲突的一种方法。各个命名空间是独立的，没有任何关系的，所以一个命名空间中不能有重名，但不同的命名空间是可以重名而没有任何影响。 一般有三种命名空间： 内置名称（built-in names）， Python 语言内置的名称，比如函数名 abs、char 和异常名称 BaseException、Exception 等等。 全局名称（global names），模块中定义的名称，记录了模块的变量，包括函数、类、其它导入的模块、模块级的变量和常量。 局部名称（local names），函数中定义的名称，记录了函数的变量，包括函数的参数和局部定义的变量。（类中定义的也是） 命名空间查找顺序: 假设我们要使用变量 runoob，则 Python 的查找顺序为：局部的命名空间去 -&gt; 全局命名空间 -&gt; 内置命名空间。 如果找不到变量 runoob，它将放弃查找并引发一个 NameError 异常: 1NameError: name &#x27;runoob&#x27; is not defined。 命名空间的生命周期： 命名空间的生命周期取决于对象的作用域，如果对象执行完成，则该命名空间的生命周期就结束。 因此，我们无法从外部命名空间访问内部命名空间的对象。 作用域 作用域就是一个 Python 程序可以直接访问命名空间的正文区域。 在一个 python 程序中，直接访问一个变量，会从内到外依次访问所有的作用域直到找到，否则会报未定义的错误。 Python 中，程序的变量并不是在哪个位置都可以访问的，访问权限决定于这个变量是在哪里赋值的。 变量的作用域决定了在哪一部分程序可以访问哪个特定的变量名称。Python 的作用域一共有4种，分别是： 有四种作用域： L（Local）：最内层，包含局部变量，比如一个函数/方法内部。 E（Enclosing）：包含了非局部(non-local)也非全局(non-global)的变量。比如两个嵌套函数，一个函数（或类） A 里面又包含了一个函数 B ，那么对于 B 中的名称来说 A 中的作用域就为 nonlocal。 G（Global）：当前脚本的最外层，比如当前模块的全局变量。 B（Built-in）： 包含了内建的变量/关键字等，最后被搜索。 规则顺序： L –&gt; E –&gt; G –&gt; B。 在局部找不到，便会去局部外的局部找（例如闭包），再找不到就会去全局找，再者去内置中找。 全局和局部变量 定义在函数内部的变量拥有一个局部作用域，定义在函数外的拥有全局作用域。 局部变量只能在其被声明的函数内部访问，而全局变量可以在整个程序范围内访问。调用函数时，所有在函数内声明的变量名称都将被加入到作用域中。 global 和nolocal 关键字 当内部作用域想修改外部作用域的变量时，就要用到 global 和 nonlocal 关键字了 12345678910111213num = 1def fun1(): global num # 需要使用 global 关键字声明 print(num) num = 123 print(num)fun1()print(num)以上实例输出结果：1123123 如果要修改嵌套作用域（enclosing 作用域，外层非全局作用域）中的变量则需要 nonlocal 关键字了 12345678910111213def outer(): num = 10 def inner(): nonlocal num # nonlocal关键字声明 num = 100 print(num) inner() print(num)outer()以上实例输出结果：100100 标准库 二、高级 正则表达式 正则表达式是一个特殊的字符序列，它能帮助你方便的检查一个字符串是否与某种模式匹配。 Python 自1.5版本起增加了re 模块，它提供 Perl 风格的正则表达式模式。 re 模块使 Python 语言拥有全部的正则表达式功能。 compile 函数根据一个模式字符串和可选的标志参数生成一个正则表达式对象。该对象拥有一系列方法用于正则表达式匹配和替换。 re 模块也提供了与这些方法功能完全一致的函数，这些函数使用一个模式字符串做为它们的第一个参数。 匹配字符串 re.match() 函数 re.match 尝试从字符串的起始位置匹配一个模式，匹配成功re.match方法返回一个匹配的对象，否则返回None。 1re.match(pattern, string, flags=0) 参数 描述 pattern 匹配的正则表达式 string 要匹配的字符串。 flags 标志位，用于控制正则表达式的匹配方式，如：是否区分大小写，多行匹配等等。参见：正则表达式修饰符 - 可选标志 re.search() re.search 扫描整个字符串并返回第一个成功的匹配。匹配成功re.search方法返回一个匹配的对象，否则返回None。 re.match 只匹配字符串的开始，如果字符串开始不符合正则表达式，则匹配失败，函数返回 None，而 re.search 匹配整个字符串，直到找到一个匹配。 检索替换 re.sub() Python 的re模块提供了re.sub用于替换字符串中的匹配项。 语法： 1re.sub(pattern, repl, string, count=0, flags=0) pattern : 正则中的模式字符串。 repl : 替换的字符串，也可为一个函数。 string : 要被查找替换的原始字符串。 count : 模式匹配后替换的最大次数，默认 0 表示替换所有的匹配。 flags : 编译时用的匹配模式，数字形式。 CGI编程 MySql(mysql-connector) MySql(pymysql) 网络编程 Python 提供了两个级别访问的网络服务。： 低级别的网络服务支持基本的 Socket，它提供了标准的 BSD Sockets API，可以访问底层操作系统Socket接口的全部方法。 高级别的网络服务模块 SocketServer， 它提供了服务器中心类，可以简化网络服务器的开发。 什么是socket? Socket又称”套接字”，应用程序通常通过”套接字”向网络发出请求或者应答网络请求，使主机间或者一台计算机上的进程间可以通讯。 socket()函数 123我们用 socket() 函数来创建套接字，语法格式如下：socket.socket([family[, type[, proto]]]) family: 套接字家族可以是 AF_UNIX 或者 AF_INET type: 套接字类型可以根据是面向连接的还是非连接分为SOCK_STREAM或SOCK_DGRAM protocol: 一般不填默认为0. 函数 描述 服务器端套接字 s.bind() 绑定地址（host,port）到套接字， 在AF_INET下,以元组（host,port）的形式表示地址。 s.listen() 开始TCP监听。backlog指定在拒绝连接之前，操作系统可以挂起的最大连接数量。该值至少为1，大部分应用程序设为5就可以了。 s.accept() 被动接受TCP客户端连接,(阻塞式)等待连接的到来 客户端套接字 s.connect() 主动初始化TCP服务器连接，。一般address的格式为元组（hostname,port），如果连接出错，返回socket.error错误。 s.connect_ex() connect()函数的扩展版本,出错时返回出错码,而不是抛出异常 公共用途的套接字函数 s.recv() 接收TCP数据，数据以字符串形式返回，bufsize指定要接收的最大数据量。flag提供有关消息的其他信息，通常可以忽略。 s.send() 发送TCP数据，将string中的数据发送到连接的套接字。返回值是要发送的字节数量，该数量可能小于string的字节大小。 s.sendall() 完整发送TCP数据，完整发送TCP数据。将string中的数据发送到连接的套接字，但在返回之前会尝试发送所有数据。成功返回None，失败则抛出异常。 s.recvfrom() 接收UDP数据，与recv()类似，但返回值是（data,address）。其中data是包含接收数据的字符串，address是发送数据的套接字地址。 s.sendto() 发送UDP数据，将数据发送到套接字，address是形式为（ipaddr，port）的元组，指定远程地址。返回值是发送的字节数。 s.close() 关闭套接字 s.getpeername() 返回连接套接字的远程地址。返回值通常是元组（ipaddr,port）。 s.getsockname() 返回套接字自己的地址。通常是一个元组(ipaddr,port) s.setsockopt(level,optname,value) 设置给定套接字选项的值。 s.getsockopt(level,optname[.buflen]) 返回套接字选项的值。 s.settimeout(timeout) 设置套接字操作的超时期，timeout是一个浮点数，单位是秒。值为None表示没有超时期。一般，超时期应该在刚创建套接字时设置，因为它们可能用于连接的操作（如connect()） s.gettimeout() 返回当前超时期的值，单位是秒，如果没有设置超时期，则返回None。 s.fileno() 返回套接字的文件描述符。 s.setblocking(flag) 如果 flag 为 False，则将套接字设为非阻塞模式，否则将套接字设为阻塞模式（默认值）。非阻塞模式下，如果调用 recv() 没有发现任何数据，或 send() 调用无法立即发送数据，那么将引起 socket.error 异常。 s.makefile() 创建一个与该套接字相关连的文件 实例 服务端 我们使用 socket 模块的 socket 函数来创建一个 socket 对象。socket 对象可以通过调用其他函数来设置一个 socket 服务。 现在我们可以通过调用 bind(hostname, port) 函数来指定服务的 *port(端口)*。 接着，我们调用 socket 对象的 accept 方法。该方法等待客户端的连接，并返回 connection 对象，表示已连接到客户端 12345678910111213141516171819202122232425262728293031#!/usr/bin/python3# 文件名：server.py# 导入 socket、sys 模块import socketimport sys# 创建 socket 对象serversocket = socket.socket( socket.AF_INET, socket.SOCK_STREAM)# 获取本地主机名host = socket.gethostname()port = 9999# 绑定端口号serversocket.bind((host, port))# 设置最大连接数，超过后排队serversocket.listen(5)while True: # 建立客户端连接 clientsocket,addr = serversocket.accept() print(&quot;连接地址: %s&quot; % str(addr)) msg=&#x27;欢迎访问菜鸟教程！&#x27;+ &quot;\\r\\n&quot; clientsocket.send(msg.encode(&#x27;utf-8&#x27;)) clientsocket.close() 客户端 接下来我们写一个简单的客户端实例连接到以上创建的服务。端口号为 9999。 socket.connect(hostname, port ) 方法打开一个 TCP 连接到主机为 hostname 端口为 port 的服务商。连接后我们就可以从服务端获取数据，记住，操作完成后需要关闭连接。 12345678910111213141516171819202122232425#!/usr/bin/python3# 文件名：client.py# 导入 socket、sys 模块import socketimport sys# 创建 socket 对象s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)# 获取本地主机名host = socket.gethostname()# 设置端口号port = 9999# 连接服务，指定主机和端口s.connect((host, port))# 接收小于 1024 字节的数据msg = s.recv(1024)s.close()print (msg.decode(&#x27;utf-8&#x27;)) 现在我们打开两个终端，第一个终端执行 server.py 文件： 1$ python3 server.py 第二个终端执行 client.py 文件： 12$ python3 client.py 欢迎访问菜鸟教程！ 这时我们再打开第一个终端，就会看到有以下信息输出： 1连接地址： (&#x27;192.168.0.118&#x27;, 33397) python Internet模块 以下列出了 Python 网络编程的一些重要模块： 协议 功能用处 端口号 Python 模块 HTTP 网页访问 80 httplib, urllib, xmlrpclib NNTP 阅读和张贴新闻文章，俗称为”帖子” 119 nntplib FTP 文件传输 20 ftplib, urllib SMTP 发送邮件 25 smtplib POP3 接收邮件 110 poplib IMAP4 获取邮件 143 imaplib Telnet 命令行 23 telnetlib Gopher 信息查找 70 gopherlib, urllib SMTP发送发送邮件 多线程 多线程类似于同时执行多个不同程序，多线程运行有如下优点： 使用线程可以把占据长时间的程序中的任务放到后台去处理。 用户界面可以更加吸引人，比如用户点击了一个按钮去触发某些事件的处理，可以弹出一个进度条来显示处理的进度。 程序的运行速度可能加快。 在一些等待的任务实现上如用户输入、文件读写和网络收发数据等，线程就比较有用了。在这种情况下我们可以释放一些珍贵的资源如内存占用等等。 每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口。但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。 每个线程都有他自己的一组CPU寄存器，称为线程的上下文，该上下文反映了线程上次运行该线程的CPU寄存器的状态。 指令指针和堆栈指针寄存器是线程上下文中两个最重要的寄存器，线程总是在进程得到上下文中运行的，这些地址都用于标志拥有线程的进程地址空间中的内存。 线程可以被抢占（中断）。 在其他线程正在运行时，线程可以暂时搁置（也称为睡眠） – 这就是线程的退让。 线程可以分为: 内核线程：由操作系统内核创建和撤销。 用户线程：不需要内核支持而在用户程序中实现的线程。 Python3 线程中常用的两个模块为： _thread threading(推荐使用) thread 模块已被废弃。用户可以使用 threading 模块代替。所以，在 Python3 中不能再使用”thread” 模块。为了兼容性，Python3 将 thread 重命名为 “_thread”。 Python中使用线程有两种方式：函数或者用类来包装线程对象。 函数式：调用 _thread 模块中的start_new_thread()函数来产生新线程。语法如下: 1_thread.start_new_thread ( function, args[, kwargs] ) 参数说明: function - 线程函数。 args - 传递给线程函数的参数,他必须是个tuple类型。 kwargs - 可选参数。 实例 1234567891011121314151617181920212223242526272829303132333435#!/usr/bin/python3import _threadimport time# 为线程定义一个函数def print_time( threadName, delay): count = 0 while count &lt; 5: time.sleep(delay) count += 1 print (&quot;%s: %s&quot; % ( threadName, time.ctime(time.time()) ))# 创建两个线程try: _thread.start_new_thread( print_time, (&quot;Thread-1&quot;, 2, ) ) _thread.start_new_thread( print_time, (&quot;Thread-2&quot;, 4, ) )except: print (&quot;Error: 无法启动线程&quot;)while 1: pass执行以上程序输出结果如下：Thread-1: Wed Jan 5 17:38:08 2022Thread-2: Wed Jan 5 17:38:10 2022Thread-1: Wed Jan 5 17:38:10 2022Thread-1: Wed Jan 5 17:38:12 2022Thread-2: Wed Jan 5 17:38:14 2022Thread-1: Wed Jan 5 17:38:14 2022Thread-1: Wed Jan 5 17:38:16 2022Thread-2: Wed Jan 5 17:38:18 2022Thread-2: Wed Jan 5 17:38:22 2022Thread-2: Wed Jan 5 17:38:26 2022执行以上程后可以按下 ctrl-c 退出。 线程模块 Python3 通过两个标准库 _thread 和 threading 提供对线程的支持。 _thread 提供了低级别的、原始的线程以及一个简单的锁，它相比于 threading 模块的功能还是比较有限的。 threading 模块除了包含 _thread 模块中的所有方法外，还提供的其他方法： threading.currentThread(): 返回当前的线程变量。 threading.enumerate(): 返回一个包含正在运行的线程的list。正在运行指线程启动后、结束前，不包括启动前和终止后的线程。 threading.activeCount(): 返回正在运行的线程数量，与len(threading.enumerate())有相同的结果。 除了使用方法外，线程模块同样提供了Thread类来处理线程，Thread类提供了以下方法: run(): 用以表示线程活动的方法。 start(): 启动线程活动。 join([time]): 等待至线程中止。这阻塞调用线程直至线程的join() 方法被调用中止-正常退出或者抛出未处理的异常-或者是可选的超时发生。 isAlive(): 返回线程是否活动的。 getName(): 返回线程名。 setName(): 设置线程名。 使用threading 模块创建线程 直接从 threading.Thread 继承创建一个新的子类，并实例化后调用 start() 方法启动新线程，即它调用了线程的 run() 方法： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051import threadingimport timeexitFlag = 0class myThread (threading.Thread): def __init__(self, threadID, name, delay): threading.Thread.__init__(self) self.threadID = threadID self.name = name self.delay = delay def run(self): print (&quot;开始线程：&quot; + self.name) print_time(self.name, self.delay, 5) print (&quot;退出线程：&quot; + self.name)def print_time(threadName, delay, counter): while counter: if exitFlag: threadName.exit() time.sleep(delay) print (&quot;%s: %s&quot; % (threadName, time.ctime(time.time()))) counter -= 1# 创建新线程thread1 = myThread(1, &quot;Thread-1&quot;, 1)thread2 = myThread(2, &quot;Thread-2&quot;, 2)# 开启新线程thread1.start()thread2.start()thread1.join()thread2.join()print (&quot;退出主线程&quot;)以上程序执行结果如下；开始线程：Thread-1开始线程：Thread-2Thread-1: Wed Jan 5 17:34:54 2022Thread-2: Wed Jan 5 17:34:55 2022Thread-1: Wed Jan 5 17:34:55 2022Thread-1: Wed Jan 5 17:34:56 2022Thread-2: Wed Jan 5 17:34:57 2022Thread-1: Wed Jan 5 17:34:57 2022Thread-1: Wed Jan 5 17:34:58 2022退出线程：Thread-1Thread-2: Wed Jan 5 17:34:59 2022Thread-2: Wed Jan 5 17:35:01 2022Thread-2: Wed Jan 5 17:35:03 2022退出线程：Thread-2退出主线程 线程同步 如果多个线程共同对某个数据修改，则可能出现不可预料的结果，为了保证数据的正确性，需要对多个线程进行同步。 使用 Thread 对象的 Lock 和 Rlock 可以实现简单的线程同步，这两个对象都有 acquire 方法和 release 方法，对于那些需要每次只允许一个线程操作的数据，可以将其操作放到 acquire 和 release 方法之间。如下： 多线程的优势在于可以同时运行多个任务（至少感觉起来是这样）。但是当线程需要共享数据时，可能存在数据不同步的问题。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253import threadingimport timeclass myThread (threading.Thread): def __init__(self, threadID, name, delay): threading.Thread.__init__(self) self.threadID = threadID self.name = name self.delay = delay def run(self): print (&quot;开启线程： &quot; + self.name) # 获取锁，用于线程同步 threadLock.acquire() print_time(self.name, self.delay, 3) # 释放锁，开启下一个线程 threadLock.release()def print_time(threadName, delay, counter): while counter: time.sleep(delay) print (&quot;%s: %s&quot; % (threadName, time.ctime(time.time()))) counter -= 1threadLock = threading.Lock()threads = []# 创建新线程thread1 = myThread(1, &quot;Thread-1&quot;, 1)thread2 = myThread(2, &quot;Thread-2&quot;, 2)# 开启新线程thread1.start()thread2.start()# 添加线程到线程列表threads.append(thread1)threads.append(thread2)# 等待所有线程完成for t in threads: t.join()print (&quot;退出主线程&quot;)执行以上程序，输出结果为：开启线程： Thread-1开启线程： Thread-2Thread-1: Wed Jan 5 17:36:50 2022Thread-1: Wed Jan 5 17:36:51 2022Thread-1: Wed Jan 5 17:36:52 2022Thread-2: Wed Jan 5 17:36:54 2022Thread-2: Wed Jan 5 17:36:56 2022Thread-2: Wed Jan 5 17:36:58 2022退出主线程W 线程优先级队列（Queue） XML解析 JSON 日期时间 内置函数 MongoDB urllib uWSGI 安装配置 pip","categories":[{"name":"Python","slug":"Python","permalink":"https://hxlpub.github.io/categories/Python/"}],"tags":[{"name":"python","slug":"python","permalink":"https://hxlpub.github.io/tags/python/"}]},{"title":"编译","slug":"compiler","date":"2021-09-14T09:26:07.000Z","updated":"2022-06-29T14:03:49.674Z","comments":true,"path":"2021/09/14/compiler/","link":"","permalink":"https://hxlpub.github.io/2021/09/14/compiler/","excerpt":"","text":"CompilergccGCC原名为GNU C语言编译器（GNU C Compiler），只能处理C语言。但其很快扩展，变得可处理C++，后来又扩展为能够支持更多编程语言，如Fortran、Pascal、Objective -C、Java、Ada、Go以及各类处理器架构上的汇编语言等，所以改名GNU编译器套件（GNU Compiler Collection）。 ​ 虽然我们称GCC是C语言的编译器，但使用gcc由C语言源代码文件生成可执行文件的过程不仅仅是编译的过程，而是要经历四个相互关联的步骤∶ ​ 预处理（也称预编译，Preprocessing） ​ 编译（Compilation） ​ 汇编（Assembly） ​ 链接（Linking） 参数https://gcc.gnu.org/onlinedocs/gcc/Option-Summary.html g++ makefile configure cmake","categories":[{"name":"编译","slug":"编译","permalink":"https://hxlpub.github.io/categories/%E7%BC%96%E8%AF%91/"}],"tags":[{"name":"编译","slug":"编译","permalink":"https://hxlpub.github.io/tags/%E7%BC%96%E8%AF%91/"}]},{"title":"cv","slug":"cv","date":"2021-09-14T09:26:07.000Z","updated":"2022-03-26T09:01:13.127Z","comments":true,"path":"2021/09/14/cv/","link":"","permalink":"https://hxlpub.github.io/2021/09/14/cv/","excerpt":"","text":"","categories":[{"name":"计算机视觉CV","slug":"计算机视觉CV","permalink":"https://hxlpub.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89CV/"}],"tags":[{"name":"cv","slug":"cv","permalink":"https://hxlpub.github.io/tags/cv/"}]},{"title":"postgres数据库之基本操作","slug":"database_pg","date":"2021-09-14T09:26:07.000Z","updated":"2022-05-14T03:41:56.034Z","comments":true,"path":"2021/09/14/database_pg/","link":"","permalink":"https://hxlpub.github.io/2021/09/14/database_pg/","excerpt":"","text":"1.pgadmin工具 2.增删改查 ​ 插入批量记录： ​ 1）生成insertDeviceChannels 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139create or replace function insertDeviceChannels(num_limit integer) returns booleanAS$$declare id integer default 1; devName varchar; channelName varchar; devIndexCode varchar; devIp varchar; devIpEnd1 integer default 1; devIpEnd2 integer default 1; devPort integer default 1001; devExternalCode varchar; channelExternalCode varchar; regionCount integer; regionResourceLimit integer; regionResourceNum integer default 0; regionIndexCode varchar; offsetNum integer default 0;begin select count(o.region_index_code) into regionCount from tb_region o where region_status = &#x27;0&#x27;; raise notice &#x27;regionCount %&#x27; , regionCount; if num_limit % regionCount = 0 then regionResourceLimit := num_limit / regionCount; end if; if num_limit % regionCount &gt; 0 then regionResourceLimit := num_limit / regionCount + 1; end if; while devIpEnd1 &lt;= 100 loop devIpEnd2 := 1; while devIpEnd2 &lt;= 100 loop devip := &#x27;10.33.&#x27; || devIpEnd1 || &#x27;.&#x27; || devIpEnd2; devPort := 1000; while devPort &lt;= 1099 loop devName := devip; devIndexCode := uuid_generate_v4(); if regionIndexCode is null then select region_index_code into regionIndexCode from tb_region where region_status = &#x27;0&#x27; limit 1 offset offsetNum; end if; INSERT INTO public.tb_device (dev_id, dev_index_code, dev_name, dev_addr, dev_port, dev_model, active_device_code, dev_username, dev_password, pwd_strength, dev_type, dev_serial_num, dis_order, dev_capability, manufacturer, treaty_type, driver, sync_iac, remote_status, region_index_code, domain_id, ezviz_user_id, ezviz_dev_code, dev_restype, business_class, description, version, is_cascade, extended_attribute, com_id, data_no, status, create_time, update_time, creator, modifier ) VALUES (uuid_generate_v4(), devIndexCode, devName, devIp, devPort, &#x27;Simulator&#x27;, null, &#x27;admin&#x27;, &#x27;Dg/I6if34PWRn093VjyPqg==&#x27;, 3, null, &#x27;SimulatorDevice&#x27;, 1, &#x27;&#123;&#125;&#x27;, &#x27;hikvision&#x27;, &#x27;hiksdk_net&#x27;, &#x27;drv_vss_hiksdk_general_1.13.100&#x27;, 0, 1, regionIndexCode, 0, null, null, &#x27;&#123;encodeDevice&#125;&#x27;, &#x27;vms_encodeDevice_model&#x27;, null, 0, 0, &#x27;&#123; &quot;zeroChanCount&quot;: &quot;0&quot;, &quot;analogIoInCount&quot;: &quot;0&quot;, &quot;analogIoOutCount&quot;: &quot;0&quot;, &quot;digitalIoInCount&quot;: &quot;0&quot;, &quot;dataCollectStatus&quot;: &quot;1&quot;, &quot;digitalIoOutCount&quot;: &quot;0&quot;, &quot;analogChannelCount&quot;: &quot;0&quot;, &quot;digitalChannelCount&quot;: &quot;1&quot; &#125;&#x27;, &#x27;sdmc&#x27;, 1, 0, now(), now(), &#x27;admin&#x27;, &#x27;admin&#x27; ); channelName := devName || &#x27;_1&#x27;; INSERT INTO public.tb_channel (channel_id, channel_index_code, channel_name, channel_num, channel_main_type, channel_sub_type, channel_capability, dev_index_code, region_index_code, description, com_id, ezviz_safe_watch_key, treaty_type, is_cascade, cascade_platform_code, dis_order, sync_iac, data_no, status, extended_attribute, business_class, create_time, update_time, channel_restype, creator, modifier) VALUES (uuid_generate_v4(), uuid_generate_v4(), channelName, &#x27;1&#x27;, &#x27;camera&#x27;, &#x27;digital&#x27;, &#x27;&#123;&#125;&#x27;, devIndexCode, regionIndexCode, null, &#x27;sdmc&#x27;, null, null, &#x27;0&#x27;, &#x27;0&#x27;, id, null, id, 0, &#x27;&#123; &quot;osdStatus&quot;: &quot;0&quot; &#125;&#x27;, &#x27;vss_encodeDevice_camera&#x27;, now(), now(), &#x27;&#123;camera&#125;&#x27;, &#x27;admin&#x27;, &#x27;admin&#x27;); devPort := devPort + 1; regionResourceNum := regionResourceNum + 1; if regionResourceNum = regionResourceLimit then offsetNum := offsetNum + 1; regionIndexCode := null; regionResourceNum := 0; end if; if id = num_limit then return null; end if; id := id + 1; end loop; devIpEnd2 := devIpEnd2 + 1; end loop; devIpEnd1 := devIpEnd1 + 1; end loop; return null;end$$ LANGUAGE plpgsql; 2）插入10w记录 1select insertDeviceChannels(100000); 3)删除指定记录 1delete from tb_device where region_index_code = &#x27;219f98dd-a83a-468f-a2c0-3a30cd2e6082&#x27;;","categories":[{"name":"数据库","slug":"数据库","permalink":"https://hxlpub.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"postgres","slug":"postgres","permalink":"https://hxlpub.github.io/tags/postgres/"}]},{"title":"PostgreSQL数据库","slug":"database_redis","date":"2021-09-14T09:26:07.000Z","updated":"2022-05-14T03:41:43.650Z","comments":true,"path":"2021/09/14/database_redis/","link":"","permalink":"https://hxlpub.github.io/2021/09/14/database_redis/","excerpt":"","text":"","categories":[{"name":"数据库","slug":"数据库","permalink":"https://hxlpub.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"pg","slug":"pg","permalink":"https://hxlpub.github.io/tags/pg/"}]},{"title":"debug-段错误","slug":"debug","date":"2021-09-14T09:26:07.000Z","updated":"2022-08-03T06:37:54.251Z","comments":true,"path":"2021/09/14/debug/","link":"","permalink":"https://hxlpub.github.io/2021/09/14/debug/","excerpt":"","text":"段错误参考： https://blog.csdn.net/chen1415886044/article/details/108175581 https://blog.csdn.net/chen1415886044/article/details/108118966 #coredump 原理分析: 常用解决方法： coredump分析段错误详细步骤： 创建储存coredump空间 1如，mkdir /home/tests/corefile 设置coredump文件大小 1ulimit -c unlimited 设置文件格式 12echo “1” &gt; /proc/sys/kernel/core_uses_pid //将1写入到该文件里echo &quot;/home/tests/corefile/core-%e-%p-%t&quot; &gt; /proc/sys/kernel/core_pattern 修改配置文件/etc/profile, 12添加 `ulimit -S -c unlimited &gt; /dev/null 2&gt;&amp;1`后执行source etc/profile 在配置文件/etc/rc.local中最后面添加信息（机器重启时会自动加载该命令） 12rm -rf /home/tests/corefile/*机器重启时清空该文件夹，由于产生的coredump文件很大，若不清空的话时间长了会将硬盘占满； 实例 12345678910111213141516171.test.c源文件#include&lt;stdio.h&gt;int main()&#123; int *p = NULL; *p = 3; return 0;&#125;2.Makefile文件make: gcc -g test.c -o test #加g 才能gdb调试clean: rm test~ 详细过程： 1).执行make,编译完成后，运行二级制文件，生成corefile 123[root@hik c]# ll /home/tests/corefile/total 220-rw-------. 1 root root 307200 Jun 24 22:21 core-test-58552-1656080504 2)readelf 查看是否为core文件 12345678910111213141516171819202122readelf -h /home/tests/corefile/core-test-58552-1656080504ELF Header: Magic: 7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00 Class: ELF64 Data: 2&#x27;s complement, little endian Version: 1 (current) OS/ABI: UNIX - System V ABI Version: 0 Type: CORE (Core file) Machine: Advanced Micro Devices X86-64 Version: 0x1 Entry point address: 0x0 Start of program headers: 64 (bytes into file) Start of section headers: 0 (bytes into file) Flags: 0x0 Size of this header: 64 (bytes) Size of program headers: 56 (bytes) Number of program headers: 24 Size of section headers: 0 (bytes) Number of section headers: 0 Section header string table index: 0 运行gdb阅读core文件,格式，gdb 二进制文件 core文件 12345678910111213141516171819202122232425[root@hik c]# gdb test /home/tests/corefile/core-test-58552-1656080504GNU gdb (GDB) Red Hat Enterprise Linux 10.2-8.el9Copyright (C) 2021 Free Software Foundation, Inc.License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;This is free software: you are free to change and redistribute it.There is NO WARRANTY, to the extent permitted by law.Type &quot;show copying&quot; and &quot;show warranty&quot; for details.This GDB was configured as &quot;x86_64-redhat-linux-gnu&quot;.Type &quot;show configuration&quot; for configuration details.For bug reporting instructions, please see:&lt;https://www.gnu.org/software/gdb/bugs/&gt;.Find the GDB manual and other documentation resources online at: &lt;http://www.gnu.org/software/gdb/documentation/&gt;.For help, type &quot;help&quot;.Type &quot;apropos word&quot; to search for commands related to &quot;word&quot;...Reading symbols from test...[New LWP 58552][Thread debugging using libthread_db enabled]Using host libthread_db library &quot;/lib64/libthread_db.so.1&quot;.Core was generated by `./test&#x27;.Program terminated with signal SIGSEGV, Segmentation fault.#0 0x0000000000401116 in main () at test.c:55 *p = 3;(gdb) 进一步调试：断点调试 1234567891011121314151617181920212223242526272829303132(gdb) l #--用l(list)显示我们的源代码1 #include&lt;stdio.h&gt;2 int main()3 &#123;4 int *p = NULL;5 *p = 3;6 7 return 0;8 &#125;(gdb) b 5 # --用b(break)设置断点Breakpoint 1 at 0x401112: file test.c, line 5.(gdb) p p # --用p(print)打印变量i的值[看到没，这里p的值是0哦]$1 = (int *) 0x0(gdb) r #--用r(run)运行，直到断点处Starting program: /home/tests/c/test [Thread debugging using libthread_db enabled]Using host libthread_db library &quot;/lib64/libthread_db.so.1&quot;.Breakpoint 1, main () at test.c:55 *p = 3; #--[试图往地址0处写进一个值](gdb) n #-用n(next)执行下一步Program received signal SIGSEGV, Segmentation fault.0x0000000000401116 in main () at test.c:55 *p = 3;(gdb) c #--在上面我们接收到了SIGSEGV,然后用c(continue)继续执Continuing.Program terminated with signal SIGSEGV, Segmentation fault.The program no longer exists.(gdb) quit #--退出gdb undefined reference to依次排查（后续顺序会有调整）： case1: 函数定义时使用的是static型，它的作用域限于包含它的文件中，但是我却在别的文件中引用这个函数，编译结果必然会出现“函数未定义的使用”。 case2：","categories":[{"name":"debug","slug":"debug","permalink":"https://hxlpub.github.io/categories/debug/"}],"tags":[{"name":"debug","slug":"debug","permalink":"https://hxlpub.github.io/tags/debug/"}]},{"title":"学习思路","slug":"deep-learning","date":"2021-09-14T09:26:07.000Z","updated":"2022-03-26T09:02:10.564Z","comments":true,"path":"2021/09/14/deep-learning/","link":"","permalink":"https://hxlpub.github.io/2021/09/14/deep-learning/","excerpt":"","text":"","categories":[{"name":"深度学习","slug":"深度学习","permalink":"https://hxlpub.github.io/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"DL","slug":"DL","permalink":"https://hxlpub.github.io/tags/DL/"}]},{"title":"git版本管理工具","slug":"git_tools","date":"2021-09-14T09:26:07.000Z","updated":"2022-05-10T14:21:09.623Z","comments":true,"path":"2021/09/14/git_tools/","link":"","permalink":"https://hxlpub.github.io/2021/09/14/git_tools/","excerpt":"","text":"1.把github上面的仓库克隆到本地 1git clone 仓库 2.上传本地的项目到github仓库 1234567git add * #可将当前目录下文件添加到暂存区git add [file1] [file2] ...#添加一个或多个文件到暂存区git add [dir]#添加指定目录到暂存区，包括子目录git add .#添加当前目录下的所有文件到暂存区git commit -m &quot;提交信息&quot; （注：“提交信息”里面换成你需要，如“first commit”）git push -u origin master （注：此操作目的是把本地仓库push到github上面，此步骤需要你输入帐号和密码，这里的账号和密码是你的github的账号和密码，你第一次上传的话可能会需要你输密码）","categories":[{"name":"git","slug":"git","permalink":"https://hxlpub.github.io/categories/git/"}],"tags":[{"name":"版本管理","slug":"版本管理","permalink":"https://hxlpub.github.io/tags/%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86/"}]},{"title":"实现从Linux服务器获取windows文件","slug":"linux","date":"2021-09-14T09:26:07.000Z","updated":"2022-03-26T09:06:44.984Z","comments":true,"path":"2021/09/14/linux/","link":"","permalink":"https://hxlpub.github.io/2021/09/14/linux/","excerpt":"","text":"问题描述​ 工作中需要从Linux服务器端去拿windows端的文件，linux服务器之间底层互传文件可以用scp很容易实现，但是 不同的操作系统之间实现文件传输,如，windows 和linux之间，又如何实现呢？ 子问题1 描述：ftp ip 需要手动输入win ftpserver所在的win用户名密码后才可以执行抓取等操作，怎么能跳过手动的验证？ 12345678910[root@localhost AuthServer]# ftp 10.192.44.183Connected to 10.192.44.183 (10.192.44.183).220 Microsoft FTP ServiceName (10.192.44.183:root): linhongxun331 Password requiredPassword:230 User logged in.Remote system type is Windows_NT.ftp&gt; 解决方案： 1234567891011121314#!/bin/shftp -n &lt;&lt;- EOF#win 端IPopen ip#win 端用户名密码user username password#传输格式ascii(or bin)#操作put *(or get)#退出byeEOF 子问题2： 解决方案 ftp：需要在windows端搭建ftpserver服务，在linux端安装ftp工具 scp 工作中使用了ftp的方案，本文着重讲解ftp实现从Linux服务器获取windows文件 实现windows 端搭建ftpserver​ 问一下度娘，很简单，在这不耽误时间，推荐 Linux 端安装ftp工具 rpm包方式安装 yum 安装 yum list |grep ftp #查看可安装版本ftp yum install ftp… ftp实现抓取windows端的文件到指定路径​ example:实现将win端的路径下文件cp 到linux端同一路径下：downloadjson.sh 1234567891011121314151617#!/bin/sh# $1 是第一个参数，即路径，执行的脚本为: ./downloadjson.sh /nas/test/test/DocumentVoucher.jsonparam1=`echo $1 |awk -F &quot;DocumentVoucher&quot; &#x27;&#123;printf $1&#125;&#x27;`#echo $&#123;param1&#125;ftp -n &lt;&lt;- EOFopen ftpserveripuser username passwordasciicd $&#123;param1&#125;get DocumentVoucher.jsonbyeEOFmkdir -p $&#123;param1&#125;cp DocumentVoucher.json $&#123;param1&#125; go语言执行脚本​ 项目中，上层应用是http 协议，目的是请求到含有文件路径报文的同时，将文件下载到Linux服务器端，故在http协议绑定的接口函数里面实现了执行该脚本,逻辑如下 123456789command := &quot;./downloadjson.sh &quot; + documentPathfmt.Println(command)cmd := exec.Command(&quot;/bin/sh&quot;, &quot;-c&quot;, command)bytes, err := cmd.Output()if err != nil &#123; fmt.Println(err) &#125;resp := string(bytes) fmt.Println(resp) 常见问题FAQ ​ ftp ip 时连接超时 1234[root@localhost AuthServer]# ftp 10.192.44.183ftp: connect: Connection timed outftp&gt; 解决方案：关闭win端的防火墙 ftp常用指令 连接ftp服务器 格式： 1ftp [hostname| ip-address] a)在linux命令行下输入： 1ftp 192.168.26.66 b)服务器询问你用户名和口令，分别输入用户名和相应密码，待认证通过即可。 2. 下载文件 下载文件通常用get和mget这两条命令。 a) get 格式： 1get [remote-file] [local-file] 将文件从远端主机中传送至本地主机中. 如要获取服务器上e:\\rose\\1.bmp,则 1ftp&gt; get /rose/1.bmp 1.bmp (回车) b) mget 格式： 1mget [remote-files] 从远端主机接收一批文件至本地主机. 如要获取服务器上e:\\rose\\下的所有文件,则 12ftp&gt; cd /roseftp&gt; mget *.* (回车) 注意：文件都下载到了linux主机的当前目录下。比如，在 /root/yint下运行的ftp命令，则文件都下载到了/root/yint 下。 3.上传文件 a) put 1格式：put local-file [remote-file] 将本地一个文件传送至远端主机中. 如要把本地的1.bmp传送到远端主机e:\\rose,并改名为333.bmp 1 ftp&gt; put 1.bmp /rose/333.bmp (回车) b) mput 1格式：mput local-files 将本地主机中一批文件传送至远端主机. 如要把本地当前目录下所有bmp文件上传到服务器e:\\rose 下 12ftp&gt; cd /rose （回车）ftp&gt; mput *.bmp （回车） 注意：上传文件都来自于主机的当前目录下。比如，在 /root/test下运行的ftp命令，则只有在/root/test下的文件linux才会 上传到服务器e:\\rose 下。 4. 断开连接 bye：中断与服务器的连接。 1 ftp&gt; bye (回车) scp常用​ scp是安全的文件拷贝，基于ssh的登录 ​ 假定你想把本地计算机/home下的一个名为a.tar.tz的文件拷贝到远程服务器192.168.0.2上的/home/tmp。而且你在远程服务器 上的帐号名为root。可以用这个命令： 1scp /home/a.tar.tz root@192.168.0.2:/home/tmp/ ​ 如果把文件从远程机器拷贝到本机当前目录用这个命令： 1scp root@192.168.0.2:/home/a.tar.tz ​ 拷贝远程机器的整个目录下的文件 1scp -r root@192.168.0.2：/home/* ./","categories":[{"name":"Linux","slug":"Linux","permalink":"https://hxlpub.github.io/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://hxlpub.github.io/tags/Linux/"}]},{"title":"Linux内核","slug":"linux_kernel","date":"2021-09-14T09:26:07.000Z","updated":"2022-05-14T02:34:23.771Z","comments":true,"path":"2021/09/14/linux_kernel/","link":"","permalink":"https://hxlpub.github.io/2021/09/14/linux_kernel/","excerpt":"","text":"","categories":[{"name":"Linux","slug":"Linux","permalink":"https://hxlpub.github.io/categories/Linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://hxlpub.github.io/tags/linux/"}]},{"title":"Linux驱动.ko文件编写加载","slug":"linux_ko","date":"2021-09-14T09:26:07.000Z","updated":"2022-03-26T08:45:12.487Z","comments":true,"path":"2021/09/14/linux_ko/","link":"","permalink":"https://hxlpub.github.io/2021/09/14/linux_ko/","excerpt":"","text":"参考 一、.ko 文件介绍.ko文件是kernel object文件（内核模块），该文件的意义就是把内核的一些功能移动到内核外边， 需要的时候插入内核，不需要时卸载。 二、优点（1）这样可以缩小内核体积； （2）使用方便。 三、.ko文件一般的用处（1）作为一个功能模块，需要使用时，直接插入运行就行。如在imx6上连接模拟摄像头，先运行模拟摄像头对应的驱动模块 camera.ko文件，然后对应的工程执行文件运行就行。 四、使用.ko 文件1、加载驱动模块test.ko（1）方法一进入test.ko驱动模块文件所在的目录，然后直接 insmod test.ko （2）方法二将test.ko文件拷贝到/lib/module/#uname-r#/目录下，这里，#uname -r#意思是，在终端中输入uname -r后显示的内核版本及名称，例如我的环境centos 7系统下#uname-r#就是3.10.0-957.12.2.el7.x86_64然后 depmod（会在/lib/modules/#uname -r#/目录下生成modules.dep和modules.dep.bb文件，表明模块的依赖关系）最后 modprobe test（注意这里无需输入.ko后缀） 即可 注：两种方法的区别 modprobe和insmod类似，都是用来动态加载驱动模块的，区别在于modprobe可以解决load module时的依赖关系，它是通过/lib/modules/#uname -r/modules.dep(.bb)文件来查找依赖关系的；而insmod不能解决依赖问题。也就是说，如果你确定你要加载的驱动模块不依赖其他驱动模块的话，既可以insmod也可以modprobe，当然insmod可以在任何目录下执行，更方便一些。而如果你要加载的驱动模块还依赖其他ko驱动模块的话，就只能将模块拷贝到上述的特定目录，depmod后再modprobe。 2、查看已加载的驱动模块列表在任何目录下输入命令lsmod 12345678910111213141516171819202122232425`[root@HikvisionOS ~]# lsmod` `Module Size Used by``ip6t_rpfilter 12595 1` `ipt_REJECT 12541 2` `nf_reject_ipv4 13373 1 ipt_REJECT``ip6t_REJECT 12625 2` `nf_reject_ipv6 13717 1 ip6t_REJECT``xt_conntrack 12760 19` `ip_set 45644 0` `nfnetlink 14490 1 ip_set``ebtable_nat 12807 1` `ebtable_broute 12731 1` `bridge 151336 1 ebtable_broute``stp 12976 1 bridge``llc 14552 2 stp,bridge``ip6table_nat 12864 1` `nf_conntrack_ipv6 18935 11` `nf_defrag_ipv6 35104 1 nf_conntrack_ipv6``nf_nat_ipv6 14131 1 ip6table_nat``ip6table_mangle 12700 1` `ip6table_security 12710 1` `ip6table_raw 12683 1` `iptable_nat 12875 1` `nf_conntrack_ipv4 15053 10` `nf_defrag_ipv4 12729 1 nf_conntrack_ipv4` 3、卸载驱动模块在任何目录下， 输入命令 rmmod 注：“module_name”是lsmod显示的模块名称，而不是对应的ko文件名 五、编写生成.ko 文件Linux下hello.ko内核模块制作的全过程 1.linux系统用的是Redflag 6.0 SP1 下载地址：ftp://ftp.redflag-linux.com/pub/redflag/dt6sp1/SP1/redflag-6-sp1.iso， 系统安装很容易，安提示做就好。所用的内核源码目录树下载地址：ftp://ftp.redflag-linux.com/pub/redflag/dt6sp1/SP1/redflag-6-tool-sp1-src1.iso，将此iso文件挂载到/mnt下，安装其中的内核rpm包。挂载方法：mount -t iso9660 redflag-6-tool-sp1-src1.iso /mnt/ -o loop内核目录树安装方法：cd /mnt/RedFlag/SRMPS/ rpm -i kernel-2.6.23.1-4.src.rpm 2.编写hello模块代码，源码如下： hello.c 12345678910111213141516#include &lt;linux/init.h&gt; #include &lt;linux/module.h&gt; MODULE_LICENSE(&quot;GPL&quot;); static int hello_init(void) &#123; printk(KERN_ALERT &quot;Hello, world\\n&quot;); return 0; &#125; static void hello_exit(void) &#123; printk(KERN_ALERT &quot;Goodbye, cruel world\\n&quot;); &#125; module_init(hello_init); module_exit(hello_exit); 3.编写hello模块的Makefile文件，Makefile内容如下： 123456789101112Makefile#Makefile 2.6 obj-m :=hello.o KERNEL :=/usr/src/kernels/$(uname -r)/ PWD :=$(shell pwd) modules : $(MAKE) -C $(KERNEL) M=$(PWD) modules .PHONEY:clean clean : rm -f *.o *.ko 4.编译模块在命令行进入hello.c所在的文件夹下执行make命令即可完成hello模块的编译。用ls命令可以查看到hello.ko文件，此文件就是我们自定义的内核模块。 5.安装hello模块 命令行下执行命令：insmod hello.ko 。通过命令:cat /var/log/messages 可以看到下面这样的信息：“Aug 6 13:37:59 localhost kernel: Hello, world”，说明模块加载成功了。 6.另外一种模块Makefile的编写方法 Makefile 1234567891011121314151617181920# If KERNELRELEASE is defined, we&#x27;ve been invoked from the # kernel build system and can use its language. ifneq ($(KERNELRELEASE),) obj-m := hello.o # Otherwise we were called directly from the command # line; invoke the kernel build system. else KERNELDIR ?= /lib/modules/$(shell uname -r)/build PWD := $(shell pwd) default: $(MAKE) -C $(KERNELDIR) M=$(PWD) modules endif 卸载hello模块 命令行下执行命令：rmmod hello.ko即可。通过命令：cat /var/log/messages.可以看到下面这样的信息：“Aug 6 13:40:36 localhost kernel: Goodbye, cruel world”，说明模块卸载成功。 查看模块信息 命令行下执行命令：modinfo hello————————————————版权声明：本文为CSDN博主「worthsen」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。原文链接：https://blog.csdn.net/qq_38880380/article/details/79227760","categories":[{"name":"Linux","slug":"Linux","permalink":"https://hxlpub.github.io/categories/Linux/"}],"tags":[]},{"title":"基于最小化系统centos7搭建服务器","slug":"linux_mini_system_config","date":"2021-09-14T09:26:07.000Z","updated":"2022-05-14T02:34:37.451Z","comments":true,"path":"2021/09/14/linux_mini_system_config/","link":"","permalink":"https://hxlpub.github.io/2021/09/14/linux_mini_system_config/","excerpt":"","text":"将自己的一台旧笔记本装成centos 7 配置服务器 网络配置 配置无线网卡（有网线的可以配置有线网卡）,一开始， 1.nmcli 查看网卡，我的无线网卡是wlp1s0,显示unmanaged， plugin missing，需要托管下并且安装NetworkManager-wifi模块 2.nmcli dev set wlp1s0 autoconnect yes managed yes 加入托管 3.在官网下载相应版本的rpm 包，我的是centos 7 版本NetworkManager-wifi-1.18.8-1.el7.x86_64.rpm ,拷贝到U盘 4.安装，yum install -y NetworkManager-wifi-1.18.8-1.el7.x86_64.rpm 5.安装完，重启下NetworkManager.service ,systemctl restart NetworkManager.service nmcli 查看 显示disconnected 6.连接无线 nmcli d wifi list：列出当前扫描出的热点 nmcli dev wifi connect “wifi名称” password “WiFi密码” 查看 nmcli dev show wlp1s0 已经connected 7.ping 一下自己另外的设备A，不通的，但是能ping 通网关还能ping www.baidu.com,而且在另外的设备A上ping 服务器B是通的：关闭A 防火墙 其他配置参考 [参考]: https://blog.csdn.net/chenkaifang/article/details/82531696 “CentOS7.5最小化安装之后的配置”","categories":[{"name":"Linux","slug":"Linux","permalink":"https://hxlpub.github.io/categories/Linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://hxlpub.github.io/tags/linux/"}]},{"title":"linux性能分析","slug":"linux_server_performance_analysis","date":"2021-09-14T09:26:07.000Z","updated":"2022-03-26T08:46:12.343Z","comments":true,"path":"2021/09/14/linux_server_performance_analysis/","link":"","permalink":"https://hxlpub.github.io/2021/09/14/linux_server_performance_analysis/","excerpt":"","text":"","categories":[{"name":"Linux","slug":"Linux","permalink":"https://hxlpub.github.io/categories/Linux/"}],"tags":[]},{"title":"Linux OM(运维)","slug":"linux_om","date":"2021-09-14T09:26:07.000Z","updated":"2022-06-29T12:26:24.395Z","comments":true,"path":"2021/09/14/linux_om/","link":"","permalink":"https://hxlpub.github.io/2021/09/14/linux_om/","excerpt":"","text":"目录文件管理目录管理123456789101112131415161718192021222324252627282930313233343536373839404142434445464748491.列出目录文件名 ls/ll 1、ls -al ~:将家目录下的所有文件列出来（含属性与隐藏文件） 2、ls -alF --color=never:不显示颜色，文件名末尾显示文件名代表的类型 3、ls -al --full-time ~ ：完整呈现文件的修改时间 权限说明drwxr-xr-x 2 root root 4096 Jul 20 2017 Documents第一栏drwxr-xr-x:类型与权限 第一个字符表示文件是目录或文件或链接等等 [d]:目录 [-]:文件 [l]:链接 [b]:装置文件里可供存储的接口设备（可随机存取装置） [c]:装置文件里串行端口设备，如键盘鼠标（一次性读取装 置） 剩余字符以三个为一组：均为rwx三个参数组合 r可读：4 w可写:2 x可执行:1 没有权限则-:0 drwxr-xr-x: rwx=4+2+1=7 r-x:4+0+1=5 r-x:4+0+1=5 则该文件的权限数字是755 第一组：文件拥有者权限 第二组：加入此群组账号的权限 第三组：非本人且未加入本群组的其他账号的权限 第二栏 表示有多少档名连接到此节点（i_node） 第三栏 表示文件或者目录的拥有者账号 第四栏 表示文件所属群组 第五栏 表示文件容量大小，默认单位bytes 第六栏 表示文件的件当日期或最近修改日期 第七栏 表示文档的名字2.切换目录 cd 1、cd /usr/bin: 绝对路径，以根目录/开头 2、cd bin:在usr下，相对路径，相对于当前目录 3、cd ～：切换到目前用户所在家目录 4、cd . :目前所在目录 5、cd .. :切换至目前目录的上一层目录 6、cd ../.. :切换至上上层目录 7、cd ~account :切换到目前用户account所在家目录/home/account 8、cd ../dir:切换到与本目录并列的另一个目录 9、cd -:回到之前的目录3.显示当前目录 pwd4.创建一个新目录 mkdir5.删除一个空目录 rmdir 传输文件1234567891011121314151.wget 从URL获取文件 wget URL #下载URL指定的文件 ex: wget www.baidu.com #下载百度网页 wget -O filename URL #从URL获取文件并重命名filename,filename包含路径 ex：wget http://mirrors.hikvision.com.cn/help/centos/7/CentOS-Base.repo -O /etc/yum.repos.d/CenOS-Base.repo #配置hik yum源 wget -o log URL#注意o与O区别，o为写日志log（怎么获取文件的过程，包括解析、建立连接、传文件等），O为文件名2.ftp 子主题 1 子主题 23.scp 用于 Linux 之间复制文件和目录 scp [可选参数] file_source file_target 1、scp /home/space/music/1.mp3 IP:/home/root/others/music （本地到远程） 2、scp -P 55555 IP:/usr/local/sin.sh /home/administrator（远程到本地） 创建文件、文件链接12341.touch filename#从无到有创建文件2.cp file file.bak #备份3.ln -sf /dev/dm-30 /dev/cvr_vg/lun1 (ln -sf 目的地 链接) 删除文件1rm -rf filename #r：递归，f：强制删除，不提示 更改文件12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455561.重命名​ mv filename newfilename#将文件filename重命名为newfilename2.更改文件属性​ chattr​ 语法​ chattr [-RV][-v&lt;版本编号&gt;][+/-/=&lt;属性&gt;][文件或目录...]​ 参数​ -R 递归处理，将指定目录下的所有文件及子目录一并处理。 -v&lt;版本编号&gt; 设置文件或目录版本。 -V 显示指令执行过程。 +&lt;属性&gt; 开启文件或目录的该项属性。 -&lt;属性&gt; 关闭文件或目录的该项属性。 =&lt;属性&gt; 指定文件或目录的该项属性。 属性 a：让文件或目录仅供附加用途。 b：不更新文件或目录的最后存取时间。 c：将文件或目录压缩后存放。 d：将文件或目录排除在倾倒操作之外。 i：不得任意更动文件或目录。 s：保密性删除文件或目录。 S：即时更新文件或目录。 u：预防意外删除。 示例 chattr +i /etc/resolv.conf#用chattr命令防止系统中某个关键文件被修改 chattr +a /var/log/messages#让某个文件只能往里面追加数据，但不能删除，适用于各种日志文件3.更改文件权限 chmod 格式 chmod [-cfvR] [--help] [--version] mode file... 参数 mode : 权限设定字串 [ugoa...][[+-=][rwxX]...][,...]#格式 其中： u 表示该文件的拥有者，g 表示与该文件的拥有者属于同一个群体(group)者，o 表示其他以外的人，a 表示这三者皆是。 + 表示增加权限、- 表示取消权限、= 表示唯一设定权限。 r 表示可读取，w 表示可写入，x 表示可执行，X 表示只有当该文件是个子目录或者该文件已经被设定过为可执行。 其他参数说明： -c : 若该文件权限确实已经更改，才显示其更改动作 -f : 若该文件权限无法被更改也不要显示错误讯息 -v : 显示权限变更的详细资料 -R : 对目前目录下的所有文件与子目录进行相同的权限变更(即以递归的方式逐个变更) --help : 显示辅助说明 --version : 显示版本 示例 chmod ugo+r file1.txt#将文件 file1.txt 设为所有人皆可读取 chmod ug+w,o-w file1.txt file2.txt#将文件 file1.txt 与 file2.txt 设为该文件拥有者，与其所属同一个群体者可写入，但其他以外的人则不可写入 chmod -R a+r *#将目前目录下的所有文件与子目录皆设为任何人可读取 chmod a=rwx file == chmod 777 file 查看文件1234567891011121314151617181920212223242526272829301.cat 从头到尾显示文件内容 cat 文件 #从头到尾显示整个文件内容，当文件很大时，终端无法完全显示其所有内容 cat -n 文件 #查看文件内容的同时添加行号 三大功能 1.cat 文件 #一次显示整个文件 2.cat &gt; 文件 #从键盘创建一个文件,只能创建新文件，不能编辑已有文件，执行命令后会进入文件编辑，每次都会覆盖旧的内容 3.cat file1 file2 &gt; file#将几个文件合并为一个文件 2.more 分屏显示文件 more 文件 #分屏显示文件内容，空格：向下翻页，b：向上翻页，q：退出3.less 分屏显示文件，同more4.head 从头开始查看文件内容 head 文件 #显示文件头部，默认10行 head -n 行数 文件#查看文件的前10行5.tail 与head相反6.file 观察文件类型,某个文件的基本数据 file file 文件类型诸如,ASCII，data文件，binary文件等 file file7.查看文件格式:set ff #进入到文件，vi/vim 文件后执行:set ff 搜索文件1234567891011121314151617181920212223241.find find path -option ... find . -type f#将当前目录及其子目录中的所有文件列出 find . -name &quot;*.c&quot;#将当前目录及其子目录下所有文件后缀为 .c 的文件列出来 常用：find / -name filename2.which 寻找执行档 which command -a :将所有由PATH目录中可以找到的指令均列出，而不止第一份被找到的指令名称 1、which ifconfig :找出ifconfig命令的执行文件位置3.whereis 文件档名的查找，由一些特定的目录中 寻找文件文件名 whereis [-bmsu] 文件或目录名 -l：列出whereis 会去查询的几个主要目录而已 -b:只找binary文件 -m:只找在说明文件manual路径下的文件 -s:只找source 来源文件 -u:搜寻不在上述三个项目 中的其他特殊文件 1、whereis ifconfig4.根据文件中字符串搜索文件 grep -rn &quot;字符串&quot; 比较文件121.diff diff 选项 文件一 文件二 分割文件1234split 命令用于将一个文件分割成数个 -b:指定每多少字节切成一个小文件 1、split -b 1024m txst.txt -d -a 2 test.txt_ 编辑文件vim ​ 常用快捷方式：\\ 输入输出1231.&gt;&gt; 输出重定向 example: vmstat 3 &gt;&gt; test#vmstat输出重定向到文件test 系统管理1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798991001011021031041051061071081091101111121131.top 实时显示 process 的动态 top [-d 数字] |top [-bnp] -d:后接秒数，更新的秒数 -b:以批次的方式执行 -n:与-b搭配表示需要进行几次top的输出结果 -p 指定某些个PID观察 1、top -d 2 说明: 第一行：目前的时间，经过的时间，登录用户数，在1,5,15分钟的平均负载 第二行：显示目前进程总数和个别进程状态 第三行： 显示CPU的整体负载 第四行第五行：物理内存和虚拟内存使用情况（虚拟内存来源？？) 第六：输入指令时显示状态的地方 2、top -b -n 2 &gt;/tmp/top.txt#2次输出结果到文件 3、top -d 2 -p PID #持续观察该PID2.ps 显示某个时间点的进程运作情况 ps [options] -A:显示所有process,同-e -a:不与terminal相关的process -u：有效使用者相关的pro x:通常与a一起用列出较完整信息 l :详细讲该PID信息列出 j:工作的格式 -f：更完整的输出 1、ps -l 仅仅观察自己bash相关的进程 说明： F：进程旗标，总结权限，常见号码4:表示进程权限root 1:表示仅复制而没有实际执行 S：表示状态 R：运行中 S：睡眠 D：不可唤醒，可能在等待IO的情况 T：停止 Z:僵尸状态，已经终止但无法移除到内存外 UID/PID/PPID:代表此进程被该UID所拥有，进程的PID号码，此进程的PID号码 C：Cpu 使用率 PRI/NI :priority/nice优先级，越小越优先 ADDR/SZ/WCHAN：内存相关,内存部分，用掉多少内存，是否在运作 TTY：终端机位置，远程则pts/n TIME:使用掉的CPU时间 CMD：造成此进程的程序的指令 2、ps aux#观察系统所有进程 USR;使用者账号 MEM：物理内存占比 VSZ：耗掉的虚拟内存 RSS：占用的固定内存3、ps -lA#显示所有进程 4.free 用于显示内存状态5.查看cpu cat /proc/cpuinfo6.查看内核uname -r7.查看系统cat /etc/redhat-release （redhat）8.进程管理 Kill -s 9 进程号#杀掉进程9.查看目录占用者并解除占用 stat /root/hu10.systemctl 一、systemd 系统初始化程序，系统开始的第一个进程，pid为1 二、systemctl命令 systemctl list-units ##列出当前系统服务的状态 systemctl list-unit-files ##列出服务的开机状态 systemctl status sshd ##查看指定服务的状态 systemctl stop sshd ##关闭指定服务 systemctl start sshd ##开启指定服务 systemctl restart sshd ##从新启动服务 systemctl enable sshd ##设定指定服务开机开启 systemctl disable sshd ##设定指定服务开机关闭 systemctl reload sshd ##使指定服务从新加载配置 systemctl list-dependencies sshd ##查看指定服务的倚赖关系 systemctl mask sshd ##冻结指定服务 systemctl unmask sshd ##启用服务 systemctl set-default multi-user.target ##开机不开启图形 systemctl set-default graphical.target ##开机启动图形 setterm ##文本界面设定color 三、服务状态 systemctl status 服务名称 loaded ##系统服务已经初始化完成，加载过配置 active（running） ##正有一个或多个程序正在系统中执行， vsftpd就是这种模式 atcive（exited） ##僅執行一次就正常結束的服務， 目前並沒有任何程序在系統中執行 atcive（waiting） ##正在執行當中，不過還再等待其他的事件才能继续处理 inactive ##服务关闭 enbaled ##服务开机启动 disabled ##服务开机不自启 static ##服务开机启动项不可被管理 failed ##系统配置错误 11.pstree查看Linux下systemd启动了哪些服务 pstree [options]-a #包含命令行参数-c #展开相同的子树-H [PID] #突出特定过程-g #显示进程组ID-n #使用PID排序pstree 用户 #显示特定用户的进程树-s [PID ] #限制显示一个特定的过程12.查看内存型号dmidecode -t memory13. 排名前10的内存CPU消耗ps auxw|head -1;ps auxw|sort -rn -k3|head -1014.释放内存如果内存太少， 可以把占用内存多的程序停掉， 然后执行这个命令释放： echo 3 &gt;/proc/sys/vm/drop_caches 释放完后再改回去： echo 1 &gt;/proc/sys/vm/drop_caches 系统设置123子主题 1子主题 2子主题 3 磁盘、设备管理1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162631.df 列出文件系统的整体磁盘使用量 df [-ahikHTm][目录或文件名] -a:列出所有文件系统，包括系统特有的/proc等文件系统 -k:以KBytes的容量显示文件系统 -m:以MBytes的容量显示文件系统 -h：以人们交易阅读的的GB、MB、KB等格式自行显示 -H：以M=1000K取代M=1024K 的进位方式 -T：连同该partition的filesystem名称列出 -i:不用磁盘容量而以inode数量表示 1、df:列出系统内所有filesystem列出来 filesystem:表示文件系统是哪个partition 1k-blocks:表示单位1KB，可用-h或-m改变容量 Used:使用掉的磁盘空间 Available:剩下的磁盘空间 Use%:磁盘的使用率 Mounted on :磁盘挂载的目录（挂载点） 2、df -h:易读显示 3、df -aT:将系统内所有特殊文件格式以及名称列出来 4、df -h /etc：将/etc下可用的磁盘以易读的容量格式显示出来 5、df -ih：将目前的各个partition当中可用的inode数量列出2.lsblklist block device观察磁盘分区状态lsblk [-dfimpt] device-d:仅列出磁盘本身,无分区-f:含文件系统名称-i：使用ASCII的线段输出-m：输出权限数据-p:列出完整文件名 -t:列出详细数据。包括磁盘队列机制与读写的数据量大小1、lsblk -ip /dev/sdb3.blkid对系统的块设备（包括交换分区）所使用的文件系统类型、LABEL、UUID等信息进行查询4.挂载镜像 1、sudo losetup /dev/loop0 iVMS-HG-H16_CN_STD_9.2.0_V2.3.8_iSC_V1.5.100_201026_platformactive_base.img 2、 kpartx -av /dev/loop0 3、 kpartx -d /dev/loop0 4、losetup -d /dev/loop05.调整分区fdisk 1.fdisk /dev/hda p：打印分区 d：删除分区 n:新增分区 2.格式化分区 mkfs.ext4 /dev/.. 3.挂载分区 mount /dev/... 挂载点6.激活网卡 ifup eth0 磁盘维护1234567891011121314151.dd 备份(直接读取扇区sector)制作文件 dd if=&quot;input_file&quot; of=&quot;output_file&quot; bs=&quot;blocksize&quot; count=blocknum if：输入文件名，默认为标准输入。即指定源文件或设备。 of：输出文件名，默认为标准输出。即指定目的文件或设备。 count：多少的bs bs：一个block大小 1、dd if=/etc/passwd of=/etc/passwd.back #备份文件 2、dd if=/dev/sdb of=/tmp/system.iso#将光驱内容备份下来 3、dd if=/tmp/system.iso of=/dev/sdb#将镜像备份到设备 4、将/boot整个文件系统透过dd备份下来 df -h /boot#获取设备/dev/... dd if=/dev/… of=/tmp/….img 子主题 2子主题 3 网络通讯、系统性能1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798991001011021031041051061071081091101111121131141151161171181191201211221231241251261271281291301311321.iostat I/O statistics（输入/输出统计）输出CPU和磁盘I/O相关的统计信息监控系统的IO状态 iostat [ options ] [ &lt;interval&gt; [ &lt;count&gt; ] ]-c：查看CPU部分状态信息-k:某些使用block为单位的列强制使用Kilobytes为单位-d 参数，显示设备（磁盘）使用状态-x 参数，输出更多详细信息1、iostat -c2、iostat -k 1 103、iostat -d 1 34、iostat -x 1 2说明：磁盘属性tps：该设备每秒的传输次数“一次传输”意思是“一次I/O请求”。多个逻辑请求可能会被合并为“一次I/O请求”。“一次传输”请求的大小是未知的。kB_read/s：每秒从设备（drive expressed）读取的数据量；kB_wrtn/s：每秒向设备（drive expressed）写入的数据量；kB_read：读取的总数据量；kB_wrtn：写入的总数量数据量；这些单位都为Kilobytes。CPU属性%user cpu处在用户模式下的时间百分比%nice cpu处在带NICE值的用户模式下的时间百分比%system cpu处在系统模式下的时间百分比%iowait cpu等待输入输出完成时间的百分比%steal 管理程序维护另一个虚拟处理器时，虚拟CPU的无意识等待时间百分比%idle cpu空闲时间百分比注意:如果%iowait的值过高，表示硬盘存在I/O瓶颈，%idle值高，表示CPU较空闲，如果%idle值高但系统响应慢时，有可能是CPU等待分配内存，此时应加大内存容量。%idle值如果持续低于10，那么系统的CPU处理能力相对较低，表明系统中最需要解决的资源是CPU。2.ifstat网络接口监测工具ifstat options-l 监测环路网络接口。缺省情况下ifstat监测活动的所有非环路网络接口-a 监测能检测到的所有网络接口的状态信息。-z 隐藏流量是无的接口，如接口启动了但是未使用的。-i &lt;interface&gt; 指定要监测的接口。-s 通过SNMP查询一个远程主机。-h 显示帮助信息-n 关闭周期性显示头部信息。-t 在每一行的开头加一个时间戳-T 报告所有检测接口的全部带宽-w 指定间隔时间（与官方的文档说明并不同，不知道是不是写文档的人写错，反正我测试后是间隔时间）-W 如果显示内容超出终端窗口的宽度，就换行-S 在同一行更新显示内容 -b 用kbits/s显示带宽-q 按键模式-v 显示版本信息-d 指定一个驱动来收集状态信息 3.netstatNetstat是控制台命令,是一个监控TCP/IP网络的非常有用的工具，它可以显示路由表、实际的网络连接以及每一个网络接口设备的状态信息。Netstat用于显示与IP、TCP、UDP和ICMP协议相关的统计数据，一般用于检验本机各端口的网络连接情况。netstat options-a (all) 显示所有选项，默认不显示LISTEN相关。-t (tcp) 仅显示tcp相关选项。-u (udp) 仅显示udp相关选项。-n 拒绝显示别名，能显示数字的全部转化成数字。-l 仅列出有在 Listen (监听) 的服务状态。-p 显示建立相关链接的程序名-r 显示路由信息，路由表-e 显示扩展信息，例如uid等-s 按各个协议进行统计-c 每隔一个固定时间，执行该netstat命令。LISTEN和LISTENING的状态只有用-a或者-l才能看到。1、列出所有端口 #netstat -a2、列出所有 tcp 端口 #netstat -at3、列出所有 udp 端口 #netstat -au4、只显示监听端口 #netstat -l5、只列出所有监听 tcp 端口 #netstat -lt6、只列出所有监听 udp 端口 #netstat -lu7、列出所有监听 UNIX 端口 #netstat -lx8、显示所有端口的统计信息 #netstat -s9、显示 TCP 或 UDP 端口的统计信息 #netstat -st 或 -su10、 输出中显示 PID 和进程名称 #netstat -p4.vmstat展现给定时间间隔的服务器的状态值,包括服务器的CPU使用率，内存使用，虚拟内存交换情况,IO读写情况 vmstat [options] [delay [count]]参数说明Procs（进程） r等待执行的任务数展示了正在执行和等待cpu资源的任务个数当这个值超过了cpu个数，就会出现cpu瓶颈。B等待IO的进程数量Memory(内存)swpd正在使用虚拟的内存大小，单位kfree空闲内存大小buff已用的buff大小，对块设备的读写进行缓冲cache已用的cache大小，文件系统的cacheinact非活跃内存大小，即被标明可回收的内存，区别于free和active active活跃的内存大小Swapsi每秒从交换区写入内存的大小（单位：kb/s）so每秒从内存写到交换区的大小IObi每秒读取的块数（读磁盘） 块设备每秒接收的块数量，单位是block，这里的块设备是指系统上所有的磁盘和其他块设备，现在的Linux版本块的大小为1024bytesbo每秒写入的块数（写磁盘）块设备每秒发送的块数量，单位是block system in ：中断数cs:每秒上下文切换数CPUus用户进程执行消耗cpu时间(user time) us的值比较高时，说明用户进程消耗的cpu时间多，但是如果长期超过50%的使用，那么我们就该考虑优化程序算法或其他措施了sy系统进程消耗cpu时间(system time)sys的值过高时，说明系统内核消耗的cpu资源多，这个不是良性的表现，我们应该检查原因。这里us + sy的参考值为80%，如果us+sy 大于 80%说明可能存在CPU不足Id空闲时间(包括IO等待时间) 一般来说 us+sy+id=100wa等待IO时间wa过高时，说明io等待比较严重，这可能是由于磁盘大量随机访问造成的，也有可能是磁盘的带宽出现瓶颈。5.tcpdump 虚拟机内抓一下网卡上某个ip的流量 tcpdump -i ens3 |grep 10.192.54.2206.ethtool 查看网卡信息 ethtool eth0 备份压缩12345678910111213141516171819202122232425262728293031321.zip zip -r myfile.zip ./* unzip -o -d /home/sunny myfile.zip #解压myfile.zip 到/home/sunny2.tar 用于备份文件、压缩、解压 -c：建立打包文件，可搭配-v查看过程中被打包的文件名 -t:查看打包文件的内容含有哪些档名，重点在查看档名就是了 -x:解打包或解压缩的功能，可以搭配-C在特定的目录解开，特别留意的是-c,-t，-x不可同时出现在一串指令中 -z：透过gzip的支持进行压缩解压缩，文件最好是*.tar.gz -j：透过bzip2的支持进行压缩解压缩，文件最好是*.tar.bz2 -J：透过xz的支持进行压缩解压缩，文件最好是*.tar.xz -v:在压缩解压缩的过程中，将正在处理的文件名显示出来 -f filename：-f 后面要立刻接要被处理的文档名 -C目录：这个选项用在解压缩，若要在特定目录解压缩，可以使用这个选项 -p：保留备份数据的原本权限与属性，常用于备份-c重要的配置文件 -P：保留绝对路径，即允许备份数据中含有根目录存在 --exclude=FILE：在压缩过程中，不要将FILE 打包 1、# tar -czvf test.tar.gz a.c //压缩（compress） a.c文件为test.tar.gz 2、tar -tzvf test.tar.gz （列出压缩文件内容）(list) 3、tar -xzvf test.tar.gz（解压）(extract) 4、tar -zpcv -f /root/etc.tar.gz /etc#备份/etc（先su -切换到root） tar -jpcv -f /root/etc.tar.bz2 /etc tar -Jpcv -f /root/etc.tar.xz /etc3.xz创建tar.xz文件：只要先 tar cvf xxx.tar xxx/ 这样创建xxx.tar文件先，然后使用 xz -z xxx.tar 来将 xxx.tar压缩成为 xxx.tar.xz解压tar.xz文件：先 xz -d xxx.tar.xz 将 xxx.tar.xz解压成 xxx.tar 然后，再用 tar xvf xxx.tar来解包。4.子主题 4 软件维护 Ubuntu 12345更新软件源 1.更改源sudo vim /etc/apt/sources.list 2.sudo apt-get update安装软件 3.sudo apt-get install 软件 Centos 1234567891011121314151617181920212223242526271.更改yum源wget 官方源/aliyun 等 -O /etc/yum.repos.d/CenOS-Base.repoyum clean all &amp;&amp; yum makecache #生成缓存2.安装EPEL 源EPEL (Extra Packages for Enterprise Linux)是基于Fedora的一个项目，为“红帽系”的操作系统提供额外的软件包，适用于RHEL、CentOS和Scientific Linux.我们在Centos下使用yum安装时往往找不到rpm的情况，官方的rpm repository提供的rpm包也不够丰富，很多时候需要自己编译很痛苦，而EPEL恰恰可以解决这两方面的问题。EPEL的全称叫 Extra Packages for Enterprise Linux 。EPEL是由 Fedora 社区打造，为 RHEL 及衍生发行版如 CentOS、Scientific Linux 等提供高质量软件包的项目。装上了 EPEL之后，就相当于添加了一个第三方源。————————————————版权声明：本文为CSDN博主「不忘初心fight」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。原文链接：https://blog.csdn.net/weixin_41831919/article/details/1090359361）yum install -y epel-release [root@192 daos]# ll /etc/yum.repos.d/total 52-rw-r--r--. 1 root root 1664 Oct 23 2020 CentOS-Base.repo-rw-r--r--. 1 root root 2523 Dec 26 2020 CentOS-Base.repo.aliyun-rw-r--r--. 1 root root 1309 Nov 23 2020 CentOS-CR.repo-rw-r--r--. 1 root root 649 Nov 23 2020 CentOS-Debuginfo.repo-rw-r--r--. 1 root root 314 Nov 23 2020 CentOS-fasttrack.repo-rw-r--r--. 1 root root 630 Nov 23 2020 CentOS-Media.repo-rw-r--r--. 1 root root 1331 Nov 23 2020 CentOS-Sources.repo-rw-r--r--. 1 root root 8515 Nov 23 2020 CentOS-Vault.repo-rw-r--r--. 1 root root 616 Nov 23 2020 CentOS-x86_64-kernel.repo-rw-r--r--. 1 root root 951 Oct 2 2017 epel.repo-rw-r--r--. 1 root root 1050 Oct 2 2017 epel-testing.repo2）yum repolist3) yum clean all &amp;&amp; yum makecache 其他 11.set -e # shell文件开头加上set -e,这句语句告诉bash如果任何语句的执行结果不是true则应该退出 自定义安装软件环境变量设置 Linux环境变量配置方法一：export PATH使用export命令直接修改PATH的值，配置MySQL进入环境变量的方法: 1234export PATH=/home/uusama/mysql/bin:$PATH# 或者把PATH放在前面export PATH=$PATH:/home/uusama/mysql/bin 注意事项： 生效时间：立即生效 生效期限：当前终端有效，窗口关闭后无效 生效范围：仅对当前用户有效 配置的环境变量中不要忘了加上原来的配置，即$PATH部分，避免覆盖原来配置 Linux环境变量配置方法二：vim ~/.bashrc通过修改用户目录下的~/.bashrc文件进行配置： 1234vim ~/.bashrc# 在最后一行加上export PATH=$PATH:/home/uusama/mysql/bin 注意事项： 生效时间：使用相同的用户打开新的终端时生效，或者手动source ~/.bashrc生效 生效期限：永久有效 生效范围：仅对当前用户有效 如果有后续的环境变量加载文件覆盖了PATH定义，则可能不生效 Linux环境变量配置方法三：vim ~/.bash_profile和修改~/.bashrc文件类似，也是要在文件最后加上新的路径即可： 1234vim ~/.bash_profile# 在最后一行加上export PATH=$PATH:/home/uusama/mysql/bin 注意事项： 生效时间：使用相同的用户打开新的终端时生效，或者手动source ~/.bash_profile生效 生效期限：永久有效 生效范围：仅对当前用户有效 如果没有~/.bash_profile文件，则可以编辑~/.profile文件或者新建一个 Linux环境变量配置方法四：vim /etc/bashrc该方法是修改系统配置，需要管理员权限（如root）或者对该文件的写入权限： 1234567# 如果/etc/bashrc文件不可编辑，需要修改为可编辑chmod -v u+w /etc/bashrcvim /etc/bashrc# 在最后一行加上export PATH=$PATH:/home/uusama/mysql/bin 注意事项： 生效时间：新开终端生效，或者手动source /etc/bashrc生效 生效期限：永久有效 生效范围：对所有用户有效 Linux环境变量配置方法五：vim /etc/profile该方法修改系统配置，需要管理员权限或者对该文件的写入权限，和vim /etc/bashrc类似： 1234567# 如果/etc/profile文件不可编辑，需要修改为可编辑chmod -v u+w /etc/profilevim /etc/profile# 在最后一行加上export PATH=$PATH:/home/uusama/mysql/bin 注意事项： 生效时间：新开终端生效，或者手动source /etc/profile生效 生效期限：永久有效 生效范围：对所有用户有效 Linux环境变量配置方法六：vim /etc/environment该方法是修改系统环境配置文件，需要管理员权限或者对该文件的写入权限： 1234567# 如果/etc/bashrc文件不可编辑，需要修改为可编辑chmod -v u+w /etc/environmentvim /etc/profile# 在最后一行加上export PATH=$PATH:/home/uusama/mysql/bin 注意事项： 生效时间：新开终端生效，或者手动source /etc/environment生效 生效期限：永久有效 生效范围：对所有用户有效 Linux环境变量加载原理解析上面列出了环境变量的各种配置方法，那么Linux是如何加载这些配置的呢？是以什么样的顺序加载的呢？ 特定的加载顺序会导致相同名称的环境变量定义被覆盖或者不生效。 环境变量的分类环境变量可以简单的分成用户自定义的环境变量以及系统级别的环境变量。 用户级别环境变量定义文件：~/.bashrc、~/.profile（部分系统为：~/.bash_profile） 系统级别环境变量定义文件：/etc/bashrc、/etc/profile(部分系统为：/etc/bash_profile）、/etc/environment 另外在用户环境变量中，系统会首先读取~/.bash_profile（或者~/.profile）文件，如果没有该文件则读取~/.bash_login，根据这些文件中内容再去读取~/.bashrc。 测试Linux环境变量加载顺序的方法为了测试各个不同文件的环境变量加载顺序，我们在每个环境变量定义文件中的第一行都定义相同的环境变量UU_ORDER，该变量的值为本身的值连接上当前文件名称。 需要修改的文件如下： /etc/environment /etc/profile /etc/profile.d/test.sh，新建文件，没有文件夹可略过 /etc/bashrc，或者/etc/bash.bashrc ~/.bash_profile，或者~/.profile ~/.bashrc 在每个文件中的第一行都加上下面这句代码，并相应的把冒号后的内容修改为当前文件的绝对文件名。 1export UU_ORDER=&quot;$UU_ORDER:~/.bash_profile&quot; 修改完之后保存，新开一个窗口，然后echo $UU_ORDER观察变量的值： 12uusama@ubuntu:~$ echo $UU_ORDER$UU_ORDER:/etc/environment:/etc/profile:/etc/bash.bashrc:/etc/profile.d/test.sh:~/.profile:~/.bashrc 可以推测出Linux加载环境变量的顺序如下： /etc/environment /etc/profile /etc/bash.bashrc /etc/profile.d/test.sh ~/.profile ~/.bashrc Linux环境变量文件加载详解由上面的测试可容易得出Linux加载环境变量的顺序如下，： 系统环境变量 -&gt; 用户自定义环境变量/etc/environment -&gt; /etc/profile -&gt; ~/.profile 打开/etc/profile文件你会发现，该文件的代码中会加载/etc/bash.bashrc文件，然后检查/etc/profile.d/目录下的.sh文件并加载。 123456789101112131415161718192021222324252627# /etc/profile: system-wide .profile file for the Bourne shell (sh(1))# and Bourne compatible shells (bash(1), ksh(1), ash(1), ...).if [ &quot;$PS1&quot; ]; then if [ &quot;$BASH&quot; ] &amp;&amp; [ &quot;$BASH&quot; != &quot;/bin/sh&quot; ]; then # The file bash.bashrc already sets the default PS1. # PS1=&#x27;\\h:\\w\\$ &#x27; if [ -f /etc/bash.bashrc ]; then . /etc/bash.bashrc fi else if [ &quot;`id -u`&quot; -eq 0 ]; then PS1=&#x27;# &#x27; else PS1=&#x27;$ &#x27; fi fifiif [ -d /etc/profile.d ]; then for i in /etc/profile.d/*.sh; do if [ -r $i ]; then . $i fi done unset ifi 其次再打开~/.profile文件，会发现该文件中加载了~/.bashrc文件。 12345678910# if running bashif [ -n &quot;$BASH_VERSION&quot; ]; then # include .bashrc if it exists if [ -f &quot;$HOME/.bashrc&quot; ]; then . &quot;$HOME/.bashrc&quot; fifi# set PATH so it includes user&#x27;s private bin directoriesPATH=&quot;$HOME/bin:$HOME/.local/bin:$PATH&quot; 从~/.profile文件中代码不难发现，/.profile文件只在用户登录的时候读取一次，而/.bashrc会在每次运行Shell脚本的时候读取一次。 一些小技巧可以自定义一个环境变量文件，比如在某个项目下定义uusama.profile，在这个文件中使用export定义一系列变量，然后在~/.profile文件后面加上：sourc uusama.profile，这样你每次登陆都可以在Shell脚本中使用自己定义的一系列变量。 也可以使用alias命令定义一些命令的别名，比如alias rm=&quot;rm -i&quot;（双引号必须），并把这个代码加入到~/.profile中，这样你每次使用rm命令的时候，都相当于使用rm -i命令，非常方便。 rpm包管理123456基本指令：rpm --import https://packages.daos.io/RPM-GPG-KEY#导入签名后再打开rpm -i *.rpm #打开rpmrpmbuild -ba rpmbuild/SPECS/*.spec #编译rpm -ql rpmdevtools | grep bin #查看 rpmdevtools package 安装的bin,当然也可查询其他工具的binrpmlint -i .spec #build 之前使用rpmlint查找SPEC文件和RPM包的常见错误，如果返回错误/警告，使用 “-i” 选项查看更详细的信息。 制作rpm包参考https://gohalo.me/post/linux-create-rpm-package.html 规范 步骤 常见问题：","categories":[{"name":"Linux","slug":"Linux","permalink":"https://hxlpub.github.io/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://hxlpub.github.io/tags/Linux/"}]},{"title":"shell","slug":"linux_shell","date":"2021-09-14T09:26:07.000Z","updated":"2022-07-25T08:16:45.419Z","comments":true,"path":"2021/09/14/linux_shell/","link":"","permalink":"https://hxlpub.github.io/2021/09/14/linux_shell/","excerpt":"","text":"符号 读文件方法https://blog.csdn.net/feixiaohuijava/article/details/53129413 重定向​ 在shell脚本中，默认情况下，总是有三个文件处于打开状态，标准输入(键盘输入)、标准输出（输出到屏幕）、标准错误（也是输出到屏幕），它们分别对应的文件描述符是0，1，2 。 &gt; 默认为标准输出重定向，与 1&gt; 相同 ls a.txt b.txt 1&gt;file.out 2&gt;file.err 将标准输出重定向到file.out,将标准错误输出重定向到file.err 2&gt;&amp;1 意思是把 标准错误输出 重定向到 标准输出通道1. 2&gt;1 把 标准错误输出 重定向到 文件1 &amp;&gt;file 标准输出 和 标准错误输出 都重定向到文件file中 /dev/null 是一个文件，这个文件比较特殊，所有传给它的东西它都丢弃掉 rm -f $(find / -name core) &amp;&gt; /dev/null 实例 说明 grep da * &gt; greplog1 只有正常输出内容 grep da * &gt; greplog2 1&gt;&amp;2 什么都没有 grep da * &gt; greplog3 2&gt;&amp;1 既有正常输出内容又有错误输出内容 三剑客：sed\\grep\\awk sed -e：","categories":[{"name":"Linux","slug":"Linux","permalink":"https://hxlpub.github.io/categories/Linux/"}],"tags":[{"name":"shell","slug":"shell","permalink":"https://hxlpub.github.io/tags/shell/"}]},{"title":"常用的开源资源","slug":"linux_sites","date":"2021-09-14T09:26:07.000Z","updated":"2022-03-26T09:10:59.432Z","comments":true,"path":"2021/09/14/linux_sites/","link":"","permalink":"https://hxlpub.github.io/2021/09/14/linux_sites/","excerpt":"","text":"ubuntu: Ubuntu 命令技巧","categories":[{"name":"Linux","slug":"Linux","permalink":"https://hxlpub.github.io/categories/Linux/"}],"tags":[{"name":"open_sites","slug":"open-sites","permalink":"https://hxlpub.github.io/tags/open-sites/"}]},{"title":"学习思路","slug":"machine-learning","date":"2021-09-14T09:26:07.000Z","updated":"2022-03-26T09:11:36.082Z","comments":true,"path":"2021/09/14/machine-learning/","link":"","permalink":"https://hxlpub.github.io/2021/09/14/machine-learning/","excerpt":"","text":"","categories":[{"name":"机器学习","slug":"机器学习","permalink":"https://hxlpub.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"ML","slug":"ML","permalink":"https://hxlpub.github.io/tags/ML/"}]},{"title":"编译常见问题FAQ","slug":"linux_soft_manage_FAq","date":"2021-09-14T09:26:07.000Z","updated":"2022-03-26T09:11:23.177Z","comments":true,"path":"2021/09/14/linux_soft_manage_FAq/","link":"","permalink":"https://hxlpub.github.io/2021/09/14/linux_soft_manage_FAq/","excerpt":"","text":"1.执行dnf install python3 ：bash: /usr/bin/dnf: /usr/bin/python3: bad interpreter: No such file or directory 12345678#原因，安装其他软件导致python 版本同dnf 配置文件里的python 版本不一致[root@192 /]# whereis dnf dnf: /usr/bin/dnf /etc/dnf /usr/share/man/man8/dnf.8.gz[root@192 /]# vim /usr/bin/dnf#!/usr/bin/python3.9# The dnf executable script.# error while loading shared libraries: librte_telemetry.so.21: cannot open shared object file: No such file or directory 1234vim /etc/ld.so.conf#加入so lib path如/usr/local/daos/prereq/release/spdk/libldconfig 更新一下配置 3.ldd 查看 库 no found 123vim /etc/ld.so.conf 加相应的库路径，如/usr/local/daos/prereq/release/spdk/lib 后ldconfig","categories":[{"name":"Linux","slug":"Linux","permalink":"https://hxlpub.github.io/categories/Linux/"}],"tags":[{"name":"编译FAQ","slug":"编译FAQ","permalink":"https://hxlpub.github.io/tags/%E7%BC%96%E8%AF%91FAQ/"}]},{"title":"vscode extensions离线下载安装","slug":"vscode_extensions","date":"2021-09-14T09:26:07.000Z","updated":"2022-03-26T09:12:24.690Z","comments":true,"path":"2021/09/14/vscode_extensions/","link":"","permalink":"https://hxlpub.github.io/2021/09/14/vscode_extensions/","excerpt":"","text":"1.windows step1 ：下载扩展包，https://marketplace.visualstudio.com/search?term=go&amp;target=VSCode&amp;category=All%20categories&amp;sortBy=Relevance ,并放到vscode bin 下 step2：安装，bin下右键打开命令行工具，执行 1code --install-extension *.vsix step3: 显示安装完成 Extension ‘yzhang.markdown-all-in-one-1.4.0.vsix’ was successfully installed!","categories":[{"name":"开发工具","slug":"开发工具","permalink":"https://hxlpub.github.io/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"vscode_extensions","slug":"vscode-extensions","permalink":"https://hxlpub.github.io/tags/vscode-extensions/"}]},{"title":"golang linux编译运行环境搭建","slug":"go_compile","date":"2021-09-13T14:29:54.000Z","updated":"2022-05-14T09:37:21.896Z","comments":true,"path":"2021/09/13/go_compile/","link":"","permalink":"https://hxlpub.github.io/2021/09/13/go_compile/","excerpt":"","text":"1.最直接的方式​ 官网提供了第一手资料，十分全面，可以根据自己的系统（windows、linux、mac）选择自己的下载和安装方式 点击进入官网 2.源码编译方式2.1 准备 交叉编译工具链： 交叉编译：是A机器上编译生成，运行在B机器上。两个机子有不同的机器指令。 工具链：一般由编译器、连接器、解释器和调试器组成。 构建交叉工具链方法： 方法一：分步编译和安装交叉编译工具链所需要的库和源代码，最终生成交叉编译工具链。该方法相对比较困难，适合想深入学习构建交叉工具链的读者。如果只是想使用交叉工具链，建议使用下列的方法二构建交叉工具链。 方法二 通过Crosstool脚本工具来实现一次编译，生成交叉编译工具链，该方法相对于方法一要简单许多，并且出错的机会也非常少，建议大多数情况下使用该方法构建交叉编译工具链。 方法三 直接通过网上下载已经制作好的交叉编译工具链。该方法的优点不用多说，当然是简单省事，但该方法有一定的弊端就是局限性太大，因为毕竟是别人构建好的，也就是固定的，没有灵活性，所以构建所用的库以及编译器的版本也许并不适合你要编译的程序，同时也许会在使用时出现许多莫名其妙的错误，建议读者慎用此方法。 2.2 安装编译工具链3.编译参数","categories":[{"name":"golang","slug":"golang","permalink":"https://hxlpub.github.io/categories/golang/"}],"tags":[{"name":"golang","slug":"golang","permalink":"https://hxlpub.github.io/tags/golang/"}]},{"title":"golang fan-out模式","slug":"go_fan-out","date":"2021-09-13T14:29:54.000Z","updated":"2022-05-14T02:31:49.532Z","comments":true,"path":"2021/09/13/go_fan-out/","link":"","permalink":"https://hxlpub.github.io/2021/09/13/go_fan-out/","excerpt":"","text":"Go 语言在构建微服务、特别是有使用 gRPC 的应用中，非常地流行，其实在构建命令行程序时也是特别地好用。为了学习扇出模式，我会基于我们公司使用 ETL 的例子，来介绍这个模式。 ## ETL ETL（提取（Extract），转换（Transform），加载（Load））通常都需要处理大量的数据。在这样的场景下，有一个好的并发策略对于 ETL 来说，能够带来巨大的性能提升。 ETL 中有两个最重要的部分是提取（extracting）和加载（Load），通常它们都跟数据库有关，瓶颈通常也属于老生常谈的话题：网络带宽，查询性能等等。基于我们要处理的数据以及瓶颈所在，两种模式对于处理数据或者处理输入流的编码和解码过程中，非常有用。 ## 扇入扇出模式（Fan-in, fan-out pattern） 扇入和扇出模式在并发场景中能得到较大的好处。这里将对它们逐个做专门的介绍（review）： 扇出，在 GO 博客中这样定义： 多个函数能够同时从相同的 channel 中读数据，直到 channel 关闭。 这种模式在快速输入流到分布式数据处理中，有一定的优势： 扇入，在 Google 这样定义： 一个函数可以从多个输入中读取，并继续操作，直到所有 channel 所关联的输入端，都已经关闭。 这种模式，在有多个输入源，且需要快速地数据处理中，有一定的优势： ## 在实际中使用扇出模式（Fan-out in action） 在我们的项目中，我们需要处理存储在 CSV 文件的大量数据，它们加载后，将在 elastic 中被检索。输入的处理必须快，否则（阻塞加载）加载就会变得很慢。因此，我们需要比输入生成器更多的数据处理器。扇出模式在这个例子中，看起来非常适合： 下面是我们的伪代码： bash Variables: data chan Start: // a goroutine will parse the CSV and will send it to the channel ParseCSV(data&lt;-) // a goroutine is started for each workers, defined as command line arguments For each worker in workers Start goroutine For each value in &lt;-data Insert the value in database by chunk of 50 Wait for the workers Stop 输入和加载程序是并发执行的，我们不需要等到解析完成后再开始启动数据处理程序。 这种模式让我们可以单独考虑业务逻辑的同时，还可以使用（Go)并发的特性。几个工作器之间原生的分布式负载能力，有助于我们解决此类过程中的峰值负载问题。","categories":[{"name":"golang","slug":"golang","permalink":"https://hxlpub.github.io/categories/golang/"}],"tags":[{"name":"golang","slug":"golang","permalink":"https://hxlpub.github.io/tags/golang/"}]},{"title":"golang 内建函数","slug":"go_func_builtin","date":"2021-09-13T14:29:54.000Z","updated":"2022-05-14T02:31:56.974Z","comments":true,"path":"2021/09/13/go_func_builtin/","link":"","permalink":"https://hxlpub.github.io/2021/09/13/go_func_builtin/","excerpt":"","text":"1、new and make :https://www.jb51.net/article/126703.htm","categories":[{"name":"golang","slug":"golang","permalink":"https://hxlpub.github.io/categories/golang/"}],"tags":[{"name":"golang","slug":"golang","permalink":"https://hxlpub.github.io/tags/golang/"}]},{"title":"golang import rules","slug":"go_import_rules","date":"2021-09-13T14:29:54.000Z","updated":"2022-05-22T13:13:56.334Z","comments":true,"path":"2021/09/13/go_import_rules/","link":"","permalink":"https://hxlpub.github.io/2021/09/13/go_import_rules/","excerpt":"","text":"https://www.cnblogs.com/f-ck-need-u/p/9847554.html 模块管理三种方法： 1.GOPATH、GOROOT 2.vendor 3.","categories":[{"name":"golang","slug":"golang","permalink":"https://hxlpub.github.io/categories/golang/"}],"tags":[{"name":"golang","slug":"golang","permalink":"https://hxlpub.github.io/tags/golang/"}]},{"title":"golang 标准包","slug":"go_packages","date":"2021-09-13T14:29:54.000Z","updated":"2022-05-14T02:32:21.973Z","comments":true,"path":"2021/09/13/go_packages/","link":"","permalink":"https://hxlpub.github.io/2021/09/13/go_packages/","excerpt":"","text":"","categories":[{"name":"golang","slug":"golang","permalink":"https://hxlpub.github.io/categories/golang/"}],"tags":[{"name":"golang","slug":"golang","permalink":"https://hxlpub.github.io/tags/golang/"}]},{"title":"notes","slug":"love","date":"2021-09-12T09:05:23.000Z","updated":"2022-03-26T08:48:12.204Z","comments":true,"path":"2021/09/12/love/","link":"","permalink":"https://hxlpub.github.io/2021/09/12/love/","excerpt":"","text":"ps:宝宝，爱你！！！","categories":[{"name":"startup","slug":"startup","permalink":"https://hxlpub.github.io/categories/startup/"}],"tags":[{"name":"love","slug":"love","permalink":"https://hxlpub.github.io/tags/love/"}]}],"categories":[{"name":"分布式存储","slug":"分布式存储","permalink":"https://hxlpub.github.io/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8/"},{"name":"编程语言","slug":"编程语言","permalink":"https://hxlpub.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"Linux","slug":"Linux","permalink":"https://hxlpub.github.io/categories/Linux/"},{"name":"开发工具","slug":"开发工具","permalink":"https://hxlpub.github.io/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"},{"name":"debug","slug":"debug","permalink":"https://hxlpub.github.io/categories/debug/"},{"name":"HPC","slug":"HPC","permalink":"https://hxlpub.github.io/categories/HPC/"},{"name":"存储-basics","slug":"存储-basics","permalink":"https://hxlpub.github.io/categories/%E5%AD%98%E5%82%A8-basics/"},{"name":"daos","slug":"daos","permalink":"https://hxlpub.github.io/categories/daos/"},{"name":"git","slug":"git","permalink":"https://hxlpub.github.io/categories/git/"},{"name":"数据结构&算法分析","slug":"数据结构-算法分析","permalink":"https://hxlpub.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/"},{"name":"codes","slug":"codes","permalink":"https://hxlpub.github.io/categories/codes/"},{"name":"Python","slug":"Python","permalink":"https://hxlpub.github.io/categories/Python/"},{"name":"startup","slug":"startup","permalink":"https://hxlpub.github.io/categories/startup/"},{"name":"设计模式","slug":"设计模式","permalink":"https://hxlpub.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"golang","slug":"golang","permalink":"https://hxlpub.github.io/categories/golang/"},{"name":"编译","slug":"编译","permalink":"https://hxlpub.github.io/categories/%E7%BC%96%E8%AF%91/"},{"name":"Hexo","slug":"Hexo","permalink":"https://hxlpub.github.io/categories/Hexo/"},{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://hxlpub.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"计算机视觉CV","slug":"计算机视觉CV","permalink":"https://hxlpub.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89CV/"},{"name":"数据库","slug":"数据库","permalink":"https://hxlpub.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"深度学习","slug":"深度学习","permalink":"https://hxlpub.github.io/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"},{"name":"机器学习","slug":"机器学习","permalink":"https://hxlpub.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"分布式对象存储","slug":"分布式对象存储","permalink":"https://hxlpub.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AF%B9%E8%B1%A1%E5%AD%98%E5%82%A8/"},{"name":"C","slug":"C","permalink":"https://hxlpub.github.io/tags/C/"},{"name":"rpm","slug":"rpm","permalink":"https://hxlpub.github.io/tags/rpm/"},{"name":"xmind","slug":"xmind","permalink":"https://hxlpub.github.io/tags/xmind/"},{"name":"coredump","slug":"coredump","permalink":"https://hxlpub.github.io/tags/coredump/"},{"name":"HPC","slug":"HPC","permalink":"https://hxlpub.github.io/tags/HPC/"},{"name":"存储","slug":"存储","permalink":"https://hxlpub.github.io/tags/%E5%AD%98%E5%82%A8/"},{"name":"分布式对象存储daos","slug":"分布式对象存储daos","permalink":"https://hxlpub.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AF%B9%E8%B1%A1%E5%AD%98%E5%82%A8daos/"},{"name":"版本管理","slug":"版本管理","permalink":"https://hxlpub.github.io/tags/%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86/"},{"name":"Typora","slug":"Typora","permalink":"https://hxlpub.github.io/tags/Typora/"},{"name":"Structures&Algorithm","slug":"Structures-Algorithm","permalink":"https://hxlpub.github.io/tags/Structures-Algorithm/"},{"name":"codes","slug":"codes","permalink":"https://hxlpub.github.io/tags/codes/"},{"name":"Python","slug":"Python","permalink":"https://hxlpub.github.io/tags/Python/"},{"name":"python","slug":"python","permalink":"https://hxlpub.github.io/tags/python/"},{"name":"Linux","slug":"Linux","permalink":"https://hxlpub.github.io/tags/Linux/"},{"name":"systemd","slug":"systemd","permalink":"https://hxlpub.github.io/tags/systemd/"},{"name":"love more","slug":"love-more","permalink":"https://hxlpub.github.io/tags/love-more/"},{"name":"设计模式","slug":"设计模式","permalink":"https://hxlpub.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"golang","slug":"golang","permalink":"https://hxlpub.github.io/tags/golang/"},{"name":"Makefile","slug":"Makefile","permalink":"https://hxlpub.github.io/tags/Makefile/"},{"name":"c++","slug":"c","permalink":"https://hxlpub.github.io/tags/c/"},{"name":"Hexo","slug":"Hexo","permalink":"https://hxlpub.github.io/tags/Hexo/"},{"name":"排序","slug":"排序","permalink":"https://hxlpub.github.io/tags/%E6%8E%92%E5%BA%8F/"},{"name":"编译","slug":"编译","permalink":"https://hxlpub.github.io/tags/%E7%BC%96%E8%AF%91/"},{"name":"cv","slug":"cv","permalink":"https://hxlpub.github.io/tags/cv/"},{"name":"postgres","slug":"postgres","permalink":"https://hxlpub.github.io/tags/postgres/"},{"name":"pg","slug":"pg","permalink":"https://hxlpub.github.io/tags/pg/"},{"name":"debug","slug":"debug","permalink":"https://hxlpub.github.io/tags/debug/"},{"name":"DL","slug":"DL","permalink":"https://hxlpub.github.io/tags/DL/"},{"name":"linux","slug":"linux","permalink":"https://hxlpub.github.io/tags/linux/"},{"name":"shell","slug":"shell","permalink":"https://hxlpub.github.io/tags/shell/"},{"name":"open_sites","slug":"open-sites","permalink":"https://hxlpub.github.io/tags/open-sites/"},{"name":"ML","slug":"ML","permalink":"https://hxlpub.github.io/tags/ML/"},{"name":"编译FAQ","slug":"编译FAQ","permalink":"https://hxlpub.github.io/tags/%E7%BC%96%E8%AF%91FAQ/"},{"name":"vscode_extensions","slug":"vscode-extensions","permalink":"https://hxlpub.github.io/tags/vscode-extensions/"},{"name":"love","slug":"love","permalink":"https://hxlpub.github.io/tags/love/"}]}