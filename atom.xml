<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hongxun&#39;s Blog</title>
  
  
  <link href="https://hxlpub.github.io/atom.xml" rel="self"/>
  
  <link href="https://hxlpub.github.io/"/>
  <updated>2023-05-28T12:08:54.208Z</updated>
  <id>https://hxlpub.github.io/</id>
  
  <author>
    <name>Hongxun</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>【Python】构建python知识体系：basics</title>
    <link href="https://hxlpub.github.io/2023/05/28/Python/"/>
    <id>https://hxlpub.github.io/2023/05/28/Python/</id>
    <published>2023-05-28T09:26:07.000Z</published>
    <updated>2023-05-28T12:08:54.208Z</updated>
    
    <content type="html"><![CDATA[<ol><li><h5 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h5><p>import 时找不到模块，修改python sys.path  </p><blockquote><blockquote><blockquote><p>import sys<br>sys.path.append(‘/home/daos/site_scons’)</p></blockquote></blockquote></blockquote></li><li><h5 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h5><ul><li><p>编码</p><p>默认情况下，Python 3 源码文件以 <strong>UTF-8</strong> 编码，所有字符串都是 unicode 字符串。 当然你也可以为源码文件指定不同的编码：</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: cp-1252 -*-</span></span><br></pre></td></tr></table></figure><ul><li><p>标识符</p><ul><li><p>第一个字符必须是字母表中字母或下划线 <strong>_</strong> 。</p></li><li><p>标识符的其他的部分由字母、数字和下划线组成。</p></li><li><p>标识符对大小写敏感。</p><p>在 Python 3 中，可以用中文作为变量名，非 ASCII 标识符也是允许的了。</p></li></ul></li><li><p>保留字(关键字)</p><p>保留字即关键字，我们不能把它们用作任何标识符名称。Python 的标准库提供了一个 keyword 模块，可以输出当前版本的所有关键字：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> keyword</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>keyword.kwlist</span><br><span class="line">[<span class="string">&#x27;False&#x27;</span>, <span class="string">&#x27;None&#x27;</span>, <span class="string">&#x27;True&#x27;</span>, <span class="string">&#x27;__peg_parser__&#x27;</span>, <span class="string">&#x27;and&#x27;</span>, <span class="string">&#x27;as&#x27;</span>, <span class="string">&#x27;assert&#x27;</span>, <span class="string">&#x27;async&#x27;</span>, <span class="string">&#x27;await&#x27;</span>, <span class="string">&#x27;break&#x27;</span>, <span class="string">&#x27;class&#x27;</span>, <span class="string">&#x27;continue&#x27;</span>, <span class="string">&#x27;def&#x27;</span>, <span class="string">&#x27;del&#x27;</span>, <span class="string">&#x27;elif&#x27;</span>, <span class="string">&#x27;else&#x27;</span>, <span class="string">&#x27;except&#x27;</span>, <span class="string">&#x27;finally&#x27;</span>, <span class="string">&#x27;for&#x27;</span>, <span class="string">&#x27;from&#x27;</span>, <span class="string">&#x27;global&#x27;</span>, <span class="string">&#x27;if&#x27;</span>, <span class="string">&#x27;import&#x27;</span>, <span class="string">&#x27;in&#x27;</span>, <span class="string">&#x27;is&#x27;</span>, <span class="string">&#x27;lambda&#x27;</span>, <span class="string">&#x27;nonlocal&#x27;</span>, <span class="string">&#x27;not&#x27;</span>, <span class="string">&#x27;or&#x27;</span>, <span class="string">&#x27;pass&#x27;</span>, <span class="string">&#x27;raise&#x27;</span>, <span class="string">&#x27;return&#x27;</span>, <span class="string">&#x27;try&#x27;</span>, <span class="string">&#x27;while&#x27;</span>, <span class="string">&#x27;with&#x27;</span>, <span class="string">&#x27;yield&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>注释</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">   ```</span><br><span class="line"><span class="comment"># 单行注释 #</span></span><br><span class="line">   <span class="built_in">print</span> (<span class="string">&quot;Hello, Python!&quot;</span>) <span class="comment"># 第二个注释、</span></span><br><span class="line">   <span class="comment"># 多行注释 &#x27;&#x27;&#x27;&#x27;注释内容&#x27;&#x27;&#x27; 和&quot;&quot;&quot;注释内容&quot;&quot;&quot;</span></span><br><span class="line">   <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">   第三注释</span></span><br><span class="line"><span class="string">   第四注释</span></span><br><span class="line"><span class="string">   &#x27;&#x27;&#x27;</span></span><br><span class="line">    </span><br><span class="line">   <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">   第五注释</span></span><br><span class="line"><span class="string">   第六注释</span></span><br><span class="line"><span class="string">   &quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure></li><li><p>行与缩进</p><p>python最具特色的就是使用缩进来表示代码块，不需要使用大括号 <strong>{}</strong> 。</p><p>缩进的空格数是可变的，但是同一个代码块的语句必须包含相同的缩进空格数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"> ```</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="literal">True</span>:</span><br><span class="line">     <span class="built_in">print</span> (<span class="string">&quot;Answer&quot;</span>)</span><br><span class="line">     <span class="built_in">print</span> (<span class="string">&quot;True&quot;</span>)</span><br><span class="line"> <span class="keyword">else</span>:</span><br><span class="line">     <span class="built_in">print</span> (<span class="string">&quot;Answer&quot;</span>)</span><br><span class="line">   <span class="built_in">print</span> (<span class="string">&quot;False&quot;</span>)    <span class="comment"># 缩进不一致，会导致运行错误</span></span><br><span class="line"> </span><br><span class="line"> root@<span class="number">192</span> python]<span class="comment"># python test.py </span></span><br><span class="line">   File <span class="string">&quot;/home/tests/python/test.py&quot;</span>, line <span class="number">14</span></span><br><span class="line">     <span class="built_in">print</span> (<span class="string">&quot;False&quot;</span>)</span><br><span class="line">                    ^</span><br><span class="line"> IndentationError: unindent does <span class="keyword">not</span> match <span class="built_in">any</span> outer indentation level</span><br><span class="line"> </span><br></pre></td></tr></table></figure></li><li><p>多行语句</p><p>Python 通常是一行写完一条语句，但如果语句很长，我们可以使用反斜杠 *<em>*</em> 来实现多行语句，例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> ```</span><br><span class="line"></span><br><span class="line">total = item_one + \</span><br><span class="line">         item_two + \</span><br><span class="line">         item_three</span><br></pre></td></tr></table></figure><p>在 [], {}, 或 () 中的多行语句，不需要使用反斜杠 ****，例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">total = [<span class="string">&#x27;item_one&#x27;</span>, <span class="string">&#x27;item_two&#x27;</span>, <span class="string">&#x27;item_three&#x27;</span>,</span><br><span class="line">         <span class="string">&#x27;item_four&#x27;</span>, <span class="string">&#x27;item_five&#x27;</span>]</span><br></pre></td></tr></table></figure></li><li><p>数字类型</p><ul><li><strong>int</strong> (整数), 如 1, 只有一种整数类型 int，表示为长整型，没有 python2 中的 Long。</li></ul></li></ul></li></ol><ul><li><p><strong>bool</strong> (布尔), 如 True。</p><ul><li><strong>float</strong> (浮点数), 如 1.23、3E-2</li><li><strong>complex</strong> (复数), 如 1 + 2j、 1.1 + 2.2j</li></ul></li><li><p>字符串</p><ul><li>Python 中单引号 <strong>‘</strong> 和双引号 <strong>“</strong> 使用完全相同。</li></ul></li><li><p>使用三引号(<strong>‘’’</strong> 或 <strong>“””</strong>)可以指定一个多行字符串。</p><ul><li>转义符 ****。</li><li>反斜杠可以用来转义，使用 <strong>r</strong> 可以让反斜杠不发生转义。 如 <strong>r”this is a line with \n”</strong> 则 <strong>\n</strong> 会显示，并不是换行。</li><li>按字面意义级联字符串，如 <strong>“this “ “is “ “string”</strong> 会被自动转换为 <strong>this is string</strong>。</li><li>字符串可以用 <strong>+</strong> 运算符连接在一起，用 ***** 运算符重复。</li><li>Python 中的字符串有两种索引方式，从左往右以 <strong>0</strong> 开始，从右往左以 <strong>-1</strong> 开始。</li><li>Python 中的字符串不能改变。</li><li>Python 没有单独的字符类型，一个字符就是长度为 1 的字符串。</li><li>字符串的截取的语法格式如下：<strong>变量[头下标:尾下标:步长]</strong></li></ul> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">word = <span class="string">&#x27;字符串&#x27;</span></span><br><span class="line"> sentence = <span class="string">&quot;这是一个句子。&quot;</span></span><br><span class="line"> paragraph = <span class="string">&quot;&quot;&quot;这是一个段落，</span></span><br><span class="line"><span class="string"> 可以由多行组成&quot;&quot;&quot;</span></span><br><span class="line"> <span class="comment">#!/usr/bin/python3</span></span><br><span class="line">  </span><br><span class="line"> <span class="built_in">str</span>=<span class="string">&#x27;123456789&#x27;</span></span><br><span class="line">  </span><br><span class="line"> <span class="built_in">print</span>(<span class="built_in">str</span>)                 <span class="comment"># 输出字符串</span></span><br><span class="line"> <span class="built_in">print</span>(<span class="built_in">str</span>[<span class="number">0</span>:-<span class="number">1</span>])           <span class="comment"># 输出第一个到倒数第二个的所有字符</span></span><br><span class="line"> <span class="built_in">print</span>(<span class="built_in">str</span>[<span class="number">0</span>])              <span class="comment"># 输出字符串第一个字符</span></span><br><span class="line"> <span class="built_in">print</span>(<span class="built_in">str</span>[<span class="number">2</span>:<span class="number">5</span>])            <span class="comment"># 输出从第三个开始到第五个的字符</span></span><br><span class="line"> <span class="built_in">print</span>(<span class="built_in">str</span>[<span class="number">2</span>:])             <span class="comment"># 输出从第三个开始后的所有字符</span></span><br><span class="line"> <span class="built_in">print</span>(<span class="built_in">str</span>[<span class="number">1</span>:<span class="number">5</span>:<span class="number">2</span>])          <span class="comment"># 输出从第二个开始到第五个且每隔一个的字符（步长为2）</span></span><br><span class="line"> <span class="built_in">print</span>(<span class="built_in">str</span> * <span class="number">2</span>)             <span class="comment"># 输出字符串两次</span></span><br><span class="line"> <span class="built_in">print</span>(<span class="built_in">str</span> + <span class="string">&#x27;你好&#x27;</span>)         <span class="comment"># 连接字符串</span></span><br><span class="line">  </span><br><span class="line"> <span class="built_in">print</span>(<span class="string">&#x27;------------------------------&#x27;</span>)</span><br><span class="line">  </span><br><span class="line"> <span class="built_in">print</span>(<span class="string">&#x27;hello\nrunoob&#x27;</span>)      <span class="comment"># 使用反斜杠(\)+n转义特殊字符</span></span><br><span class="line"> <span class="built_in">print</span>(<span class="string">r&#x27;hello\nrunoob&#x27;</span>)     <span class="comment"># 在字符串前面添加一个 r，表示原始字符串，不会发生转义</span></span><br><span class="line"> </span><br><span class="line"> <span class="number">123456789</span></span><br><span class="line"> <span class="number">12345678</span></span><br><span class="line"> <span class="number">1</span></span><br><span class="line"> <span class="number">345</span></span><br><span class="line"> <span class="number">3456789</span></span><br><span class="line"> <span class="number">24</span></span><br><span class="line"> <span class="number">123456789123456789</span></span><br><span class="line"> <span class="number">123456789</span>你好</span><br><span class="line"> ------------------------------</span><br><span class="line"> hello</span><br><span class="line"> runoob</span><br><span class="line"> hello\nrunoob</span><br></pre></td></tr></table></figure></li><li><p>空行</p><p>函数之间或类的方法之间用空行分隔，表示一段新的代码的开始。类和函数入口之间也用一行空行分隔，以突出函数入口的开始。</p><p>空行与代码缩进不同，空行并不是 Python 语法的一部分。书写时不插入空行，Python 解释器运行也不会出错。但是空行的作用在于分隔两段不同功能或含义的代码，便于日后代码的维护或重构。</p><p><strong>记住：</strong>空行也是程序代码的一部分。</p></li><li><p>等待用户输入</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    <span class="built_in">input</span>(<span class="string">&quot;\n\n按下 enter 键后退出。&quot;</span>)</span><br><span class="line">     [root@<span class="number">192</span> python]<span class="comment"># python test.py </span></span><br><span class="line">     <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">​     </span><br><span class="line">​     press enter to exit</span><br><span class="line">​     </span><br><span class="line">​     ```</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">​     </span><br><span class="line"></span><br><span class="line">   - 同一行显示多条语句</span><br><span class="line"></span><br><span class="line">     在同一行中使用多条语句，语句之间使用分号 **;** 分割</span><br><span class="line"></span><br><span class="line">     ```python</span><br><span class="line"></span><br><span class="line">    <span class="keyword">import</span> sys; x = <span class="string">&#x27;runoob&#x27;</span>; sys.stdout.write(x + <span class="string">&#x27;\n&#x27;</span>)</span><br></pre></td></tr></table></figure></li><li><p>多个语句构成代码组</p><p>缩进相同的一组语句构成一个代码块，我们称之代码组。</p><p>像if、while、def和class这样的复合语句，首行以关键字开始，以冒号( : )结束，该行之后的一行或多行代码构成代码组。</p><p>我们将首行及后面的代码组称为一个子句(clause)。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">if</span> expression : </span><br><span class="line">    suite</span><br><span class="line"> <span class="keyword">elif</span> expression : </span><br><span class="line">    suite </span><br><span class="line"> <span class="keyword">else</span> : </span><br><span class="line">    suite</span><br></pre></td></tr></table></figure></li><li><p>print</p><p><strong>print</strong> 默认输出是换行的，如果要实现不换行需要在变量末尾加上 **end=””**：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line">  </span><br><span class="line"> x=<span class="string">&quot;a&quot;</span></span><br><span class="line"> y=<span class="string">&quot;b&quot;</span></span><br><span class="line"> <span class="comment"># 换行输出</span></span><br><span class="line"> <span class="built_in">print</span>( x )</span><br><span class="line"> <span class="built_in">print</span>( y )</span><br><span class="line">  </span><br><span class="line"> <span class="built_in">print</span>(<span class="string">&#x27;---------&#x27;</span>)</span><br><span class="line"> <span class="comment"># 不换行输出</span></span><br><span class="line"> <span class="built_in">print</span>( x, end=<span class="string">&quot; &quot;</span> )</span><br><span class="line"> <span class="built_in">print</span>( y, end=<span class="string">&quot; &quot;</span> )</span><br><span class="line"> <span class="built_in">print</span>()</span><br><span class="line"> </span><br><span class="line"> a</span><br><span class="line"> b</span><br><span class="line"> ---------</span><br><span class="line"> a b</span><br></pre></td></tr></table></figure></li></ul><p>​     </p><ul><li><p>import 与 from … import</p><p>在 python 用 <strong>import</strong> 或者 <strong>from…import</strong> 来导入相应的模块。</p><p>将整个模块(somemodule)导入，格式为： <strong>import somemodule</strong></p><p>从某个模块中导入某个函数,格式为： <strong>from somemodule import somefunction</strong></p><p>从某个模块中导入多个函数,格式为： <strong>from somemodule import firstfunc, secondfunc, thirdfunc</strong></p><p>将某个模块中的全部函数导入，格式为： <strong>from somemodule import *</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">#导入sys 模块</span></span><br><span class="line"> <span class="keyword">import</span> sys</span><br><span class="line"> <span class="built_in">print</span>(<span class="string">&#x27;================Python import mode==========================&#x27;</span>)</span><br><span class="line"> <span class="built_in">print</span> (<span class="string">&#x27;命令行参数为:&#x27;</span>)</span><br><span class="line"> <span class="keyword">for</span> i <span class="keyword">in</span> sys.argv:</span><br><span class="line">     <span class="built_in">print</span> (i)</span><br><span class="line"> <span class="built_in">print</span> (<span class="string">&#x27;\n python 路径为&#x27;</span>,sys.path)</span><br><span class="line"> <span class="comment">#导入sys模块的argv 和path成员</span></span><br><span class="line"> <span class="keyword">from</span> sys <span class="keyword">import</span> argv,path  <span class="comment">#  导入特定的成员</span></span><br><span class="line"> <span class="built_in">print</span>(<span class="string">&#x27;================python from import===================================&#x27;</span>)</span><br><span class="line"> <span class="built_in">print</span>(<span class="string">&#x27;path:&#x27;</span>,path) <span class="comment"># 因为已经导入path成员，所以此处引用时不需要加sys.path</span></span><br></pre></td></tr></table></figure></li><li><p>命令行参数</p><p>稍后补充</p></li></ul><ol start="3"><li><h5 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h5><ul><li><p>变量不需要声明。每个变量在使用前都必须赋值，变量赋值以后该变量才会被创建。</p></li><li><p>变量就是变量，它没有类型，我们所说的”类型”是变量所指的内存中对象的类型。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"></span><br><span class="line">counter = <span class="number">100</span>          <span class="comment"># 整型变量</span></span><br><span class="line">miles   = <span class="number">1000.0</span>       <span class="comment"># 浮点型变量</span></span><br><span class="line">name    = <span class="string">&quot;runoob&quot;</span>     <span class="comment"># 字符串</span></span><br><span class="line"><span class="built_in">print</span> (counter)</span><br><span class="line"><span class="built_in">print</span> (miles)</span><br><span class="line"><span class="built_in">print</span> (name)</span><br></pre></td></tr></table></figure></li><li><p>多变量赋值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = b = c = <span class="number">1</span></span><br><span class="line">a, b, c = <span class="number">1</span>, <span class="number">2</span>, <span class="string">&quot;hello&quot;</span></span><br></pre></td></tr></table></figure></li><li><p>标准数据类型</p><p>python3 中有6中标准数据类型：</p><ul><li>Number（数字）</li><li>String（字符串）</li><li>List（列表）</li><li>Tuple（元组）</li><li>Set（集合）</li><li>Dictionary（字典）</li><li><strong>不可变数据（3 个）：</strong>Number（数字）、String（字符串）、Tuple（元组）；</li><li><strong>可变数据（3 个）：</strong>List（列表）、Dictionary（字典）、Set（集合）。</li></ul></li><li><p>Number</p><p>Python3 支持 <strong>int、float、bool、complex（复数）</strong>。</p><p>内置的 type() 函数可以用来查询变量所指的对象类型。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a, b, c, d = <span class="number">20</span>, <span class="number">5.5</span>, <span class="literal">True</span>, <span class="number">4</span>+<span class="number">3j</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="built_in">type</span>(a), <span class="built_in">type</span>(b), <span class="built_in">type</span>(c), <span class="built_in">type</span>(d))</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> &#x27;<span class="title">int</span>&#x27;&gt; &lt;<span class="title">class</span> &#x27;<span class="title">float</span>&#x27;&gt; &lt;<span class="title">class</span> &#x27;<span class="title">bool</span>&#x27;&gt; &lt;<span class="title">class</span> &#x27;<span class="title">complex</span>&#x27;&gt;</span></span><br></pre></td></tr></table></figure><p>还可以用 isinstance 来判断：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="number">111</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">isinstance</span>(a, <span class="built_in">int</span>)</span><br><span class="line"><span class="literal">True</span></span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><p>isinstance 和 type 的区别在于：</p><ul><li>type()不会认为子类是一种父类类型。</li><li>isinstance()会认为子类是一种父类类型。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">pass</span></span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">B</span>(<span class="params">A</span>):</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">pass</span></span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">isinstance</span>(A(), A)</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">type</span>(A()) == A </span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">isinstance</span>(B(), A)</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">type</span>(B()) == A</span><br><span class="line"><span class="literal">False</span></span><br><span class="line">注意：Python3 中，<span class="built_in">bool</span> 是 <span class="built_in">int</span> 的子类，<span class="literal">True</span> 和 <span class="literal">False</span> 可以和数字相加， <span class="literal">True</span>==<span class="number">1</span>、<span class="literal">False</span>==<span class="number">0</span> 会返回 <span class="literal">True</span>，但可以通过 <span class="keyword">is</span> 来判断类型。</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">issubclass</span>(<span class="built_in">bool</span>, <span class="built_in">int</span>) </span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="literal">True</span>==<span class="number">1</span></span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="literal">False</span>==<span class="number">0</span></span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="literal">True</span>+<span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="literal">False</span>+<span class="number">1</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">1</span> <span class="keyword">is</span> <span class="literal">True</span></span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">0</span> <span class="keyword">is</span> <span class="literal">False</span></span><br><span class="line"><span class="literal">False</span></span><br></pre></td></tr></table></figure><p>使用del语句删除单个或多个对象。例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">del</span> var</span><br><span class="line"><span class="keyword">del</span> var_a, var_b</span><br></pre></td></tr></table></figure><p>数值运算</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">5</span> + <span class="number">4</span>  <span class="comment"># 加法</span></span><br><span class="line"><span class="number">9</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">4.3</span> - <span class="number">2</span> <span class="comment"># 减法</span></span><br><span class="line"><span class="number">2.3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">3</span> * <span class="number">7</span>  <span class="comment"># 乘法</span></span><br><span class="line"><span class="number">21</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">2</span> / <span class="number">4</span>  <span class="comment"># 除法，得到一个浮点数</span></span><br><span class="line"><span class="number">0.5</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">2</span> // <span class="number">4</span> <span class="comment"># 除法，得到一个整数</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">17</span> % <span class="number">3</span> <span class="comment"># 取余</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">2</span> ** <span class="number">5</span> <span class="comment"># 乘方</span></span><br><span class="line"><span class="number">32</span></span><br></pre></td></tr></table></figure></li><li><p>String</p><p>使用单引号’’或双引号””将字符串括起来，并使用\转义特殊字符</p><p>反斜杠()可以作为续行符，表示下一行是上一行的延续。也可以使用 <strong>“””…”””</strong> 或者 <strong>‘’’…’’’</strong> 跨越多行</p><p>字符串的截取格式：变量[头下标:尾下标]</p><p>从前索引：索引值从0开始</p><p>从后索引：索引值从-1开始</p><p>+：字符串连接符</p><p>*数字：复制当前字符串，数字是复制的次数</p><p>实例</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment">#!/usr/bin/python3.6</span></span><br><span class="line"><span class="built_in">str</span> = <span class="string">&#x27;string&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>) </span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>[<span class="number">0</span>:-<span class="number">1</span>])  <span class="comment">#打印第一个到倒数第二个字符</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>[<span class="number">0</span>])     </span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>[<span class="number">2</span>:<span class="number">5</span>])   <span class="comment">#第三个到第五个，注意与上面的[0:-1]有区别</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>*<span class="number">2</span>)     </span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>+<span class="string">&#x27;TEST&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;stri\ng&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">r&#x27;stri\ng&#x27;</span>)</span><br><span class="line"></span><br><span class="line">[root@<span class="number">192</span> python]<span class="comment"># python data_type.py </span></span><br><span class="line">string</span><br><span class="line">strin</span><br><span class="line">s</span><br><span class="line">rin</span><br><span class="line">stringstring</span><br><span class="line">stringTEST</span><br><span class="line">stri</span><br><span class="line">g</span><br><span class="line">stri\ng </span><br></pre></td></tr></table></figure></li><li><p>List</p><p>使用最频繁的数据类型</p><p>列表中元素的类型可以不相同，它支持数字，字符串甚至可以包含列表（所谓嵌套）。</p><ul><li>1、List写在方括号之间，元素用逗号隔开。</li><li>2、和字符串一样，list可以被索引和切片。</li><li>3、List可以使用+操作符进行拼接。</li><li>4、List中的元素是可以改变的。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">变量[头下标:尾下标] 也可以 变量[头下标:尾下标:步长]</span><br><span class="line">索引值以 <span class="number">0</span> 为开始值，-<span class="number">1</span> 为从末尾的开始位置。</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://github.com/hxlpub/imgs/blob/master/list_slicing1_new1.png?raw=true"></p><p>实例1</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">list</span> = [<span class="string">&#x27;a&#x27;</span>, <span class="number">1</span>, <span class="number">2.3</span>, <span class="number">4.56</span>]</span><br><span class="line">tinylist = [<span class="string">&#x27;123&#x27;</span>, <span class="string">&#x27;tinylist&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>[<span class="number">0</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>[<span class="number">1</span>:<span class="number">3</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>[<span class="number">2</span>:])</span><br><span class="line"><span class="built_in">print</span>(tinylist*<span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>+tinylist)</span><br><span class="line"><span class="built_in">list</span>[<span class="number">0</span>] = <span class="number">9</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>)</span><br><span class="line"><span class="built_in">list</span>[<span class="number">1</span>:<span class="number">3</span>] = [<span class="number">8</span>, <span class="number">7</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>)</span><br><span class="line"><span class="built_in">list</span>[<span class="number">3</span>:]=[]</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>)</span><br><span class="line"><span class="built_in">list</span>.append(<span class="number">6</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>[<span class="number">0</span>:<span class="number">3</span>:<span class="number">2</span>])</span><br><span class="line">[root@<span class="number">192</span> python]<span class="comment"># python data_type.py </span></span><br><span class="line">[<span class="string">&#x27;a&#x27;</span>, <span class="number">1</span>, <span class="number">2.3</span>, <span class="number">4.56</span>]</span><br><span class="line">a</span><br><span class="line">[<span class="number">1</span>, <span class="number">2.3</span>]</span><br><span class="line">[<span class="number">2.3</span>, <span class="number">4.56</span>]</span><br><span class="line">[<span class="string">&#x27;123&#x27;</span>, <span class="string">&#x27;tinylist&#x27;</span>, <span class="string">&#x27;123&#x27;</span>, <span class="string">&#x27;tinylist&#x27;</span>]</span><br><span class="line">[<span class="string">&#x27;a&#x27;</span>, <span class="number">1</span>, <span class="number">2.3</span>, <span class="number">4.56</span>, <span class="string">&#x27;123&#x27;</span>, <span class="string">&#x27;tinylist&#x27;</span>]</span><br><span class="line">[<span class="number">9</span>, <span class="number">1</span>, <span class="number">2.3</span>, <span class="number">4.56</span>]</span><br><span class="line">[<span class="number">9</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">4.56</span>]</span><br><span class="line">[<span class="number">9</span>, <span class="number">8</span>, <span class="number">7</span>]</span><br><span class="line">[<span class="number">9</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">6</span>]</span><br><span class="line">[<span class="number">9</span>, <span class="number">7</span>]</span><br></pre></td></tr></table></figure><p>List 内置了很多方法，如append()、pop()等</p><p>实例2 字符翻转</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reverserWords</span>(<span class="params"><span class="built_in">input</span></span>):</span></span><br><span class="line">        inputWords = <span class="built_in">input</span>.split(<span class="string">&#x27; &#x27;</span>)</span><br><span class="line"></span><br><span class="line">        inputWords = inputWords[-<span class="number">1</span>::-<span class="number">1</span>]</span><br><span class="line">        output = <span class="string">&#x27; &#x27;</span>.join(inputWords)</span><br><span class="line">        <span class="keyword">return</span> output</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">        <span class="built_in">input</span> = <span class="string">&#x27;I like you&#x27;</span></span><br><span class="line">        rw = reverserWords(<span class="built_in">input</span>)</span><br><span class="line">        <span class="built_in">print</span>(rw)</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul></li></ol><ul><li><p>元组</p><ul><li><p>1、与字符串一样，元组的元素不能修改。</p><p>虽然tuple的元素不可改变，但它可以包含可变的对象，比如list列表。</p></li><li><p>2、元组也可以被索引和切片，方法一样。</p></li><li><p>3、注意构造包含 0 或 1 个元素的元组的特殊语法规则。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tup1 = ()    <span class="comment"># 空元组</span></span><br><span class="line">tup2 = (<span class="number">20</span>,) <span class="comment"># 一个元素，需要在元素后添加逗号</span></span><br></pre></td></tr></table></figure></li><li><p>4、元组也可以使用+操作符进行拼接。</p></li><li><p>5、</p></li></ul></li><li><p>Set 集合</p><p> 集合（set）是由一个或数个形态各异的大小整体组成的，构成集合的事物或对象称作元素或是成员。</p><p>基本功能是进行成员关系测试和删除重复元素。</p><p>创建格式：注意创建一个空集，必须用set() 而不能用{}（因为{}是用来创建一个空字典）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">parame = &#123;value1, value2, ...&#125;</span><br><span class="line">或者</span><br><span class="line"><span class="built_in">set</span>(value)   </span><br></pre></td></tr></table></figure><p>实例</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#set</span></span><br><span class="line">sites = &#123;<span class="string">&#x27;google&#x27;</span>, <span class="string">&#x27;baidu&#x27;</span>, <span class="string">&#x27;ali&#x27;</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(sites)</span><br><span class="line"><span class="keyword">if</span> <span class="string">&#x27;ali&#x27;</span> <span class="keyword">in</span> sites:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;ali in sites&#x27;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;ali not in sites &#x27;</span>)</span><br><span class="line"><span class="comment">#set 集合运算</span></span><br><span class="line">a=<span class="built_in">set</span>(<span class="string">&#x27;abracadabra&#x27;</span>)</span><br><span class="line">b=<span class="built_in">set</span>(<span class="string">&#x27;alacazam&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="built_in">print</span>(a - b) <span class="comment">#差集</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(a | b) <span class="comment">#并集</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(a &amp; b) <span class="comment">#交集</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(a ^ b) <span class="comment">#a和b中不同时存在的元素</span></span><br><span class="line">输出：</span><br><span class="line"><span class="built_in">set</span>([<span class="string">&#x27;baidu&#x27;</span>, <span class="string">&#x27;google&#x27;</span>, <span class="string">&#x27;ali&#x27;</span>])</span><br><span class="line">ali <span class="keyword">in</span> sites</span><br><span class="line"><span class="built_in">set</span>([<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;r&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>])</span><br><span class="line"><span class="built_in">set</span>([<span class="string">&#x27;r&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;d&#x27;</span>])</span><br><span class="line"><span class="built_in">set</span>([<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;m&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;r&#x27;</span>, <span class="string">&#x27;z&#x27;</span>])</span><br><span class="line"><span class="built_in">set</span>([<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;c&#x27;</span>])</span><br><span class="line"><span class="built_in">set</span>([<span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;m&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;r&#x27;</span>, <span class="string">&#x27;z&#x27;</span>])</span><br></pre></td></tr></table></figure></li><li><p>Dictionary</p><ul><li>1、非常有用的内置数据类型</li><li>2、字典是一种映射类型，它的元素是键值对。一个无序的 <strong>键(key) : 值(value)</strong> 的集合</li><li>3、字典的关键字必须为不可变类型，且不能重复。</li><li>4、创建空字典使用 { }。</li><li>5、在同一个字典中，键(key)必须是唯一的</li><li>6、构造函数 dict() 可以直接从键值对序列中构建字典</li><li>7、字典类型也有一些内置的函数，例如 clear()、keys()、values() 等。</li></ul><p>实例1</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dict</span> = &#123;&#125;</span><br><span class="line"><span class="built_in">dict</span>[<span class="string">&#x27;one&#x27;</span>] = <span class="string">&#x27;you&#x27;</span></span><br><span class="line"><span class="built_in">dict</span>[<span class="number">2</span>] = <span class="string">&#x27;me&#x27;</span></span><br><span class="line">tinydict = &#123;<span class="string">&#x27;one&#x27;</span>:<span class="string">&#x27;you&#x27;</span>, <span class="string">&#x27;two&#x27;</span>:<span class="string">&#x27;and&#x27;</span>, <span class="string">&#x27;three&#x27;</span>:<span class="string">&#x27;me&#x27;</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">dict</span>[<span class="string">&#x27;one&#x27;</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">dict</span>[<span class="number">2</span>])</span><br><span class="line"><span class="built_in">print</span>(tinydict.keys())</span><br><span class="line"><span class="built_in">print</span>(tinydict.values())</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">you</span><br><span class="line">me</span><br><span class="line">[<span class="string">&#x27;three&#x27;</span>, <span class="string">&#x27;two&#x27;</span>, <span class="string">&#x27;one&#x27;</span>]</span><br><span class="line">[<span class="string">&#x27;me&#x27;</span>, <span class="string">&#x27;and&#x27;</span>, <span class="string">&#x27;you&#x27;</span>]</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>实例2</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">dict</span>([(<span class="string">&#x27;Runoob&#x27;</span>, <span class="number">1</span>), (<span class="string">&#x27;Google&#x27;</span>, <span class="number">2</span>), (<span class="string">&#x27;Taobao&#x27;</span>, <span class="number">3</span>)])</span><br><span class="line">&#123;<span class="string">&#x27;Runoob&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;Google&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;Taobao&#x27;</span>: <span class="number">3</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>&#123;x: x**<span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> (<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>)&#125;</span><br><span class="line">&#123;<span class="number">2</span>: <span class="number">4</span>, <span class="number">4</span>: <span class="number">16</span>, <span class="number">6</span>: <span class="number">36</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">dict</span>(Runoob=<span class="number">1</span>, Google=<span class="number">2</span>, Taobao=<span class="number">3</span>)</span><br><span class="line">&#123;<span class="string">&#x27;Runoob&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;Google&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;Taobao&#x27;</span>: <span class="number">3</span>&#125;</span><br></pre></td></tr></table></figure></li></ul><ol start="4"><li><h5 id="数据类型转换"><a href="#数据类型转换" class="headerlink" title="数据类型转换"></a>数据类型转换</h5><p>Python 数据类型转换可以分为两种：</p><ul><li><p>隐式类型转换 - 自动完成</p><p>较低数据类型（整数）就会转换为较高数据类型（浮点数）以避免数据丢失。</p></li><li><p>显式类型转换 - 需要使用类型函数来转换</p><p>在显式类型转换中，用户将对象的数据类型转换为所需的数据类型。 我们使用 int()、float()、str() 等预定义函数来执行显式类型转换。</p><p>整型和字符串类型进行运算，就可以用强制类型转换来完成</p><p>常用的几个内置函数：</p><table><thead><tr><th align="left">函数</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">[int(x <a href="https://www.runoob.com/python3/python-func-int.html">,base])</a></td><td align="left">将x转换为一个整数</td></tr><tr><td align="left"><a href="https://www.runoob.com/python3/python-func-float.html">float(x)</a></td><td align="left">将x转换到一个浮点数</td></tr><tr><td align="left">[complex(real <a href="https://www.runoob.com/python3/python-func-complex.html">,imag])</a></td><td align="left">创建一个复数</td></tr><tr><td align="left"><a href="https://www.runoob.com/python3/python-func-str.html">str(x)</a></td><td align="left">将对象 x 转换为字符串</td></tr><tr><td align="left"><a href="https://www.runoob.com/python3/python-func-repr.html">repr(x)</a></td><td align="left">将对象 x 转换为表达式字符串</td></tr><tr><td align="left"><a href="https://www.runoob.com/python3/python-func-eval.html">eval(str)</a></td><td align="left">用来计算在字符串中的有效Python表达式,并返回一个对象</td></tr><tr><td align="left"><a href="https://www.runoob.com/python3/python3-func-tuple.html">tuple(s)</a></td><td align="left">将序列 s 转换为一个元组</td></tr><tr><td align="left"><a href="https://www.runoob.com/python3/python3-att-list-list.html">list(s)</a></td><td align="left">将序列 s 转换为一个列表</td></tr><tr><td align="left"><a href="https://www.runoob.com/python3/python-func-set.html">set(s)</a></td><td align="left">转换为可变集合</td></tr><tr><td align="left"><a href="https://www.runoob.com/python3/python-func-dict.html">dict(d)</a></td><td align="left">创建一个字典。d 必须是一个 (key, value)元组序列。</td></tr><tr><td align="left"><a href="https://www.runoob.com/python3/python-func-frozenset.html">frozenset(s)</a></td><td align="left">转换为不可变集合</td></tr><tr><td align="left"><a href="https://www.runoob.com/python3/python-func-chr.html">chr(x)</a></td><td align="left">将一个整数转换为一个字符</td></tr><tr><td align="left"><a href="https://www.runoob.com/python3/python-func-ord.html">ord(x)</a></td><td align="left">将一个字符转换为它的整数值</td></tr><tr><td align="left"><a href="https://www.runoob.com/python3/python-func-hex.html">hex(x)</a></td><td align="left">将一个整数转换为一个十六进制字符串</td></tr><tr><td align="left"><a href="https://www.runoob.com/python3/python-func-oct.html">oct(x)</a></td><td align="left"></td></tr></tbody></table></li></ul></li><li><h5 id="推导式"><a href="#推导式" class="headerlink" title="推导式"></a>推导式</h5><p>Python 推导式是一种独特的数据处理方式，可以从一个数据序列构建另一个新的数据序列的结构体。</p><p>Python 支持各种数据结构的推导式：</p><ul><li>列表(list)推导式</li><li>字典(dict)推导式</li><li>集合(set)推导式</li><li>元组(tuple)推导式</li></ul><p><strong>列表推导式</strong></p><p>​    推导式格式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[表达式 <span class="keyword">for</span> 变量 <span class="keyword">in</span> 列表] </span><br><span class="line">[out_exp_res <span class="keyword">for</span> out_exp <span class="keyword">in</span> input_list]</span><br><span class="line">或者 </span><br><span class="line">[表达式 <span class="keyword">for</span> 变量 <span class="keyword">in</span> 列表 <span class="keyword">if</span> 条件]</span><br><span class="line">[out_exp_res <span class="keyword">for</span> out_exp <span class="keyword">in</span> input_list <span class="keyword">if</span> condition]</span><br><span class="line">说明</span><br><span class="line">out_exp_res：列表生成元素表达式，可以是有返回值的函数。</span><br><span class="line"><span class="keyword">for</span> out_exp <span class="keyword">in</span> input_list：迭代 input_list 将 out_exp 传入到 out_exp_res 表达式中。</span><br><span class="line"><span class="keyword">if</span> condition：条件语句，可以过滤列表中不符合条件的值。</span><br></pre></td></tr></table></figure><p>实例1：过滤掉长度小于或等于3的字符串列表，并将剩下的转换成大写字母：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>names = [<span class="string">&#x27;Bob&#x27;</span>,<span class="string">&#x27;Tom&#x27;</span>,<span class="string">&#x27;alice&#x27;</span>,<span class="string">&#x27;Jerry&#x27;</span>,<span class="string">&#x27;Wendy&#x27;</span>,<span class="string">&#x27;Smith&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>new_names = [name.upper()<span class="keyword">for</span> name <span class="keyword">in</span> names <span class="keyword">if</span> <span class="built_in">len</span>(name)&gt;<span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(new_names)</span><br><span class="line">[<span class="string">&#x27;ALICE&#x27;</span>, <span class="string">&#x27;JERRY&#x27;</span>, <span class="string">&#x27;WENDY&#x27;</span>, <span class="string">&#x27;SMITH&#x27;</span>]</span><br></pre></td></tr></table></figure><p>实例2：计算 30 以内可以被 3 整除的整数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">multiples = [i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">30</span>) <span class="keyword">if</span> i % <span class="number">3</span> == <span class="number">0</span>]</span><br><span class="line"><span class="built_in">print</span>(multiples)</span><br></pre></td></tr></table></figure><p><strong>字典推导式</strong></p><p>​    格式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123; key_expr: value_expr <span class="keyword">for</span> value <span class="keyword">in</span> collection &#125;</span><br><span class="line">或</span><br><span class="line">&#123; key_expr: value_expr <span class="keyword">for</span> value <span class="keyword">in</span> collection <span class="keyword">if</span> condition &#125;</span><br></pre></td></tr></table></figure><p>实例1：使用字符串及其长度创建字典</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">list</span> =[<span class="string">&#x27;beijing&#x27;</span>, <span class="string">&#x27;shanghai&#x27;</span>, <span class="string">&#x27;guangzhou&#x27;</span>,<span class="string">&#x27;shenzhen&#x27;</span>]</span><br><span class="line">dic = &#123;key:<span class="built_in">len</span>(key) <span class="keyword">for</span> key <span class="keyword">in</span> <span class="built_in">list</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(dic)</span><br><span class="line">输出：</span><br><span class="line">&#123;<span class="string">&#x27;beijing&#x27;</span>: <span class="number">7</span>, <span class="string">&#x27;shanghai&#x27;</span>: <span class="number">8</span>, <span class="string">&#x27;guangzhou&#x27;</span>: <span class="number">9</span>, <span class="string">&#x27;shenzhen&#x27;</span>: <span class="number">8</span>&#125;</span><br></pre></td></tr></table></figure><p>实例2：将三个整数及其平方值作为键值对创建字典</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dic = &#123;i : i**<span class="number">2</span> <span class="keyword">for</span> i <span class="keyword">in</span> (<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)&#125;</span><br><span class="line"><span class="built_in">print</span>(dic)</span><br><span class="line">输出：</span><br><span class="line">&#123;<span class="number">1</span>: <span class="number">1</span>, <span class="number">2</span>: <span class="number">4</span>, <span class="number">3</span>: <span class="number">9</span>&#125;</span><br></pre></td></tr></table></figure><p><strong>集合推导式</strong></p><p>​    格式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123; expression <span class="keyword">for</span> item <span class="keyword">in</span> <span class="type">Sequence</span> &#125;</span><br><span class="line">或</span><br><span class="line">&#123; expression <span class="keyword">for</span> item <span class="keyword">in</span> <span class="type">Sequence</span> <span class="keyword">if</span> conditional &#125;</span><br></pre></td></tr></table></figure><p>实例1：计算1，2，3平方</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set = &#123;x**2 for x in (1,2,3)&#125;</span><br></pre></td></tr></table></figure><p>实例2：判断不是abc的字母并输出</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a = &#123;x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="string">&#x27;abclsm&#x27;</span> <span class="keyword">if</span> x <span class="keyword">not</span> <span class="keyword">in</span> <span class="string">&#x27;abc&#x27;</span>&#125;</span><br></pre></td></tr></table></figure><p><strong>元组推导式</strong></p><p>​    元组推导式可以利用 range 区间、元组、列表、字典和集合等数据类型，快速生成一个满足指定需求的元组。</p><p>​    元组推导式和列表推导式的用法也完全相同，只是元组推导式是用 <strong>()</strong> 圆括号将各部分括起来，而列表推导式用的是中括号 **[]**，另外元组推导式返回的结果是一个生成器对象。</p><p>​    格式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(expression <span class="keyword">for</span> item <span class="keyword">in</span> <span class="type">Sequence</span> )</span><br><span class="line">或</span><br><span class="line">(expression <span class="keyword">for</span> item <span class="keyword">in</span> <span class="type">Sequence</span> <span class="keyword">if</span> conditional )</span><br></pre></td></tr></table></figure><p>实例1：生成一个包含数字 1~9 的元组：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = (x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">10</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line">&lt;generator <span class="built_in">object</span> &lt;genexpr&gt; at <span class="number">0x7faf6ee20a50</span>&gt;  <span class="comment"># 返回的是生成器对象</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">tuple</span>(a)       <span class="comment"># 使用 tuple() 函数，可以直接将生成器对象转换成元组</span></span><br><span class="line">(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>)</span><br></pre></td></tr></table></figure></li><li><h5 id="解释器"><a href="#解释器" class="headerlink" title="解释器"></a>解释器</h5><p>python 的二进制文件</p><p>交互式编程</p><p>脚本式编程</p></li><li><h5 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h5><p>确保对模块, 函数, 方法和行内注释使用正确的风格。</p><p>Python 中的注释有单行注释和多行注释。</p><p>Python 中单行注释以 <strong>#</strong> 开头，例如：</p><p># 这是一个注释 print(“Hello, World!”)</p><p>多行注释用三个单引号 <strong>‘’’</strong> 或者三个双引号 <strong>“””</strong> 将注释括起来，例如:</p><p><strong>单引号（’’’）</strong></p><p>#!/usr/bin/python3  ‘’’ 这是多行注释，用三个单引号 这是多行注释，用三个单引号  这是多行注释，用三个单引号 ‘’’ print(“Hello, World!”)</p><p><strong>双引号（”””）</strong></p><p>#!/usr/bin/python3  “”” 这是多行注释，用三个双引号 这是多行注释，用三个双引号  这是多行注释，用三个双引号 “”” print(“Hello, World!”)</p></li><li><h5 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h5><p>Python 语言支持以下类型的运算符:</p><ul><li><a href="https://www.runoob.com/python3/python3-basic-operators.html#ysf1">算术运算符</a></li><li><a href="https://www.runoob.com/python3/python3-basic-operators.html#ysf2">比较（关系）运算符</a></li><li><a href="https://www.runoob.com/python3/python3-basic-operators.html#ysf3">赋值运算符</a></li><li><a href="https://www.runoob.com/python3/python3-basic-operators.html#ysf4">逻辑运算符</a></li><li><a href="https://www.runoob.com/python3/python3-basic-operators.html#ysf5">位运算符</a></li><li><a href="https://www.runoob.com/python3/python3-basic-operators.html#ysf6">成员运算符</a></li><li><a href="https://www.runoob.com/python3/python3-basic-operators.html#ysf7">身份运算符</a></li><li><a href="https://www.runoob.com/python3/python3-basic-operators.html#ysf8">运算符优先级</a></li></ul><p>以下表格列出了从最高到最低优先级的所有运算符：</p><table><thead><tr><th align="left">运算符</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">**</td><td align="left">指数 (最高优先级)</td></tr><tr><td align="left">~ + -</td><td align="left">按位翻转, 一元加号和减号 (最后两个的方法名为 +@ 和 -@)</td></tr><tr><td align="left">* / % //</td><td align="left">乘，除，求余数和取整除</td></tr><tr><td align="left">+ -</td><td align="left">加法减法</td></tr><tr><td align="left">&gt;&gt; &lt;&lt;</td><td align="left">右移，左移运算符</td></tr><tr><td align="left">&amp;</td><td align="left">位 ‘AND’</td></tr><tr><td align="left">^ |</td><td align="left">位运算符</td></tr><tr><td align="left">&lt;= &lt; &gt; &gt;=</td><td align="left">比较运算符</td></tr><tr><td align="left">== !=</td><td align="left">等于运算符</td></tr><tr><td align="left">= %= /= //= -= += *= **=</td><td align="left">赋值运算符</td></tr><tr><td align="left">is is not</td><td align="left">身份运算符</td></tr><tr><td align="left">in not in</td><td align="left">成员运算符</td></tr><tr><td align="left">not and or</td><td align="left">逻辑运算符</td></tr></tbody></table></li><li><h5 id="数字"><a href="#数字" class="headerlink" title="数字"></a>数字</h5><p><a href="https://www.runoob.com/python3/python3-number.html">查看</a></p></li><li><h5 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h5><p>注：只记录新的东西，使用与 C 中 sprintf 函数一样的语法，不同的是后面的变量前面有个%</p><ul><li><p>字符串格式化：</p><p>如 print (“我叫 %s 今年 %d 岁!” % (‘小明’, 10))</p></li><li><p>新的格式化方式 <strong>str.format()</strong> 通过 <strong>{}</strong> 和 **.**来代替以前的 <strong>%</strong> 。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;<span class="string">&quot;&#123;&#125; &#123;&#125;&quot;</span>.<span class="built_in">format</span>(<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>)    <span class="comment"># 不设置指定位置，按默认顺序</span></span><br><span class="line"><span class="string">&#x27;hello world&#x27;</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&quot;&#123;0&#125; &#123;1&#125;&quot;</span>.<span class="built_in">format</span>(<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>)  <span class="comment"># 设置指定位置</span></span><br><span class="line"><span class="string">&#x27;hello world&#x27;</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&quot;&#123;1&#125; &#123;0&#125; &#123;1&#125;&quot;</span>.<span class="built_in">format</span>(<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>)  <span class="comment"># 设置指定位置</span></span><br><span class="line"><span class="string">&#x27;world hello world&#x27;</span></span><br><span class="line">也可设置参数</span><br><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;网站名：&#123;name&#125;, 地址 &#123;url&#125;&quot;</span>.<span class="built_in">format</span>(name=<span class="string">&quot;菜鸟教程&quot;</span>, url=<span class="string">&quot;www.runoob.com&quot;</span>))</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 通过字典设置参数</span></span><br><span class="line">site = &#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;菜鸟教程&quot;</span>, <span class="string">&quot;url&quot;</span>: <span class="string">&quot;www.runoob.com&quot;</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;网站名：&#123;name&#125;, 地址 &#123;url&#125;&quot;</span>.<span class="built_in">format</span>(**site))</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 通过列表索引设置参数</span></span><br><span class="line">my_list = [<span class="string">&#x27;菜鸟教程&#x27;</span>, <span class="string">&#x27;www.runoob.com&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;网站名：&#123;0[0]&#125;, 地址 &#123;0[1]&#125;&quot;</span>.<span class="built_in">format</span>(my_list))  <span class="comment"># &quot;0&quot; 是必须的</span></span><br><span class="line"><span class="comment"># 向str.format() 传入对象   不明白这里</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AssignValue</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, value</span>):</span></span><br><span class="line">        self.value = value</span><br><span class="line">my_value = AssignValue(<span class="number">6</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;value 为: &#123;0.value&#125;&#x27;</span>.<span class="built_in">format</span>(my_value))  <span class="comment"># &quot;0&quot; 是可选的</span></span><br></pre></td></tr></table></figure><ul><li>数字格式化</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="string">&quot;&#123;:.2f&#125;&quot;</span>.<span class="built_in">format</span>(<span class="number">3.1415926</span>))</span><br><span class="line"><span class="number">3.14</span></span><br></pre></td></tr></table></figure></li></ul></li><li><h5 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h5><p>一些列表操作：</p><ul><li><p>更新列表</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">list</span> = []</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">list</span>.append(<span class="string">&#x27;test&#x27;</span>)</span><br></pre></td></tr></table></figure></li><li><p>删除列表元素</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">del</span> <span class="built_in">list</span>[<span class="number">0</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span> <span class="built_in">list</span></span><br><span class="line">[]</span><br></pre></td></tr></table></figure></li><li><p>操作符 </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#len(list)</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">list</span>.append(<span class="string">&#x27;test&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">len</span>(<span class="built_in">list</span>)</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="comment"># + 组合列表 -&gt; 新列表</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[<span class="number">1</span>] + <span class="built_in">list</span></span><br><span class="line">[<span class="number">1</span>, <span class="string">&#x27;test&#x27;</span>]</span><br><span class="line"><span class="comment"># * 重复列表 -&gt; 新列表</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">list</span> * <span class="number">2</span></span><br><span class="line">[<span class="string">&#x27;test&#x27;</span>, <span class="string">&#x27;test&#x27;</span>]</span><br><span class="line"><span class="comment"># in 检查成员</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;test&#x27;</span> <span class="keyword">in</span> <span class="built_in">list</span></span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="comment"># for x in [1,2,3]: print x</span></span><br></pre></td></tr></table></figure></li><li><p>函数和方法</p><table><thead><tr><th align="left">序号</th><th align="left">函数</th></tr></thead><tbody><tr><td align="left">1</td><td align="left"><a href="https://www.runoob.com/python/att-list-cmp.html">cmp(list1, list2)</a> 比较两个列表的元素</td></tr><tr><td align="left">2</td><td align="left"><a href="https://www.runoob.com/python/att-list-len.html">len(list)</a> 列表元素个数</td></tr><tr><td align="left">3</td><td align="left"><a href="https://www.runoob.com/python/att-list-max.html">max(list)</a> 返回列表元素最大值</td></tr><tr><td align="left">4</td><td align="left"><a href="https://www.runoob.com/python/att-list-min.html">min(list)</a> 返回列表元素最小值</td></tr><tr><td align="left">5</td><td align="left"><a href="https://www.runoob.com/python/att-list-list.html">list(seq)</a> 将元组转换为列表</td></tr></tbody></table><table><thead><tr><th align="left">序号</th><th align="left">方法</th></tr></thead><tbody><tr><td align="left">1</td><td align="left"><a href="https://www.runoob.com/python/att-list-append.html">list.append(obj)</a> 在列表末尾添加新的对象</td></tr><tr><td align="left">2</td><td align="left"><a href="https://www.runoob.com/python/att-list-count.html">list.count(obj)</a> 统计某个元素在列表中出现的次数</td></tr><tr><td align="left">3</td><td align="left"><a href="https://www.runoob.com/python/att-list-extend.html">list.extend(seq)</a> 在列表末尾一次性追加另一个序列中的多个值（用新列表扩展原来的列表）</td></tr><tr><td align="left">4</td><td align="left"><a href="https://www.runoob.com/python/att-list-index.html">list.index(obj)</a> 从列表中找出某个值第一个匹配项的索引位置</td></tr><tr><td align="left">5</td><td align="left"><a href="https://www.runoob.com/python/att-list-insert.html">list.insert(index, obj)</a> 将对象插入列表</td></tr><tr><td align="left">6</td><td align="left">[list.pop(<a href="https://www.runoob.com/python/att-list-pop.html">index=-1])</a> 移除列表中的一个元素（默认最后一个元素），并且返回该元素的值</td></tr><tr><td align="left">7</td><td align="left"><a href="https://www.runoob.com/python/att-list-remove.html">list.remove(obj)</a> 移除列表中某个值的第一个匹配项</td></tr><tr><td align="left">8</td><td align="left"><a href="https://www.runoob.com/python/att-list-reverse.html">list.reverse()</a> 反向列表中元素</td></tr><tr><td align="left">9</td><td align="left"><a href="https://www.runoob.com/python/att-list-sort.html">list.sort(cmp=None, key=None, reverse=False)</a> 对原列表进行排序</td></tr></tbody></table></li></ul><p>​        </p></li><li><h5 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h5><ul><li>创建</li></ul><p>tup1 = (‘physics’, ‘chemistry’, 1997, 2000) tup2 = (1, 2, 3, 4, 5 ) tup3 = “a”, “b”, “c”, “d”</p><p>创建空元组</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tup1 = ()</span><br></pre></td></tr></table></figure><p>元组中只包含一个元素时，需要在元素后面添加逗号</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tup1 = (<span class="number">50</span>,)</span><br></pre></td></tr></table></figure><p>元组与字符串类似，下标索引从0开始，可以进行截取，组合等。</p><ul><li><p>访问</p><p>索引或切片</p></li><li><p>修改</p><p>元组中的元素值是不允许修改的，但我们可以对元组进行连接组合</p><p>tup1 = (12, 34.56) tup2 = (‘abc’, ‘xyz’)  # 以下修改元组元素操作是非法的。 # tup1[0] = 100  # 创建一个新的元组 tup3 = tup1 + tup2 print tup3 输出(12, 34.56, ‘abc’, ‘xyz’)</p></li><li><p>删除</p><p>del tup</p></li><li><p>运算符</p><table><thead><tr><th align="left">Python 表达式</th><th align="left">结果</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">len((1, 2, 3))</td><td align="left">3</td><td align="left">计算元素个数</td></tr><tr><td align="left">(1, 2, 3) + (4, 5, 6)</td><td align="left">(1, 2, 3, 4, 5, 6)</td><td align="left">连接</td></tr><tr><td align="left">(‘Hi!’,) * 4</td><td align="left">(‘Hi!’, ‘Hi!’, ‘Hi!’, ‘Hi!’)</td><td align="left">复制</td></tr><tr><td align="left">3 in (1, 2, 3)</td><td align="left">True</td><td align="left">元素是否存在</td></tr><tr><td align="left">for x in (1, 2, 3): print x,</td><td align="left">1 2 3</td><td align="left">迭代</td></tr></tbody></table></li><li><p>任意无符号的对象，以逗号隔开，默认为元组</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span> <span class="string">&#x27;abc&#x27;</span>, -<span class="number">4.24e93</span>, <span class="number">18</span>+<span class="number">6.6j</span>, <span class="string">&#x27;xyz&#x27;</span></span><br><span class="line">x, y = <span class="number">1</span>, <span class="number">2</span></span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;Value of x , y : &quot;</span>, x,y</span><br><span class="line"></span><br><span class="line">abc -<span class="number">4.24e+93</span> (<span class="number">18</span>+<span class="number">6.6j</span>) xyz</span><br><span class="line">Value of x , y : <span class="number">1</span> <span class="number">2</span></span><br></pre></td></tr></table></figure></li><li><p>内置 函数</p><table><thead><tr><th align="left">序号</th><th align="left">方法及描述</th></tr></thead><tbody><tr><td align="left">1</td><td align="left"><a href="https://www.runoob.com/python/att-tuple-cmp.html">cmp(tuple1, tuple2)</a> 比较两个元组元素。</td></tr><tr><td align="left">2</td><td align="left"><a href="https://www.runoob.com/python/att-tuple-len.html">len(tuple)</a> 计算元组元素个数。</td></tr><tr><td align="left">3</td><td align="left"><a href="https://www.runoob.com/python/att-tuple-max.html">max(tuple)</a> 返回元组中元素最大值。</td></tr><tr><td align="left">4</td><td align="left"><a href="https://www.runoob.com/python/att-tuple-min.html">min(tuple)</a> 返回元组中元素最小值。</td></tr><tr><td align="left">5</td><td align="left"><a href="https://www.runoob.com/python/att-tuple-tuple.html">tuple(seq)</a> 将列表转换为元组。</td></tr></tbody></table></li></ul></li><li><h5 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h5><ul><li><p>创建字典</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">tinydict1 = &#123; <span class="string">&#x27;abc&#x27;</span>: <span class="number">456</span> &#125;</span><br><span class="line">tinydict2 = &#123; <span class="string">&#x27;abc&#x27;</span>: <span class="number">123</span>, <span class="number">98.6</span>: <span class="number">37</span> &#125;</span><br><span class="line"><span class="comment"># 使用大括号 &#123;&#125; 来创建空字典</span></span><br><span class="line">emptyDict = &#123;&#125; </span><br><span class="line"><span class="comment"># 打印字典</span></span><br><span class="line"><span class="built_in">print</span>(emptyDict)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 查看字典的数量</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Length:&quot;</span>, <span class="built_in">len</span>(emptyDict))</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 查看类型</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(emptyDict))</span><br><span class="line"><span class="comment"># 使用dict() 创建</span></span><br><span class="line">emptyDict = <span class="built_in">dict</span>()</span><br></pre></td></tr></table></figure></li><li><p>访问</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tinydict = &#123;<span class="string">&#x27;Name&#x27;</span>: <span class="string">&#x27;Runoob&#x27;</span>, <span class="string">&#x27;Age&#x27;</span>: <span class="number">7</span>, <span class="string">&#x27;Class&#x27;</span>: <span class="string">&#x27;First&#x27;</span>&#125;</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;tinydict[&#x27;Name&#x27;]: &quot;</span>, tinydict[<span class="string">&#x27;Name&#x27;</span>])</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;tinydict[&#x27;Age&#x27;]: &quot;</span>, tinydict[<span class="string">&#x27;Age&#x27;</span>])</span><br></pre></td></tr></table></figure></li><li><p>修改</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">tinydict = &#123;<span class="string">&#x27;Name&#x27;</span>: <span class="string">&#x27;Runoob&#x27;</span>, <span class="string">&#x27;Age&#x27;</span>: <span class="number">7</span>, <span class="string">&#x27;Class&#x27;</span>: <span class="string">&#x27;First&#x27;</span>&#125;</span><br><span class="line">tinydict[<span class="string">&#x27;Age&#x27;</span>] = <span class="number">8</span>               <span class="comment"># 更新 Age</span></span><br><span class="line">tinydict[<span class="string">&#x27;School&#x27;</span>] = <span class="string">&quot;菜鸟教程&quot;</span>  <span class="comment"># 添加信息</span></span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;tinydict[&#x27;Age&#x27;]: &quot;</span>, tinydict[<span class="string">&#x27;Age&#x27;</span>])</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;tinydict[&#x27;School&#x27;]: &quot;</span>, tinydict[<span class="string">&#x27;School&#x27;</span>])</span><br></pre></td></tr></table></figure></li><li><p>删除元素</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">del</span> tinydict[<span class="string">&#x27;Name&#x27;</span>] <span class="comment"># 删除键 &#x27;Name&#x27;</span></span><br><span class="line">tinydict.clear()     <span class="comment"># 清空字典</span></span><br><span class="line"><span class="keyword">del</span> tinydict         <span class="comment"># 删除字典</span></span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;tinydict[&#x27;Age&#x27;]: &quot;</span>, tinydict[<span class="string">&#x27;Age&#x27;</span>])</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;tinydict[&#x27;School&#x27;]: &quot;</span>, tinydict[<span class="string">&#x27;School&#x27;</span>])</span><br></pre></td></tr></table></figure></li><li><p>键特性</p><p>两个重要的点需要记住：</p><p>1）不允许同一个键出现两次。创建时如果同一个键被赋值两次，后一个值会被记住</p><p>2）键必须不可变，所以可以用数字，字符串或元组充当，而用列表就不行</p></li><li><p>内置函数和方法</p><table><thead><tr><th align="left">号</th><th align="left">函数及描述</th><th align="left">实例</th></tr></thead><tbody><tr><td align="left">1</td><td align="left">len(dict) 计算字典元素个数，即键的总数。</td><td align="left"><code>&gt;&gt;&gt; tinydict = &#123;&#39;Name&#39;: &#39;Runoob&#39;, &#39;Age&#39;: 7, &#39;Class&#39;: &#39;First&#39;&#125; &gt;&gt;&gt; len(tinydict) 3</code></td></tr><tr><td align="left">2</td><td align="left">str(dict) 输出字典，可以打印的字符串表示。</td><td align="left"><code>&gt;&gt;&gt; tinydict = &#123;&#39;Name&#39;: &#39;Runoob&#39;, &#39;Age&#39;: 7, &#39;Class&#39;: &#39;First&#39;&#125; &gt;&gt;&gt; str(tinydict) &quot;&#123;&#39;Name&#39;: &#39;Runoob&#39;, &#39;Class&#39;: &#39;First&#39;, &#39;Age&#39;: 7&#125;&quot;</code></td></tr><tr><td align="left">3</td><td align="left">type(variable) 返回输入的变量类型，如果变量是字典就返回字典类型。</td><td align="left"><code>&gt;&gt;&gt; tinydict = &#123;&#39;Name&#39;: &#39;Runoob&#39;, &#39;Age&#39;: 7, &#39;Class&#39;: &#39;First&#39;&#125; &gt;&gt;&gt; type(tinydict) &lt;class &#39;dict&#39;&gt;</code></td></tr></tbody></table><table><thead><tr><th align="left">序号</th><th align="left">函数及描述</th></tr></thead><tbody><tr><td align="left">1</td><td align="left"><a href="https://www.runoob.com/python3/python3-att-dictionary-clear.html">dict.clear()</a> 删除字典内所有元素</td></tr><tr><td align="left">2</td><td align="left"><a href="https://www.runoob.com/python3/python3-att-dictionary-copy.html">dict.copy()</a> 返回一个字典的浅复制</td></tr><tr><td align="left">3</td><td align="left"><a href="https://www.runoob.com/python3/python3-att-dictionary-fromkeys.html">dict.fromkeys()</a> 创建一个新字典，以序列seq中元素做字典的键，val为字典所有键对应的初始值</td></tr><tr><td align="left">4</td><td align="left"><a href="https://www.runoob.com/python3/python3-att-dictionary-get.html">dict.get(key, default=None)</a> 返回指定键的值，如果键不在字典中返回 default 设置的默认值</td></tr><tr><td align="left">5</td><td align="left"><a href="https://www.runoob.com/python3/python3-att-dictionary-in.html">key in dict</a> 如果键在字典dict里返回true，否则返回false</td></tr><tr><td align="left">6</td><td align="left"><a href="https://www.runoob.com/python3/python3-att-dictionary-items.html">dict.items()</a> 以列表返回一个视图对象</td></tr><tr><td align="left">7</td><td align="left"><a href="https://www.runoob.com/python3/python3-att-dictionary-keys.html">dict.keys()</a> 返回一个视图对象</td></tr><tr><td align="left">8</td><td align="left"><a href="https://www.runoob.com/python3/python3-att-dictionary-setdefault.html">dict.setdefault(key, default=None)</a> 和get()类似, 但如果键不存在于字典中，将会添加键并将值设为default</td></tr><tr><td align="left">9</td><td align="left"><a href="https://www.runoob.com/python3/python3-att-dictionary-update.html">dict.update(dict2)</a> 把字典dict2的键/值对更新到dict里</td></tr><tr><td align="left">10</td><td align="left"><a href="https://www.runoob.com/python3/python3-att-dictionary-values.html">dict.values()</a> 返回一个视图对象</td></tr><tr><td align="left">11</td><td align="left">[pop(key<a href="https://www.runoob.com/python3/python3-att-dictionary-pop.html">,default])</a> 删除字典给定键 key 所对应的值，返回值为被删除的值。key值必须给出。 否则，返回default值。</td></tr><tr><td align="left">12</td><td align="left"><a href="https://www.runoob.com/python3/python3-att-dictionary-popitem.html">popitem()</a> 返回并删除字典中的最后一对键和值。</td></tr></tbody></table></li></ul><p>​     </p></li><li><h5 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h5><p>一个无序的不重复元素序列。</p><ul><li><p>创建</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">parame = &#123;value01,value02,...&#125;</span><br><span class="line">或者</span><br><span class="line"><span class="built_in">set</span>(value)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>basket = &#123;<span class="string">&#x27;apple&#x27;</span>, <span class="string">&#x27;orange&#x27;</span>, <span class="string">&#x27;apple&#x27;</span>, <span class="string">&#x27;pear&#x27;</span>, <span class="string">&#x27;orange&#x27;</span>, <span class="string">&#x27;banana&#x27;</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(basket)                      <span class="comment"># 这里演示的是去重功能</span></span><br><span class="line">&#123;<span class="string">&#x27;orange&#x27;</span>, <span class="string">&#x27;banana&#x27;</span>, <span class="string">&#x27;pear&#x27;</span>, <span class="string">&#x27;apple&#x27;</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;orange&#x27;</span> <span class="keyword">in</span> basket                 <span class="comment"># 快速判断元素是否在集合内</span></span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;crabgrass&#x27;</span> <span class="keyword">in</span> basket</span><br><span class="line"><span class="literal">False</span></span><br></pre></td></tr></table></figure></li><li><p>添加元素</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">s.add( x ) <span class="comment">#将元素 x 添加到集合 s 中，如果元素已存在，则不进行任何操作</span></span><br><span class="line">s.update( x ) <span class="comment">#参数可以是列表，元组，字典等</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>thisset = <span class="built_in">set</span>((<span class="string">&quot;Google&quot;</span>, <span class="string">&quot;Runoob&quot;</span>, <span class="string">&quot;Taobao&quot;</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>thisset.update(&#123;<span class="number">1</span>,<span class="number">3</span>&#125;)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(thisset)</span><br><span class="line">&#123;<span class="number">1</span>, <span class="number">3</span>, <span class="string">&#x27;Google&#x27;</span>, <span class="string">&#x27;Taobao&#x27;</span>, <span class="string">&#x27;Runoob&#x27;</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>thisset.update([<span class="number">1</span>,<span class="number">4</span>],[<span class="number">5</span>,<span class="number">6</span>])  </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(thisset)</span><br><span class="line">&#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="string">&#x27;Google&#x27;</span>, <span class="string">&#x27;Taobao&#x27;</span>, <span class="string">&#x27;Runoob&#x27;</span>&#125;</span><br></pre></td></tr></table></figure></li><li><p>删除元素</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">s.remove( x ) <span class="comment">#将元素 x 从集合 s 中移除，如果元素不存在，则会发生错误</span></span><br><span class="line">s.discard( x ) <span class="comment">#如果元素不存在，不会发生错误</span></span><br><span class="line">s.pop()  <span class="comment">#随机删除集合中的一个元素，set 集合的 pop 方法会对集合进行无序的排列，然后将这个无序排列集合的左面第一个元素进行删除</span></span><br></pre></td></tr></table></figure></li><li><p>计算元素个数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">len</span>(s)</span><br></pre></td></tr></table></figure></li><li><p>清空集合</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s.clear() </span><br></pre></td></tr></table></figure></li><li><p>判断元素是否存在</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x <span class="keyword">in</span> s</span><br></pre></td></tr></table></figure></li><li><p>内置方法</p><table><thead><tr><th align="left">方法</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><a href="https://www.runoob.com/python3/ref-set-add.html">add()</a></td><td align="left">为集合添加元素</td></tr><tr><td align="left"><a href="https://www.runoob.com/python3/ref-set-clear.html">clear()</a></td><td align="left">移除集合中的所有元素</td></tr><tr><td align="left"><a href="https://www.runoob.com/python3/ref-set-copy.html">copy()</a></td><td align="left">拷贝一个集合</td></tr><tr><td align="left"><a href="https://www.runoob.com/python3/ref-set-difference.html">difference()</a></td><td align="left">返回多个集合的差集</td></tr><tr><td align="left"><a href="https://www.runoob.com/python3/ref-set-difference_update.html">difference_update()</a></td><td align="left">移除集合中的元素，该元素在指定的集合也存在。</td></tr><tr><td align="left"><a href="https://www.runoob.com/python3/ref-set-discard.html">discard()</a></td><td align="left">删除集合中指定的元素</td></tr><tr><td align="left"><a href="https://www.runoob.com/python3/ref-set-intersection.html">intersection()</a></td><td align="left">返回集合的交集</td></tr><tr><td align="left"><a href="https://www.runoob.com/python3/ref-set-intersection_update.html">intersection_update()</a></td><td align="left">返回集合的交集。</td></tr><tr><td align="left"><a href="https://www.runoob.com/python3/ref-set-isdisjoint.html">isdisjoint()</a></td><td align="left">判断两个集合是否包含相同的元素，如果没有返回 True，否则返回 False。</td></tr><tr><td align="left"><a href="https://www.runoob.com/python3/ref-set-issubset.html">issubset()</a></td><td align="left">判断指定集合是否为该方法参数集合的子集。</td></tr><tr><td align="left"><a href="https://www.runoob.com/python3/ref-set-issuperset.html">issuperset()</a></td><td align="left">判断该方法的参数集合是否为指定集合的子集</td></tr><tr><td align="left"><a href="https://www.runoob.com/python3/ref-set-pop.html">pop()</a></td><td align="left">随机移除元素</td></tr><tr><td align="left"><a href="https://www.runoob.com/python3/ref-set-remove.html">remove()</a></td><td align="left">移除指定元素</td></tr><tr><td align="left"><a href="https://www.runoob.com/python3/ref-set-symmetric_difference.html">symmetric_difference()</a></td><td align="left">返回两个集合中不重复的元素集合。</td></tr><tr><td align="left"><a href="https://www.runoob.com/python3/ref-set-symmetric_difference_update.html">symmetric_difference_update()</a></td><td align="left">移除当前集合中在另外一个指定集合相同的元素，并将另外一个指定集合中不同的元素插入到当前集合中。</td></tr><tr><td align="left"><a href="https://www.runoob.com/python3/ref-set-union.html">union()</a></td><td align="left">返回两个集合的并集</td></tr><tr><td align="left"><a href="https://www.runoob.com/python3/ref-set-update.html">update()</a></td><td align="left">给集合添加元素</td></tr></tbody></table></li></ul></li><li><h5 id="条件控制"><a href="#条件控制" class="headerlink" title="条件控制"></a>条件控制</h5><ul><li>if<ul><li>1、每个条件后面要使用冒号 **:**，表示接下来是满足条件后要执行的语句块。</li><li>2、使用缩进来划分语句块，相同缩进数的语句在一起组成一个语句块。</li><li>3、在Python中没有switch – case语句。</li></ul></li><li>if-elif-else : python 中无else if 而使用elif</li><li>if 嵌套</li></ul></li><li><h5 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h5><p>Python 中的循环语句有 for 和 while,同样需要注意冒号和缩进。另外，在 Python 中没有 do..while 循环</p><ul><li><p>while</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> 判断条件(condition)：</span><br><span class="line">    执行语句(statements)……</span><br></pre></td></tr></table></figure></li><li><p>while else</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> &lt;expr&gt;:</span><br><span class="line">    &lt;statement(s)&gt;</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    &lt;additional_statement(s)&gt;</span><br></pre></td></tr></table></figure></li><li><p>简单语句组</p><p>类似if语句的语法，如果你的while循环体中只有一条语句，你可以将该语句与while写在同一行中</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flag = <span class="number">1</span>  <span class="keyword">while</span> (flag): <span class="built_in">print</span> (<span class="string">&#x27;欢迎访问菜鸟教程!&#x27;</span>)  <span class="built_in">print</span> (<span class="string">&quot;Good bye!&quot;</span>)</span><br></pre></td></tr></table></figure></li><li><p>for</p><p>for 循环可以遍历任何可迭代对象，如一个列表或者一个字符串</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> &lt;variable&gt; <span class="keyword">in</span> &lt;sequence&gt;:    </span><br><span class="line">    &lt;statements&gt; </span><br><span class="line"><span class="keyword">else</span>:    </span><br><span class="line">    &lt;statements&gt;</span><br></pre></td></tr></table></figure></li><li><p>range()</p><p>遍历数字序列，可以使用内置range()函数。它会生成数列</p><p>结合range()和len()函数以遍历一个序列的索引</p><p>使用range()函数来创建一个列表</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;<span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span>(i)</span><br><span class="line">...</span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line">&gt;&gt;&gt;<span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">10</span>, <span class="number">3</span>) :</span><br><span class="line">    <span class="built_in">print</span>(i)</span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">9</span></span><br><span class="line">&gt;&gt;&gt;a = [<span class="string">&#x27;Google&#x27;</span>, <span class="string">&#x27;Baidu&#x27;</span>, <span class="string">&#x27;Runoob&#x27;</span>, <span class="string">&#x27;Taobao&#x27;</span>, <span class="string">&#x27;QQ&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(a)):</span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span>(i, a[i])</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="number">0</span> Google</span><br><span class="line"><span class="number">1</span> Baidu</span><br><span class="line"><span class="number">2</span> Runoob</span><br><span class="line"><span class="number">3</span> Taobao</span><br><span class="line"><span class="number">4</span> QQ</span><br><span class="line">&gt;&gt;&gt;<span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">5</span>))</span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br></pre></td></tr></table></figure></li><li><p>pass</p><p>pass是空语句，是为了保持程序结构的完整性,不做任何事情，一般用做占位语句</p></li></ul></li><li><h5 id="迭代器与生成器"><a href="#迭代器与生成器" class="headerlink" title="迭代器与生成器"></a>迭代器与生成器</h5><ul><li><p>迭代器</p><ul><li><p>迭代是Python最强大的功能之一，是访问集合元素的一种方式。</p></li><li><p>迭代器是一个可以记住遍历的位置的对象。</p></li><li><p>迭代器对象从集合的第一个元素开始访问，直到所有的元素被访问完结束。迭代器只能往前不会后退。</p></li><li><p>迭代器有两个基本的方法：<strong>iter()</strong> 和 **next()**。</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#字符串，列表或元组对象都可用于创建迭代器</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">list</span>=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>it = <span class="built_in">iter</span>(<span class="built_in">list</span>)    <span class="comment"># 创建迭代器对象</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span> (<span class="built_in">next</span>(it))   <span class="comment"># 输出迭代器的下一个元素</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span> (<span class="built_in">next</span>(it))</span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="comment">#迭代器对象可以使用常规for语句进行遍历：</span></span><br><span class="line"><span class="built_in">list</span>=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">it = <span class="built_in">iter</span>(<span class="built_in">list</span>)    <span class="comment"># 创建迭代器对象</span></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> it:</span><br><span class="line">    <span class="built_in">print</span> (x, end=<span class="string">&quot; &quot;</span>)</span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span></span><br></pre></td></tr></table></figure><ul><li><p>创建</p><p>把一个类作为一个迭代器使用需要在类中实现两个方法__ <strong>iter</strong>() 与__ <strong>next</strong>() </p><p>__ <strong>iter</strong>() 方法返回一个特殊的迭代器对象， 这个迭代器对象实现了 <strong>next</strong>() 方法并通过 StopIteration 异常标识迭代的完成。</p><p>__ <strong>next</strong>() 方法（Python 2 里是 next()）会返回下一个迭代器对象。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyNumbers</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span>(<span class="params">self</span>):</span></span><br><span class="line">    self.a = <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> self</span><br><span class="line"> </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__next__</span>(<span class="params">self</span>):</span></span><br><span class="line">    x = self.a</span><br><span class="line">    self.a += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line"> </span><br><span class="line">myclass = MyNumbers()</span><br><span class="line">myiter = <span class="built_in">iter</span>(myclass)</span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(myiter))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(myiter))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(myiter))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(myiter))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(myiter))</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="comment">#StopIteration 异常用于标识迭代的完成，防止出现无限循环的情况，在 __next__() 方法中我们可以设置在完成指定循环次数后触发 StopIteration 异常来结束迭代。</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyNumbers</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span>(<span class="params">self</span>):</span></span><br><span class="line">    self.a = <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> self</span><br><span class="line"> </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__next__</span>(<span class="params">self</span>):</span></span><br><span class="line">    <span class="keyword">if</span> self.a &lt;= <span class="number">20</span>:</span><br><span class="line">      x = self.a</span><br><span class="line">      self.a += <span class="number">1</span></span><br><span class="line">      <span class="keyword">return</span> x</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">      <span class="keyword">raise</span> StopIteration</span><br><span class="line"> </span><br><span class="line">myclass = MyNumbers()</span><br><span class="line">myiter = <span class="built_in">iter</span>(myclass)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> myiter:</span><br><span class="line">  <span class="built_in">print</span>(x)</span><br></pre></td></tr></table></figure></li></ul></li><li><p>生成器</p><p>在 Python 中，使用了 yield 的函数被称为生成器（generator）。</p><p>跟普通函数不同的是，生成器是一个返回迭代器的函数，只能用于迭代操作，更简单点理解生成器就是一个迭代器。</p><p>在调用生成器运行的过程中，每次遇到 yield 时函数会暂停并保存当前所有的运行信息，返回 yield 的值, 并在下一次执行 next() 方法时从当前位置继续运行。</p><p>调用一个生成器函数，返回的是一个迭代器对象。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fibonacci</span>(<span class="params">n</span>):</span> <span class="comment"># 生成器函数 - 斐波那契</span></span><br><span class="line">    a, b, counter = <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">if</span> (counter &gt; n): </span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">yield</span> a</span><br><span class="line">        a, b = b, a + b</span><br><span class="line">        counter += <span class="number">1</span></span><br><span class="line">f = fibonacci(<span class="number">10</span>) <span class="comment"># f 是一个迭代器，由生成器返回生成</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="built_in">print</span> (<span class="built_in">next</span>(f), end=<span class="string">&quot; &quot;</span>)</span><br><span class="line">    <span class="keyword">except</span> StopIteration:</span><br><span class="line">        sys.exit()</span><br><span class="line"> <span class="number">0</span> <span class="number">1</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">5</span> <span class="number">8</span> <span class="number">13</span> <span class="number">21</span> <span class="number">34</span> <span class="number">55</span>       </span><br></pre></td></tr></table></figure></li></ul></li><li><h5 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h5><ul><li>函数代码块以 <strong>def</strong> 关键词开头，后接函数标识符名称和圆括号 **()**。</li><li>任何传入参数和自变量必须放在圆括号中间，圆括号之间可以用于定义参数。</li><li>函数的第一行语句可以选择性地使用文档字符串—用于存放函数说明。</li><li>函数内容以冒号 <strong>:</strong> 起始，并且缩进。</li><li><strong>return [表达式]</strong> 结束函数，选择性地返回一个值给调用方，不带表达式的 return 相当于返回 None。</li></ul><p><strong>格式：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> 函数名（参数列表）:</span></span><br><span class="line">    函数体</span><br></pre></td></tr></table></figure><p><strong>参数传递</strong></p><p>在 python 中，类型属于对象，对象有不同类型的区分，变量是没有类型的</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"></span><br><span class="line">a=<span class="string">&quot;Runoob&quot;</span></span><br></pre></td></tr></table></figure><p>以上代码中，**[1,2,3]** 是 List 类型，**”Runoob”** 是 String 类型，而变量 a 是没有类型，她仅仅是一个对象的引用（一个指针），可以是指向 List 类型对象，也可以是指向 String 类型对象。</p><p><strong>可更改(mutable)与不可更改(immutable)对象</strong></p><p>在 python 中，strings, tuples, 和 numbers 是不可更改的对象，而 list,dict 等则是可以修改的对象。</p><ul><li><strong>不可变类型：</strong>变量赋值 <strong>a=5</strong> 后再赋值 <strong>a=10</strong>，这里实际是新生成一个 int 值对象 10，再让 a 指向它，而 5 被丢弃，不是改变 a 的值，相当于新生成了 a。</li><li><strong>可变类型：</strong>变量赋值 <strong>la=[1,2,3,4]</strong> 后再赋值 <strong>la[2]=5</strong> 则是将 list la 的第三个元素值更改，本身la没有动，只是其内部的一部分值被修改了。</li></ul><p>python 函数的参数传递：</p><ul><li><strong>不可变类型：</strong>类似 C++ 的值传递，如整数、字符串、元组。如 fun(a)，传递的只是 a 的值，没有影响 a 对象本身。如果在 fun(a) 内部修改 a 的值，则是新生成一个 a 的对象。</li><li><strong>可变类型：</strong>类似 C++ 的引用传递，如 列表，字典。如 fun(la)，则是将 la 真正的传过去，修改后 fun 外部的 la 也会受影响</li></ul><p><strong>python 中一切都是对象，严格意义我们不能说值传递还是引用传递，我们应该说传不可变对象和传可变对象。</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#传不可变对象 通过 id() 函数来查看内存地址变化：</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">change</span>(<span class="params">a</span>):</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">id</span>(a))   <span class="comment"># 指向的是同一个对象</span></span><br><span class="line">    a=<span class="number">10</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">id</span>(a))   <span class="comment"># 一个新对象</span></span><br><span class="line"> </span><br><span class="line">a=<span class="number">1</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(a))</span><br><span class="line">change(a)</span><br><span class="line"><span class="number">4379369136</span></span><br><span class="line"><span class="number">4379369136</span></span><br><span class="line"><span class="number">4379369424</span></span><br><span class="line"><span class="comment">#传可变对象 通过 id() 函数来查看内存地址变化：</span></span><br><span class="line"><span class="comment"># 可写函数说明</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">changeme</span>(<span class="params"> mylist </span>):</span></span><br><span class="line">   <span class="string">&quot;修改传入的列表&quot;</span></span><br><span class="line">   mylist.append([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>])</span><br><span class="line">   <span class="built_in">print</span> (<span class="string">&quot;函数内取值: &quot;</span>, mylist)</span><br><span class="line">   <span class="keyword">return</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 调用changeme函数</span></span><br><span class="line">mylist = [<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>]</span><br><span class="line">changeme( mylist )</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;函数外取值: &quot;</span>, mylist)</span><br><span class="line">函数内取值:  [<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]]</span><br><span class="line">函数外取值:  [<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]]</span><br></pre></td></tr></table></figure><p>参数</p><ul><li><p>必需参数</p><p>必需参数须以正确的顺序传入函数。调用时的数量必须和声明时的一样。</p></li><li><p>关键字参数</p><p>关键字参数和函数调用关系紧密，函数调用使用关键字参数来确定传入的参数值。</p><p>使用关键字参数允许函数调用时参数的顺序与声明时不一致，因为 Python 解释器能够用参数名匹配参数值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#可写函数说明</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">printme</span>(<span class="params"> <span class="built_in">str</span> </span>):</span></span><br><span class="line">   <span class="string">&quot;打印任何传入的字符串&quot;</span></span><br><span class="line">   <span class="built_in">print</span> (<span class="built_in">str</span>)</span><br><span class="line">   <span class="keyword">return</span></span><br><span class="line"><span class="comment">#调用printme函数</span></span><br><span class="line">printme( <span class="built_in">str</span> = <span class="string">&quot;菜鸟教程&quot;</span>)</span><br><span class="line"><span class="comment">#不需要使用指定顺序</span></span><br><span class="line"><span class="comment">#可写函数说明</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">printinfo</span>(<span class="params"> name, age </span>):</span></span><br><span class="line">   <span class="string">&quot;打印任何传入的字符串&quot;</span></span><br><span class="line">   <span class="built_in">print</span> (<span class="string">&quot;名字: &quot;</span>, name)</span><br><span class="line">   <span class="built_in">print</span> (<span class="string">&quot;年龄: &quot;</span>, age)</span><br><span class="line">   <span class="keyword">return</span></span><br><span class="line"><span class="comment">#调用printinfo函数</span></span><br><span class="line">printinfo( age=<span class="number">50</span>, name=<span class="string">&quot;runoob&quot;</span> )</span><br></pre></td></tr></table></figure></li><li><p>默认参数</p><p>调用函数时，如果没有传递参数，则会使用默认参数。以下实例中如果没有传入 age 参数，则使用默认值：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#可写函数说明</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">printinfo</span>(<span class="params"> name, age = <span class="number">35</span> </span>):</span></span><br><span class="line">   <span class="string">&quot;打印任何传入的字符串&quot;</span></span><br><span class="line">   <span class="built_in">print</span> (<span class="string">&quot;名字: &quot;</span>, name)</span><br><span class="line">   <span class="built_in">print</span> (<span class="string">&quot;年龄: &quot;</span>, age)</span><br><span class="line">   <span class="keyword">return</span></span><br><span class="line"><span class="comment">#调用printinfo函数</span></span><br><span class="line">printinfo( age=<span class="number">50</span>, name=<span class="string">&quot;runoob&quot;</span> )</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;------------------------&quot;</span>)</span><br><span class="line">printinfo( name=<span class="string">&quot;runoob&quot;</span> )</span><br></pre></td></tr></table></figure></li><li><p>不定长参数</p><p>你可能需要一个函数能处理比当初声明时更多的参数。这些参数叫做不定长参数，和上述 2 种参数不同，声明时不会命名。基本语法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">functionname</span>(<span class="params">[formal_args,] *var_args_tuple </span>):</span></span><br><span class="line">   <span class="string">&quot;函数_文档字符串&quot;</span></span><br><span class="line">   function_suite</span><br><span class="line">   <span class="keyword">return</span> [expression]</span><br><span class="line">加了星号 * 的参数会以元组(<span class="built_in">tuple</span>)的形式导入，存放所有未命名的变量参数。</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 可写函数说明</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">printinfo</span>(<span class="params"> arg1, *vartuple </span>):</span></span><br><span class="line">   <span class="string">&quot;打印任何传入的参数&quot;</span></span><br><span class="line">   <span class="built_in">print</span> (<span class="string">&quot;输出: &quot;</span>)</span><br><span class="line">   <span class="built_in">print</span> (arg1)</span><br><span class="line">   <span class="built_in">print</span> (vartuple)</span><br><span class="line"><span class="comment"># 调用printinfo 函数</span></span><br><span class="line">printinfo( <span class="number">70</span>, <span class="number">60</span>, <span class="number">50</span> )</span><br><span class="line">输出: </span><br><span class="line"><span class="number">70</span></span><br><span class="line">(<span class="number">60</span>, <span class="number">50</span>)</span><br></pre></td></tr></table></figure><p>还有一种就是参数带两个星号 ******基本语法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">functionname</span>(<span class="params">[formal_args,] **var_args_dict </span>):</span></span><br><span class="line">   <span class="string">&quot;函数_文档字符串&quot;</span></span><br><span class="line">   function_suite</span><br><span class="line">   <span class="keyword">return</span> [expression]</span><br><span class="line">加了两个星号 ** 的参数会以字典的形式导入</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 可写函数说明</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">printinfo</span>(<span class="params"> arg1, **vardict </span>):</span></span><br><span class="line">   <span class="string">&quot;打印任何传入的参数&quot;</span></span><br><span class="line">   <span class="built_in">print</span> (<span class="string">&quot;输出: &quot;</span>)</span><br><span class="line">   <span class="built_in">print</span> (arg1)</span><br><span class="line">   <span class="built_in">print</span> (vardict)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 调用printinfo 函数</span></span><br><span class="line">printinfo(<span class="number">1</span>, a=<span class="number">2</span>,b=<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">输出: </span><br><span class="line"><span class="number">1</span></span><br><span class="line">&#123;<span class="string">&#x27;a&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;b&#x27;</span>: <span class="number">3</span>&#125;</span><br></pre></td></tr></table></figure><p>声明函数时，参数中星号 ***** 可以单独出现，例如:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span>(<span class="params">a,b,*,c</span>):</span></span><br><span class="line">    <span class="keyword">return</span> a+b+c</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">f</span>(<span class="params">a,b,*,c</span>):</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> a+b+c</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)   <span class="comment"># 报错</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">TypeError: f() takes <span class="number">2</span> positional arguments but <span class="number">3</span> were given</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f(<span class="number">1</span>,<span class="number">2</span>,c=<span class="number">3</span>) <span class="comment"># 正常</span></span><br><span class="line"><span class="number">6</span></span><br></pre></td></tr></table></figure></li><li><p>匿名函数</p></li></ul><p>Python 使用 <strong>lambda</strong> 来创建匿名函数。</p><p>所谓匿名，意即不再使用 <strong>def</strong> 语句这样标准的形式定义一个函数。</p><ul><li><strong>lambda</strong> 只是一个表达式，函数体比 <strong>def</strong> 简单很多。</li><li>lambda 的主体是一个表达式，而不是一个代码块。仅仅能在 lambda 表达式中封装有限的逻辑进去。</li><li>lambda 函数拥有自己的命名空间，且不能访问自己参数列表之外或全局命名空间里的参数。</li><li>虽然 lambda 函数看起来只能写一行，却不等同于 C 或 C++ 的内联函数，后者的目的是调用小函数时不占用栈内存从而增加运行效率。</li></ul><p>lambda 函数的语法只包含一个语句，如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">lambda</span> [arg1 [,arg2,.....argn]]:expression</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#一个参数</span></span><br><span class="line">x = <span class="keyword">lambda</span> a : a + <span class="number">10</span></span><br><span class="line"><span class="built_in">print</span>(x(<span class="number">5</span>))</span><br><span class="line"><span class="comment">#多个参数</span></span><br><span class="line"><span class="comment"># 可写函数说明</span></span><br><span class="line"><span class="built_in">sum</span> = <span class="keyword">lambda</span> arg1, arg2: arg1 + arg2</span><br><span class="line"><span class="comment"># 调用sum函数</span></span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;相加后的值为 : &quot;</span>, <span class="built_in">sum</span>( <span class="number">10</span>, <span class="number">20</span> ))</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;相加后的值为 : &quot;</span>, <span class="built_in">sum</span>( <span class="number">20</span>, <span class="number">20</span> ))</span><br></pre></td></tr></table></figure><p>可以将匿名函数封装在一个函数内，这样可以使用同样的代码来创建多个匿名函数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">myfunc</span>(<span class="params">n</span>):</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">lambda</span> a : a * n</span><br><span class="line"> </span><br><span class="line">mydoubler = myfunc(<span class="number">2</span>)</span><br><span class="line">mytripler = myfunc(<span class="number">3</span>)</span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span>(mydoubler(<span class="number">11</span>))</span><br><span class="line"><span class="built_in">print</span>(mytripler(<span class="number">11</span>))</span><br></pre></td></tr></table></figure></li><li><h5 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h5><p><a href="https://www.runoob.com/python3/python3-data-structure.html">参考菜鸟教程</a></p></li><li><h5 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h5><p>Python 提供了一个办法，把这些定义存放在文件中，为一些脚本或者交互式的解释器实例使用，这个文件被称为模块。</p><p>模块是一个包含所有你定义的函数和变量的文件，其后缀名是.py。模块可以被别的程序引入，以使用该模块中的函数等功能。这也是使用 python 标准库的方法。</p><ul><li>1、import sys 引入 python 标准库中的 sys.py 模块；这是引入某一模块的方法。</li><li>2、sys.argv 是一个包含命令行参数的列表。</li><li>3、sys.path 包含了一个 Python 解释器自动查找所需模块的路径的列表。</li></ul><p><strong>深入模块</strong></p></li><li><h5 id="输入输出"><a href="#输入输出" class="headerlink" title="输入输出"></a>输入输出</h5><ul><li><p>输出格式美化</p><p>Python两种输出值的方式: 表达式语句和 print() 函数。</p><p>第三种方式是使用文件对象的 write() 方法，标准输出文件可以用 sys.stdout 引用。</p><p>如果你希望输出的形式更加多样，可以使用 str.format() 函数来格式化输出值。</p><p>如果你希望将输出的值转成字符串，可以使用 repr() 或 str() 函数来实现。</p><ul><li><strong>str()：</strong> 函数返回一个用户易读的表达形式。</li><li><strong>repr()：</strong> 产生一个解释器易读的表达形式。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = <span class="string">&#x27;Hello, Runoob&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">str</span>(s)</span><br><span class="line"><span class="string">&#x27;Hello, Runoob&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">repr</span>(s)</span><br><span class="line"><span class="string">&quot;&#x27;Hello, Runoob&#x27;&quot;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">str</span>(<span class="number">1</span>/<span class="number">7</span>)</span><br><span class="line"><span class="string">&#x27;0.14285714285714285&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = <span class="number">10</span> * <span class="number">3.25</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>y = <span class="number">200</span> * <span class="number">200</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = <span class="string">&#x27;x 的值为： &#x27;</span> + <span class="built_in">repr</span>(x) + <span class="string">&#x27;,  y 的值为：&#x27;</span> + <span class="built_in">repr</span>(y) + <span class="string">&#x27;...&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(s)</span><br><span class="line">x 的值为： <span class="number">32.5</span>,  y 的值为：<span class="number">40000.</span>..</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment">#  repr() 函数可以转义字符串中的特殊字符</span></span><br><span class="line"><span class="meta">... </span>hello = <span class="string">&#x27;hello, runoob\n&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>hellos = <span class="built_in">repr</span>(hello)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(hellos)</span><br><span class="line"><span class="string">&#x27;hello, runoob\n&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># repr() 的参数可以是 Python 的任何对象</span></span><br><span class="line"><span class="meta">... </span><span class="built_in">repr</span>((x, y, (<span class="string">&#x27;Google&#x27;</span>, <span class="string">&#x27;Runoob&#x27;</span>)))</span><br><span class="line"><span class="string">&quot;(32.5, 40000, (&#x27;Google&#x27;, &#x27;Runoob&#x27;))&quot;</span></span><br></pre></td></tr></table></figure><ul><li><strong>str.format()</strong> </li></ul><p>#<strong>括号及其里面的字符 (称作格式化字段) 将会被 format() 中的参数替换</strong></p><p>&gt;&gt;&gt; <strong>print</strong>(‘{}网址： “{}!”‘.format(‘菜鸟教程’, ‘<a href="http://www.runoob.com&/#39;">www.runoob.com&#39;</a>))<br>菜鸟教程网址： “<a href="http://www.runoob.com!&quot;/">www.runoob.com!&quot;</a></p><p>#<strong>在括号中的数字用于指向传入对象在 format() 中的位置</strong></p><p>&gt;&gt;&gt; <strong>print</strong>(‘{0} 和 {1}’.format(‘Google’, ‘Runoob’))<br>Google 和 Runoob<br>&gt;&gt;&gt; <strong>print</strong>(‘{1} 和 {0}’.format(‘Google’, ‘Runoob’))<br>Runoob 和 Google</p><p>#<strong>如果在 format() 中使用了关键字参数, 那么它们的值会指向使用该名字的参数</strong></p><p>&gt;&gt;&gt; <strong>print</strong>(‘{name}网址： {site}’.format(name=’菜鸟教程’, site=’<a href="http://www.runoob.com&/#39;">www.runoob.com&#39;</a>))<br>菜鸟教程网址： <a href="http://www.runoob.com/">www.runoob.com</a></p><p>#<strong>位置及关键字参数可以任意的结合</strong></p><p>&gt;&gt;&gt; <strong>print</strong>(‘站点列表 {0}, {1}, 和 {other}。’.format(‘Google’, ‘Runoob’, other=’Taobao’))<br>站点列表 Google, Runoob, 和 Taobao。</p><p>#<strong>!a (使用 ascii()), !s (使用 str()) 和 !r (使用 repr()) 可以用于在格式化某个值之前对其进行转化</strong>:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> math</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="string">&#x27;常量 PI 的值近似为： &#123;&#125;。&#x27;</span>.<span class="built_in">format</span>(math.pi))</span><br><span class="line">常量 PI 的值近似为： <span class="number">3.141592653589793</span>。</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="string">&#x27;常量 PI 的值近似为： &#123;!r&#125;。&#x27;</span>.<span class="built_in">format</span>(math.pi))</span><br><span class="line">常量 PI 的值近似为： <span class="number">3.141592653589793</span>。</span><br></pre></td></tr></table></figure><p>#可选项 <strong>:</strong> 和格式标识符可以跟着字段名。 这就允许对值进行更好的格式化。 下面的例子将 Pi 保留到小数点后三位：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> math</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="string">&#x27;常量 PI 的值近似为 &#123;0:.3f&#125;。&#x27;</span>.<span class="built_in">format</span>(math.pi))</span><br><span class="line">常量 PI 的值近似为 <span class="number">3.142</span>。</span><br></pre></td></tr></table></figure><p>#在 <strong>:</strong> 后传入一个整数, 可以保证该域至少有这么多的宽度。 用于美化表格时很有用</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>table = &#123;<span class="string">&#x27;Google&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;Runoob&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;Taobao&#x27;</span>: <span class="number">3</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> name, number <span class="keyword">in</span> table.items():</span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span>(<span class="string">&#x27;&#123;0:10&#125; ==&gt; &#123;1:10d&#125;&#x27;</span>.<span class="built_in">format</span>(name, number))</span><br><span class="line">...</span><br><span class="line">Google     ==&gt;          <span class="number">1</span></span><br><span class="line">Runoob     ==&gt;          <span class="number">2</span></span><br><span class="line">Taobao     ==&gt;          <span class="number">3</span></span><br></pre></td></tr></table></figure><ul><li><p>旧式字符串格式化</p><p><strong>%</strong> 操作符也可以实现字符串格式化。 它将左边的参数作为类似 <strong>sprintf()</strong> 式的格式化字符串, 而将右边的代入, 然后返回格式化后的字符串.</p><p>但是因为这种旧式的格式化最终会从该语言中移除, 应该更多的使用 str.format().</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> math</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="string">&#x27;常量 PI 的值近似为：%5.3f。&#x27;</span> % math.pi)</span><br><span class="line">常量 PI 的值近似为：<span class="number">3.142</span>。</span><br></pre></td></tr></table></figure></li><li><p>读取键盘输入</p><p>使用input()内置函数从标准输入读入一行文本，默认的标准输入是键盘</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"><span class="built_in">str</span> = <span class="built_in">input</span>(<span class="string">&quot;请输入：&quot;</span>);</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;你输入的内容是: &quot;</span>, <span class="built_in">str</span>)</span><br></pre></td></tr></table></figure></li><li><p>读写文件</p><p>open() 将会返回一个 file 对象：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">open</span>(filename, mode)</span><br><span class="line">filename：包含了你要访问的文件名称的字符串值。</span><br><span class="line">mode：决定了打开文件的模式：只读，写入，追加等。所有可取值见如下的完全列表。这个参数是非强制的，默认文件访问模式为只读(r)。</span><br></pre></td></tr></table></figure><p>实例</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 打开一个文件</span></span><br><span class="line">f = <span class="built_in">open</span>(<span class="string">&quot;/tmp/foo.txt&quot;</span>, <span class="string">&quot;w&quot;</span>)</span><br><span class="line">f.write( <span class="string">&quot;Python 是一个非常好的语言。\n是的，的确非常好!!\n&quot;</span> )</span><br><span class="line"><span class="comment"># 关闭打开的文件</span></span><br><span class="line">f.close()</span><br></pre></td></tr></table></figure><p>不同模式打开文件的完全列表：</p><table><thead><tr><th align="left">模式</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">r</td><td align="left">以只读方式打开文件。文件的指针将会放在文件的开头。这是默认模式。</td></tr><tr><td align="left">rb</td><td align="left">以二进制格式打开一个文件用于只读。文件指针将会放在文件的开头。</td></tr><tr><td align="left">r+</td><td align="left">打开一个文件用于读写。文件指针将会放在文件的开头。</td></tr><tr><td align="left">rb+</td><td align="left">以二进制格式打开一个文件用于读写。文件指针将会放在文件的开头。</td></tr><tr><td align="left">w</td><td align="left">打开一个文件只用于写入。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。</td></tr><tr><td align="left">wb</td><td align="left">以二进制格式打开一个文件只用于写入。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。</td></tr><tr><td align="left">w+</td><td align="left">打开一个文件用于读写。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。</td></tr><tr><td align="left">wb+</td><td align="left">以二进制格式打开一个文件用于读写。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。</td></tr><tr><td align="left">a</td><td align="left">打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。</td></tr><tr><td align="left">ab</td><td align="left">以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。</td></tr><tr><td align="left">a+</td><td align="left">打开一个文件用于读写。如果该文件已存在，文件指针将会放在文件的结尾。文件打开时会是追加模式。如果该文件不存在，创建新文件用于读写。</td></tr><tr><td align="left">ab+</td><td align="left">以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。如果该文件不存在，创建新文件用于读写。</td></tr></tbody></table><table><thead><tr><th align="center">模式</th><th align="center">r</th><th align="center">r+</th><th align="center">w</th><th align="center">w+</th><th align="center">a</th><th align="center">a+</th></tr></thead><tbody><tr><td align="center">读</td><td align="center">+</td><td align="center">+</td><td align="center"></td><td align="center">+</td><td align="center"></td><td align="center">+</td></tr><tr><td align="center">写</td><td align="center"></td><td align="center">+</td><td align="center">+</td><td align="center">+</td><td align="center">+</td><td align="center">+</td></tr><tr><td align="center">创建</td><td align="center"></td><td align="center"></td><td align="center">+</td><td align="center">+</td><td align="center">+</td><td align="center">+</td></tr><tr><td align="center">覆盖</td><td align="center"></td><td align="center"></td><td align="center">+</td><td align="center">+</td><td align="center"></td><td align="center"></td></tr><tr><td align="center">指针在开始</td><td align="center">+</td><td align="center">+</td><td align="center">+</td><td align="center">+</td><td align="center"></td><td align="center"></td></tr><tr><td align="center">指针在结尾</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center">+</td><td align="center">+</td></tr></tbody></table></li><li><p>文件对象方法</p><p><strong>f.read()</strong></p><p>#调用 f.read(size), 这将读取一定数目的数据, 然后作为字符串或字节对象返回。size 是一个可选的数字类型的参数。 当 size 被忽略了或者为负, 那么该文件的所有内容都将被读取并且返回。</p><p>实例</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"><span class="comment"># 打开一个文件</span></span><br><span class="line">f = <span class="built_in">open</span>(<span class="string">&quot;/tmp/foo.txt&quot;</span>, <span class="string">&quot;r&quot;</span>)</span><br><span class="line"><span class="built_in">str</span> = f.read()</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>)</span><br><span class="line"><span class="comment"># 关闭打开的文件</span></span><br><span class="line">f.close()</span><br><span class="line"></span><br><span class="line">Python 是一个非常好的语言。</span><br><span class="line">是的，的确非常好!!</span><br></pre></td></tr></table></figure><p><strong>f.readline()</strong></p><p>#f.readline() 会从文件中读取单独的一行。换行符为 ‘\n’。f.readline() 如果返回一个空字符串, 说明已经已经读取到最后一行。</p><p>实例</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 打开一个文件</span></span><br><span class="line">f = <span class="built_in">open</span>(<span class="string">&quot;/tmp/foo.txt&quot;</span>, <span class="string">&quot;r&quot;</span>)</span><br><span class="line"><span class="built_in">str</span> = f.readline()</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>)</span><br><span class="line"><span class="comment"># 关闭打开的文件</span></span><br><span class="line">f.close()</span><br><span class="line"></span><br><span class="line">Python 是一个非常好的语言。</span><br></pre></td></tr></table></figure><p><strong>f.readlines()</strong></p><p>#返回该文件中包含的所有行。</p><p>#如果设置可选参数 sizehint, 则读取指定长度的字节, 并且将这些字节按行分割。</p><p>实例1</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"><span class="comment"># 打开一个文件</span></span><br><span class="line">f = <span class="built_in">open</span>(<span class="string">&quot;/tmp/foo.txt&quot;</span>, <span class="string">&quot;r&quot;</span>)</span><br><span class="line"><span class="built_in">str</span> = f.readlines()</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>)</span><br><span class="line"><span class="comment"># 关闭打开的文件</span></span><br><span class="line">f.close()</span><br><span class="line">输出</span><br><span class="line">[<span class="string">&#x27;Python 是一个非常好的语言。\n&#x27;</span>, <span class="string">&#x27;是的，的确非常好!!\n&#x27;</span>]</span><br></pre></td></tr></table></figure><p>实例2 迭代一个文件对象然后读取每行:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 打开一个文件</span></span><br><span class="line">f = <span class="built_in">open</span>(<span class="string">&quot;/tmp/foo.txt&quot;</span>, <span class="string">&quot;r&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> f:</span><br><span class="line">    <span class="built_in">print</span>(line, end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line"><span class="comment"># 关闭打开的文件</span></span><br><span class="line">f.close()</span><br><span class="line">执行以上程序，输出结果为：</span><br><span class="line">Python 是一个非常好的语言。</span><br><span class="line">是的，的确非常好!!</span><br></pre></td></tr></table></figure><p><strong>f.write()</strong></p><p>f.write(string) 将 string 写入到文件中, 然后返回写入的字符数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"><span class="comment"># 打开一个文件</span></span><br><span class="line">f = <span class="built_in">open</span>(<span class="string">&quot;/tmp/foo.txt&quot;</span>, <span class="string">&quot;w&quot;</span>)</span><br><span class="line">num = f.write( <span class="string">&quot;Python 是一个非常好的语言。\n是的，的确非常好!!\n&quot;</span> )</span><br><span class="line"><span class="built_in">print</span>(num)</span><br><span class="line"><span class="comment"># 关闭打开的文件</span></span><br><span class="line">f.close()</span><br><span class="line">执行以上程序，输出结果为：</span><br><span class="line"><span class="number">29</span></span><br></pre></td></tr></table></figure><p>如果要写入一些不是字符串的东西, 那么将需要先进行转换:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"><span class="comment"># 打开一个文件</span></span><br><span class="line">f = <span class="built_in">open</span>(<span class="string">&quot;/tmp/foo1.txt&quot;</span>, <span class="string">&quot;w&quot;</span>)</span><br><span class="line">value = (<span class="string">&#x27;www.runoob.com&#x27;</span>, <span class="number">14</span>)</span><br><span class="line">s = <span class="built_in">str</span>(value)</span><br><span class="line">f.write(s)</span><br><span class="line"><span class="comment"># 关闭打开的文件</span></span><br><span class="line">f.close()</span><br><span class="line">执行以上程序，打开 foo1.txt 文件：</span><br><span class="line">$ cat /tmp/foo1.txt </span><br><span class="line">(<span class="string">&#x27;www.runoob.com&#x27;</span>, <span class="number">14</span>)</span><br></pre></td></tr></table></figure><p><strong>f.tell()</strong></p><p>f.tell() 返回文件对象当前所处的位置, 它是从文件开头开始算起的字节数。</p><p><strong>f.seek()</strong></p><p>如果要改变文件当前的位置, 可以使用 f.seek(offset, from_what) 函数。</p><p>from_what 的值, 如果是 0 表示开头, 如果是 1 表示当前位置, 2 表示文件的结尾，例如：</p><ul><li>seek(x,0) ： 从起始位置即文件首行首字符开始移动 x 个字符</li><li>seek(x,1) ： 表示从当前位置往后移动x个字符</li><li>seek(-x,2)：表示从文件的结尾往前移动x个字符</li></ul><p>from_what 值为默认为0，即文件开头。下面给出一个完整的例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>f = <span class="built_in">open</span>(<span class="string">&#x27;/tmp/foo.txt&#x27;</span>, <span class="string">&#x27;rb+&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f.write(<span class="string">b&#x27;0123456789abcdef&#x27;</span>)</span><br><span class="line"><span class="number">16</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f.seek(<span class="number">5</span>)     <span class="comment"># 移动到文件的第六个字节</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f.read(<span class="number">1</span>)</span><br><span class="line"><span class="string">b&#x27;5&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f.seek(-<span class="number">3</span>, <span class="number">2</span>) <span class="comment"># 移动到文件的倒数第三字节</span></span><br><span class="line"><span class="number">13</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f.read(<span class="number">1</span>)</span><br><span class="line"><span class="string">b&#x27;d&#x27;</span></span><br></pre></td></tr></table></figure><p><strong>f.close()</strong></p><p>当你处理完一个文件后, 调用 f.close() 来关闭文件并释放系统的资源，如果尝试再调用该文件，则会抛出异常。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>f.close()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f.read()</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> ?</span><br><span class="line">ValueError: I/O operation on closed file</span><br></pre></td></tr></table></figure><p>当处理一个文件对象时, 使用 with 关键字是非常好的方式。在结束后, 它会帮你正确的关闭文件。 而且写起来也比 try - finally 语句块要简短:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;/tmp/foo.txt&#x27;</span>, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line"><span class="meta">... </span>    read_data = f.read()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f.closed</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure></li><li><p>pickle 模块</p><p>python的pickle模块实现了基本的数据序列和反序列化。</p><p>通过pickle模块的序列化操作我们能够将程序中运行的对象信息保存到文件中去，永久存储。</p><p>通过pickle模块的反序列化操作，我们能够从文件中创建上一次程序保存的对象。</p><p>基本接口：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pickle.dump(obj, file, [,protocol])</span><br></pre></td></tr></table></figure><p>有了 pickle 这个对象, 就能对 file 以读取的形式打开:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x = pickle.load(file)</span><br></pre></td></tr></table></figure><p><strong>注解：</strong>从 file 中读取一个字符串，并将它重构为原来的python对象。</p><p><strong>file:</strong> 类文件对象，有read()和readline()接口。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用pickle模块将数据对象保存到文件</span></span><br><span class="line">data1 = &#123;<span class="string">&#x27;a&#x27;</span>: [<span class="number">1</span>, <span class="number">2.0</span>, <span class="number">3</span>, <span class="number">4</span>+<span class="number">6j</span>],</span><br><span class="line">         <span class="string">&#x27;b&#x27;</span>: (<span class="string">&#x27;string&#x27;</span>, <span class="string">u&#x27;Unicode string&#x27;</span>),</span><br><span class="line">         <span class="string">&#x27;c&#x27;</span>: <span class="literal">None</span>&#125;</span><br><span class="line"></span><br><span class="line">selfref_list = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">selfref_list.append(selfref_list)</span><br><span class="line"></span><br><span class="line">output = <span class="built_in">open</span>(<span class="string">&#x27;data.pkl&#x27;</span>, <span class="string">&#x27;wb&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Pickle dictionary using protocol 0.</span></span><br><span class="line">pickle.dump(data1, output)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Pickle the list using the highest protocol available.</span></span><br><span class="line">pickle.dump(selfref_list, output, -<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">output.close()</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pprint, pickle</span><br><span class="line"></span><br><span class="line"><span class="comment">#使用pickle模块从文件中重构python对象</span></span><br><span class="line">pkl_file = <span class="built_in">open</span>(<span class="string">&#x27;data.pkl&#x27;</span>, <span class="string">&#x27;rb&#x27;</span>)</span><br><span class="line"></span><br><span class="line">data1 = pickle.load(pkl_file)</span><br><span class="line">pprint.pprint(data1)</span><br><span class="line"></span><br><span class="line">data2 = pickle.load(pkl_file)</span><br><span class="line">pprint.pprint(data2)</span><br><span class="line"></span><br><span class="line">pkl_file.close()</span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li><h5 id="File"><a href="#File" class="headerlink" title="File"></a>File</h5><ul><li><strong>open()方法</strong></li></ul><p>Python open() 方法用于打开一个文件，并返回文件对象，在对文件进行处理过程都需要使用到这个函数，如果该文件无法被打开，会抛出 OSError。</p><p><strong>注意：</strong>使用 open() 方法一定要保证关闭文件对象，即调用 close() 方法。</p><p>open() 函数常用形式是接收两个参数：文件名(file)和模式(mode)。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">open</span>(file, mode=<span class="string">&#x27;r&#x27;</span>)</span><br></pre></td></tr></table></figure><p>完整的语法格式为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">open</span>(file, mode=<span class="string">&#x27;r&#x27;</span>, buffering=-<span class="number">1</span>, encoding=<span class="literal">None</span>, errors=<span class="literal">None</span>, newline=<span class="literal">None</span>, closefd=<span class="literal">True</span>, opener=<span class="literal">None</span>)</span><br></pre></td></tr></table></figure><p>参数说明:</p><ul><li>file: 必需，文件路径（相对或者绝对路径）。</li><li>mode: 可选，文件打开模式</li><li>buffering: 设置缓冲</li><li>encoding: 一般使用utf8</li><li>errors: 报错级别</li><li>newline: 区分换行符</li><li>closefd: 传入的file参数类型</li><li>opener: 设置自定义开启器，开启器的返回值必须是一个打开的文件描述符。</li></ul><p>mode 参数有：</p><table><thead><tr><th align="left">模式</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">t</td><td align="left">文本模式 (默认)。</td></tr><tr><td align="left">x</td><td align="left">写模式，新建一个文件，如果该文件已存在则会报错。</td></tr><tr><td align="left">b</td><td align="left">二进制模式。</td></tr><tr><td align="left">+</td><td align="left">打开一个文件进行更新(可读可写)。</td></tr><tr><td align="left">U</td><td align="left">通用换行模式（<strong>Python 3 不支持</strong>）。</td></tr><tr><td align="left">r</td><td align="left">以只读方式打开文件。文件的指针将会放在文件的开头。这是默认模式。</td></tr><tr><td align="left">rb</td><td align="left">以二进制格式打开一个文件用于只读。文件指针将会放在文件的开头。这是默认模式。一般用于非文本文件如图片等。</td></tr><tr><td align="left">r+</td><td align="left">打开一个文件用于读写。文件指针将会放在文件的开头。</td></tr><tr><td align="left">rb+</td><td align="left">以二进制格式打开一个文件用于读写。文件指针将会放在文件的开头。一般用于非文本文件如图片等。</td></tr><tr><td align="left">w</td><td align="left">打开一个文件只用于写入。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。</td></tr><tr><td align="left">wb</td><td align="left">以二进制格式打开一个文件只用于写入。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。一般用于非文本文件如图片等。</td></tr><tr><td align="left">w+</td><td align="left">打开一个文件用于读写。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。</td></tr><tr><td align="left">wb+</td><td align="left">以二进制格式打开一个文件用于读写。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。一般用于非文本文件如图片等。</td></tr><tr><td align="left">a</td><td align="left">打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。</td></tr><tr><td align="left">ab</td><td align="left">以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。</td></tr><tr><td align="left">a+</td><td align="left">打开一个文件用于读写。如果该文件已存在，文件指针将会放在文件的结尾。文件打开时会是追加模式。如果该文件不存在，创建新文件用于读写。</td></tr><tr><td align="left">ab+</td><td align="left">以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。如果该文件不存在，创建新文件用于读写。</td></tr></tbody></table><p>默认为文本模式，如果要以二进制模式打开，加上 <strong>b</strong> 。</p><ul><li><p>file 对象</p><p>file 对象使用 open 函数来创建，下表列出了 file 对象常用的函数：</p><table><thead><tr><th align="left">序号</th><th align="left">方法及描述</th></tr></thead><tbody><tr><td align="left">1</td><td align="left"><a href="https://www.runoob.com/python3/python3-file-close.html">file.close()</a>关闭文件。关闭后文件不能再进行读写操作。</td></tr><tr><td align="left">2</td><td align="left"><a href="https://www.runoob.com/python3/python3-file-flush.html">file.flush()</a>刷新文件内部缓冲，直接把内部缓冲区的数据立刻写入文件, 而不是被动的等待输出缓冲区写入。</td></tr><tr><td align="left">3</td><td align="left"><a href="https://www.runoob.com/python3/python3-file-fileno.html">file.fileno()</a>返回一个整型的文件描述符(file descriptor FD 整型), 可以用在如os模块的read方法等一些底层操作上。</td></tr><tr><td align="left">4</td><td align="left"><a href="https://www.runoob.com/python3/python3-file-isatty.html">file.isatty()</a>如果文件连接到一个终端设备返回 True，否则返回 False。</td></tr><tr><td align="left">5</td><td align="left"><a href="https://www.runoob.com/python3/python3-file-next.html">file.next()</a><strong>Python 3 中的 File 对象不支持 next() 方法。</strong>返回文件下一行。</td></tr><tr><td align="left">6</td><td align="left">[file.read(<a href="https://www.runoob.com/python3/python3-file-read.html">size])</a>从文件读取指定的字节数，如果未给定或为负则读取所有。</td></tr><tr><td align="left">7</td><td align="left">[file.readline(<a href="https://www.runoob.com/python3/python3-file-readline.html">size])</a>读取整行，包括 “\n” 字符。</td></tr><tr><td align="left">8</td><td align="left">[file.readlines(<a href="https://www.runoob.com/python3/python3-file-readlines.html">sizeint])</a>读取所有行并返回列表，若给定sizeint&gt;0，返回总和大约为sizeint字节的行, 实际读取值可能比 sizeint 较大, 因为需要填充缓冲区。</td></tr><tr><td align="left">9</td><td align="left">[file.seek(offset<a href="https://www.runoob.com/python3/python3-file-seek.html">, whence])</a>移动文件读取指针到指定位置</td></tr><tr><td align="left">10</td><td align="left"><a href="https://www.runoob.com/python3/python3-file-tell.html">file.tell()</a>返回文件当前位置。</td></tr><tr><td align="left">11</td><td align="left">[file.truncate(<a href="https://www.runoob.com/python3/python3-file-truncate.html">size])</a>从文件的首行首字符开始截断，截断文件为 size 个字符，无 size 表示从当前位置截断；截断之后后面的所有字符被删除，其中 windows 系统下的换行代表2个字符大小。</td></tr><tr><td align="left">12</td><td align="left"><a href="https://www.runoob.com/python3/python3-file-write.html">file.write(str)</a>将字符串写入文件，返回的是写入的字符长度。</td></tr><tr><td align="left">13</td><td align="left"><a href="https://www.runoob.com/python3/python3-file-writelines.html">file.writelines(sequence)</a>向文件写入一个序列字符串列表，如果需要换行则要自己加入每行的换行符。</td></tr></tbody></table></li></ul></li><li><h5 id="OS"><a href="#OS" class="headerlink" title="OS"></a>OS</h5><p><strong>os</strong> 模块提供了非常丰富的方法用来处理文件和目录。常用的方法如下表所示：</p><table><thead><tr><th align="left">序号</th><th align="left">方法及描述</th></tr></thead><tbody><tr><td align="left">1</td><td align="left"><a href="https://www.runoob.com/python3/python3-os-access.html">os.access(path, mode)</a> 检验权限模式</td></tr><tr><td align="left">2</td><td align="left"><a href="https://www.runoob.com/python3/python3-os-chdir.html">os.chdir(path)</a> 改变当前工作目录</td></tr><tr><td align="left">3</td><td align="left"><a href="https://www.runoob.com/python3/python3-os-chflags.html">os.chflags(path, flags)</a> 设置路径的标记为数字标记。</td></tr><tr><td align="left">4</td><td align="left"><a href="https://www.runoob.com/python3/python3-os-chmod.html">os.chmod(path, mode)</a> 更改权限</td></tr><tr><td align="left">5</td><td align="left"><a href="https://www.runoob.com/python3/python3-os-chown.html">os.chown(path, uid, gid)</a> 更改文件所有者</td></tr><tr><td align="left">6</td><td align="left"><a href="https://www.runoob.com/python3/python3-os-chroot.html">os.chroot(path)</a> 改变当前进程的根目录</td></tr><tr><td align="left">7</td><td align="left"><a href="https://www.runoob.com/python3/python3-os-close.html">os.close(fd)</a> 关闭文件描述符 fd</td></tr><tr><td align="left">8</td><td align="left"><a href="https://www.runoob.com/python3/python3-os-closerange.html">os.closerange(fd_low, fd_high)</a> 关闭所有文件描述符，从 fd_low (包含) 到 fd_high (不包含), 错误会忽略</td></tr><tr><td align="left">9</td><td align="left"><a href="https://www.runoob.com/python3/python3-os-dup.html">os.dup(fd)</a> 复制文件描述符 fd</td></tr><tr><td align="left">10</td><td align="left"><a href="https://www.runoob.com/python3/python3-os-dup2.html">os.dup2(fd, fd2)</a> 将一个文件描述符 fd 复制到另一个 fd2</td></tr><tr><td align="left">11</td><td align="left"><a href="https://www.runoob.com/python3/python3-os-fchdir.html">os.fchdir(fd)</a> 通过文件描述符改变当前工作目录</td></tr><tr><td align="left">12</td><td align="left"><a href="https://www.runoob.com/python3/python3-os-fchmod.html">os.fchmod(fd, mode)</a> 改变一个文件的访问权限，该文件由参数fd指定，参数mode是Unix下的文件访问权限。</td></tr><tr><td align="left">13</td><td align="left"><a href="https://www.runoob.com/python3/python3-os-fchown.html">os.fchown(fd, uid, gid)</a> 修改一个文件的所有权，这个函数修改一个文件的用户ID和用户组ID，该文件由文件描述符fd指定。</td></tr><tr><td align="left">14</td><td align="left"><a href="https://www.runoob.com/python3/python3-os-fdatasync.html">os.fdatasync(fd)</a> 强制将文件写入磁盘，该文件由文件描述符fd指定，但是不强制更新文件的状态信息。</td></tr><tr><td align="left">15</td><td align="left">[os.fdopen(fd<a href="https://www.runoob.com/python3/python3-os-fdopen.html">, mode[, bufsize]])</a> 通过文件描述符 fd 创建一个文件对象，并返回这个文件对象</td></tr><tr><td align="left">16</td><td align="left"><a href="https://www.runoob.com/python3/python3-os-fpathconf.html">os.fpathconf(fd, name)</a> 返回一个打开的文件的系统配置信息。name为检索的系统配置的值，它也许是一个定义系统值的字符串，这些名字在很多标准中指定（POSIX.1, Unix 95, Unix 98, 和其它）。</td></tr><tr><td align="left">17</td><td align="left"><a href="https://www.runoob.com/python3/python3-os-fstat.html">os.fstat(fd)</a> 返回文件描述符fd的状态，像stat()。</td></tr><tr><td align="left">18</td><td align="left"><a href="https://www.runoob.com/python3/python3-os-fstatvfs.html">os.fstatvfs(fd)</a> 返回包含文件描述符fd的文件的文件系统的信息，Python 3.3 相等于 statvfs()。</td></tr><tr><td align="left">19</td><td align="left"><a href="https://www.runoob.com/python3/python3-os-fsync.html">os.fsync(fd)</a> 强制将文件描述符为fd的文件写入硬盘。</td></tr><tr><td align="left">20</td><td align="left"><a href="https://www.runoob.com/python3/python3-os-ftruncate.html">os.ftruncate(fd, length)</a> 裁剪文件描述符fd对应的文件, 所以它最大不能超过文件大小。</td></tr><tr><td align="left">21</td><td align="left"><a href="https://www.runoob.com/python3/python3-os-getcwd.html">os.getcwd()</a> 返回当前工作目录</td></tr><tr><td align="left">22</td><td align="left"><a href="https://www.runoob.com/python3/python3-os-getcwdb.html">os.getcwdb()</a> 返回一个当前工作目录的Unicode对象</td></tr><tr><td align="left">23</td><td align="left"><a href="https://www.runoob.com/python3/python3-os-isatty.html">os.isatty(fd)</a> 如果文件描述符fd是打开的，同时与tty(-like)设备相连，则返回true, 否则False。</td></tr><tr><td align="left">24</td><td align="left"><a href="https://www.runoob.com/python3/python3-os-lchflags.html">os.lchflags(path, flags)</a> 设置路径的标记为数字标记，类似 chflags()，但是没有软链接</td></tr><tr><td align="left">25</td><td align="left"><a href="https://www.runoob.com/python3/python3-os-lchmod.html">os.lchmod(path, mode)</a> 修改连接文件权限</td></tr><tr><td align="left">26</td><td align="left"><a href="https://www.runoob.com/python3/python3-os-lchown.html">os.lchown(path, uid, gid)</a> 更改文件所有者，类似 chown，但是不追踪链接。</td></tr><tr><td align="left">27</td><td align="left"><a href="https://www.runoob.com/python3/python3-os-link.html">os.link(src, dst)</a> 创建硬链接，名为参数 dst，指向参数 src</td></tr><tr><td align="left">28</td><td align="left"><a href="https://www.runoob.com/python3/python3-os-listdir.html">os.listdir(path)</a> 返回path指定的文件夹包含的文件或文件夹的名字的列表。</td></tr><tr><td align="left">29</td><td align="left"><a href="https://www.runoob.com/python3/python3-os-lseek.html">os.lseek(fd, pos, how)</a> 设置文件描述符 fd当前位置为pos, how方式修改: SEEK_SET 或者 0 设置从文件开始的计算的pos; SEEK_CUR或者 1 则从当前位置计算; os.SEEK_END或者2则从文件尾部开始. 在unix，Windows中有效</td></tr><tr><td align="left">30</td><td align="left"><a href="https://www.runoob.com/python3/python3-os-lstat.html">os.lstat(path)</a> 像stat(),但是没有软链接</td></tr><tr><td align="left">31</td><td align="left"><a href="https://www.runoob.com/python3/python3-os-major.html">os.major(device)</a> 从原始的设备号中提取设备major号码 (使用stat中的st_dev或者st_rdev field)。</td></tr><tr><td align="left">32</td><td align="left"><a href="https://www.runoob.com/python3/python3-os-makedev.html">os.makedev(major, minor)</a> 以major和minor设备号组成一个原始设备号</td></tr><tr><td align="left">33</td><td align="left">[os.makedirs(path<a href="https://www.runoob.com/python3/python3-os-makedirs.html">, mode])</a> 递归文件夹创建函数。像mkdir(), 但创建的所有intermediate-level文件夹需要包含子文件夹。</td></tr><tr><td align="left">34</td><td align="left"><a href="https://www.runoob.com/python3/python3-os-minor.html">os.minor(device)</a> 从原始的设备号中提取设备minor号码 (使用stat中的st_dev或者st_rdev field )。</td></tr><tr><td align="left">35</td><td align="left">[os.mkdir(path<a href="https://www.runoob.com/python3/python3-os-mkdir.html">, mode])</a> 以数字mode的mode创建一个名为path的文件夹.默认的 mode 是 0777 (八进制)。</td></tr><tr><td align="left">36</td><td align="left">[os.mkfifo(path<a href="https://www.runoob.com/python3/python3-os-mkfifo.html">, mode])</a> 创建命名管道，mode 为数字，默认为 0666 (八进制)</td></tr><tr><td align="left">37</td><td align="left">[os.mknod(filename<a href="https://www.runoob.com/python3/python3-os-mknod.html">, mode=0600, device])</a> 创建一个名为filename文件系统节点（文件，设备特别文件或者命名pipe）。</td></tr><tr><td align="left">38</td><td align="left">[os.open(file, flags<a href="https://www.runoob.com/python3/python3-os-open.html">, mode])</a> 打开一个文件，并且设置需要的打开选项，mode参数是可选的</td></tr><tr><td align="left">39</td><td align="left"><a href="https://www.runoob.com/python3/python3-os-openpty.html">os.openpty()</a> 打开一个新的伪终端对。返回 pty 和 tty的文件描述符。</td></tr><tr><td align="left">40</td><td align="left"><a href="https://www.runoob.com/python3/python3-os-pathconf.html">os.pathconf(path, name)</a> 返回相关文件的系统配置信息。</td></tr><tr><td align="left">41</td><td align="left"><a href="https://www.runoob.com/python3/python3-os-pipe.html">os.pipe()</a> 创建一个管道. 返回一对文件描述符(r, w) 分别为读和写</td></tr><tr><td align="left">42</td><td align="left">[os.popen(command<a href="https://www.runoob.com/python3/python3-os-popen.html">, mode[, bufsize]])</a> 从一个 command 打开一个管道</td></tr><tr><td align="left">43</td><td align="left"><a href="https://www.runoob.com/python3/python3-os-read.html">os.read(fd, n)</a> 从文件描述符 fd 中读取最多 n 个字节，返回包含读取字节的字符串，文件描述符 fd对应文件已达到结尾, 返回一个空字符串。</td></tr><tr><td align="left">44</td><td align="left"><a href="https://www.runoob.com/python3/python3-os-readlink.html">os.readlink(path)</a> 返回软链接所指向的文件</td></tr><tr><td align="left">45</td><td align="left"><a href="https://www.runoob.com/python3/python3-os-remove.html">os.remove(path)</a> 删除路径为path的文件。如果path 是一个文件夹，将抛出OSError; 查看下面的rmdir()删除一个 directory。</td></tr><tr><td align="left">46</td><td align="left"><a href="https://www.runoob.com/python3/python3-os-removedirs.html">os.removedirs(path)</a> 递归删除目录。</td></tr><tr><td align="left">47</td><td align="left"><a href="https://www.runoob.com/python3/python3-os-rename.html">os.rename(src, dst)</a> 重命名文件或目录，从 src 到 dst</td></tr><tr><td align="left">48</td><td align="left"><a href="https://www.runoob.com/python3/python3-os-renames.html">os.renames(old, new)</a> 递归地对目录进行更名，也可以对文件进行更名。</td></tr><tr><td align="left">49</td><td align="left"><a href="https://www.runoob.com/python3/python3-os-rmdir.html">os.rmdir(path)</a> 删除path指定的空目录，如果目录非空，则抛出一个OSError异常。</td></tr><tr><td align="left">50</td><td align="left"><a href="https://www.runoob.com/python3/python3-os-stat.html">os.stat(path)</a> 获取path指定的路径的信息，功能等同于C API中的stat()系统调用。</td></tr><tr><td align="left">51</td><td align="left">[os.stat_float_times(<a href="https://www.runoob.com/python3/python3-os-stat_float_times.html">newvalue])</a> 决定stat_result是否以float对象显示时间戳</td></tr><tr><td align="left">52</td><td align="left"><a href="https://www.runoob.com/python3/python3-os-statvfs.html">os.statvfs(path)</a> 获取指定路径的文件系统统计信息</td></tr><tr><td align="left">53</td><td align="left"><a href="https://www.runoob.com/python3/python3-os-symlink.html">os.symlink(src, dst)</a> 创建一个软链接</td></tr><tr><td align="left">54</td><td align="left"><a href="https://www.runoob.com/python3/python3-os-tcgetpgrp.html">os.tcgetpgrp(fd)</a> 返回与终端fd（一个由os.open()返回的打开的文件描述符）关联的进程组</td></tr><tr><td align="left">55</td><td align="left"><a href="https://www.runoob.com/python3/python3-os-tcsetpgrp.html">os.tcsetpgrp(fd, pg)</a> 设置与终端fd（一个由os.open()返回的打开的文件描述符）关联的进程组为pg。</td></tr><tr><td align="left">56</td><td align="left">os.tempnam([dir[, prefix]]) <strong>Python3 中已删除。</strong>返回唯一的路径名用于创建临时文件。</td></tr><tr><td align="left">57</td><td align="left">os.tmpfile() <strong>Python3 中已删除。</strong>返回一个打开的模式为(w+b)的文件对象 .这文件对象没有文件夹入口，没有文件描述符，将会自动删除。</td></tr><tr><td align="left">58</td><td align="left">os.tmpnam() <strong>Python3 中已删除。</strong>为创建一个临时文件返回一个唯一的路径</td></tr><tr><td align="left">59</td><td align="left"><a href="https://www.runoob.com/python3/python3-os-ttyname.html">os.ttyname(fd)</a> 返回一个字符串，它表示与文件描述符fd 关联的终端设备。如果fd 没有与终端设备关联，则引发一个异常。</td></tr><tr><td align="left">60</td><td align="left"><a href="https://www.runoob.com/python3/python3-os-unlink.html">os.unlink(path)</a> 删除文件路径</td></tr><tr><td align="left">61</td><td align="left"><a href="https://www.runoob.com/python3/python3-os-utime.html">os.utime(path, times)</a> 返回指定的path文件的访问和修改的时间。</td></tr><tr><td align="left">62</td><td align="left">[os.walk(top[, topdown=True[, onerror=None[, followlinks=False]]])](<a href="https://www.runoob.com/python3/python3-os-walk.html">https://www.runoob.com/python3/python3-os-walk.html</a>) 输出在文件夹中的文件名通过在树中游走，向上或者向下。</td></tr><tr><td align="left">63</td><td align="left"><a href="https://www.runoob.com/python3/python3-os-write.html">os.write(fd, str)</a> 写入字符串到文件描述符 fd中. 返回实际写入的字符串长度</td></tr><tr><td align="left">64</td><td align="left"><a href="https://www.runoob.com/python3/python3-os-path.html">os.path 模块</a> 获取文件的属性信息。</td></tr><tr><td align="left">65</td><td align="left"><a href="https://www.runoob.com/python3/python3-os-pardir.html">os.pardir()</a> 获取当前目录的父目录，以字符串形式显示目录名。</td></tr></tbody></table></li><li><h5 id="错误与异常处理"><a href="#错误与异常处理" class="headerlink" title="错误与异常处理"></a>错误与异常处理</h5><ul><li><p>语法错误 - 语法分析器检测到错误</p></li><li><p>异常 -运行期检测到的错误</p></li><li><p>异常处理</p><ul><li><p>try/except</p><p><img src="https://github.com/hxlpub/imgs/blob/master/try_except.png?raw=true" alt="try/except"></p><p>以下例子中，让用户输入一个合法的整数，但是允许用户中断这个程序（使用 Control-C 或者操作系统提供的方法）。用户中断的信息会引发一个 KeyboardInterrupt 异常。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        x = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;请输入一个数字: &quot;</span>))</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">except</span> ValueError:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;您输入的不是数字，请再次尝试输入！&quot;</span>)</span><br></pre></td></tr></table></figure><p>try 语句按照如下方式工作；</p><ul><li>首先，执行 try 子句（在关键字 try 和关键字 except 之间的语句）。</li><li>如果没有异常发生，忽略 except 子句，try 子句执行后结束。</li><li>如果在执行 try 子句的过程中发生了异常，那么 try 子句余下的部分将被忽略。如果异常的类型和 except 之后的名称相符，那么对应的 except 子句将被执行。</li><li>如果一个异常没有与任何的 except 匹配，那么这个异常将会传递给上层的 try 中。</li></ul><p>一个 try 语句可能包含多个except子句，分别来处理不同的特定的异常。最多只有一个分支会被执行。</p><p>处理程序将只针对对应的 try 子句中的异常进行处理，而不是其他的 try 的处理程序中的异常。</p><p>一个except子句可以同时处理多个异常，这些异常将被放在一个括号里成为一个元组，例如:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">except</span> (RuntimeError, TypeError, NameError):</span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>最后一个except子句可以忽略异常的名称，它将被当作通配符使用。你可以使用这种方法打印一个错误信息，然后再次把异常抛出。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    f = <span class="built_in">open</span>(<span class="string">&#x27;myfile.txt&#x27;</span>)</span><br><span class="line">    s = f.readline()</span><br><span class="line">    i = <span class="built_in">int</span>(s.strip())</span><br><span class="line"><span class="keyword">except</span> OSError <span class="keyword">as</span> err:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;OS error: &#123;0&#125;&quot;</span>.<span class="built_in">format</span>(err))</span><br><span class="line"><span class="keyword">except</span> ValueError:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Could not convert data to an integer.&quot;</span>)</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Unexpected error:&quot;</span>, sys.exc_info()[<span class="number">0</span>])</span><br><span class="line">    <span class="keyword">raise</span></span><br></pre></td></tr></table></figure></li><li><p>try/except…else</p><p><strong>try/except</strong> 语句还有一个可选的 <strong>else</strong> 子句，如果使用这个子句，那么必须放在所有的 except 子句之后。</p><p>else 子句将在 try 子句没有发生任何异常的时候执行。</p><p><img src="https://github.com/hxlpub/imgs/blob/master/try_except_else.png?raw=true" alt="try/except...else"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> arg <span class="keyword">in</span> sys.argv[<span class="number">1</span>:]:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        f = <span class="built_in">open</span>(arg, <span class="string">&#x27;r&#x27;</span>)</span><br><span class="line">    <span class="keyword">except</span> IOError:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;cannot open&#x27;</span>, arg)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(arg, <span class="string">&#x27;has&#x27;</span>, <span class="built_in">len</span>(f.readlines()), <span class="string">&#x27;lines&#x27;</span>)</span><br><span class="line">        f.close()</span><br></pre></td></tr></table></figure><p>使用 else 子句比把所有的语句都放在 try 子句里面要好，这样可以避免一些意想不到，而 except 又无法捕获的异常。</p><p>异常处理并不仅仅处理那些直接发生在 try 子句中的异常，而且还能处理子句中调用的函数（甚至间接调用的函数）里抛出的异常。例如:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">this_fails</span>():</span></span><br><span class="line">        x = <span class="number">1</span>/<span class="number">0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">try</span>:</span><br><span class="line">        this_fails()</span><br><span class="line">    <span class="keyword">except</span> ZeroDivisionError <span class="keyword">as</span> err:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Handling run-time error:&#x27;</span>, err)</span><br><span class="line">   </span><br><span class="line">Handling run-time error: <span class="built_in">int</span> division <span class="keyword">or</span> modulo by zero</span><br></pre></td></tr></table></figure></li><li><p>try-finally</p><p>try-finally 语句无论是否发生异常都将执行最后的代码。</p><p><img src="https://github.com/hxlpub/imgs/blob/master/try_except_else_finally.png?raw=true" alt="try_except_else_finally"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    runoob()</span><br><span class="line"><span class="keyword">except</span> AssertionError <span class="keyword">as</span> error:</span><br><span class="line">    <span class="built_in">print</span>(error)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;file.log&#x27;</span>) <span class="keyword">as</span> file:</span><br><span class="line">            read_data = file.read()</span><br><span class="line">    <span class="keyword">except</span> FileNotFoundError <span class="keyword">as</span> fnf_error:</span><br><span class="line">        <span class="built_in">print</span>(fnf_error)</span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;这句话，无论异常是否发生都会执行。&#x27;</span>)</span><br></pre></td></tr></table></figure></li></ul><p>​    </p></li><li><p>抛出异常</p><p>Python 使用 raise 语句抛出一个指定的异常。</p><p>raise语法格式如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">raise</span> [Exception [, args [, traceback]]]</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="number">10</span></span><br><span class="line"><span class="keyword">if</span> x &gt; <span class="number">5</span>:</span><br><span class="line">    <span class="keyword">raise</span> Exception(<span class="string">&#x27;x 不能大于 5。x 的值为: &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(x))</span><br><span class="line"></span><br><span class="line">执行以上代码会触发异常：</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;test.py&quot;</span>, line <span class="number">3</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    <span class="keyword">raise</span> Exception(<span class="string">&#x27;x 不能大于 5。x 的值为: &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(x))</span><br><span class="line">Exception: x 不能大于 <span class="number">5</span>。x 的值为: <span class="number">10</span></span><br></pre></td></tr></table></figure><p>raise 唯一的一个参数指定了要被抛出的异常。它必须是一个异常的实例或者是异常的类（也就是 Exception 的子类）。</p><p>如果你只想知道这是否抛出了一个异常，并不想去处理它，那么一个简单的 raise 语句就可以再次把它抛出。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">raise</span> NameError(<span class="string">&#x27;HiThere&#x27;</span>)</span><br><span class="line">    <span class="keyword">except</span> NameError:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;An exception flew by!&#x27;</span>)</span><br><span class="line">        <span class="keyword">raise</span></span><br><span class="line">   </span><br><span class="line">An exception flew by!</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">2</span>, <span class="keyword">in</span> ?</span><br><span class="line">NameError: HiThere</span><br><span class="line">  理解：</span><br></pre></td></tr></table></figure></li><li><p>用户自定义异常</p><p>创建一个新的异常类来拥有自己的异常。异常类继承自 Exception 类，可以直接继承，或者间接继承，例如:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">MyError</span>(<span class="params">Exception</span>):</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, value</span>):</span></span><br><span class="line">            self.value = value</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">__str__</span>(<span class="params">self</span>):</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">repr</span>(self.value)</span><br><span class="line">   </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">raise</span> MyError(<span class="number">2</span>*<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">except</span> MyError <span class="keyword">as</span> e:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;My exception occurred, value:&#x27;</span>, e.value)</span><br><span class="line">   </span><br><span class="line">My exception occurred, value: <span class="number">4</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">raise</span> MyError(<span class="string">&#x27;oops!&#x27;</span>)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> ?</span><br><span class="line">__main__.MyError: <span class="string">&#x27;oops!&#x27;</span></span><br></pre></td></tr></table></figure><p>当创建一个模块有可能抛出多种不同的异常时，一种通常的做法是为这个包建立一个基础异常类，然后基于这个基础类为不同的错误情况创建不同的子类:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Error</span>(<span class="params">Exception</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;Base class for exceptions in this module.&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InputError</span>(<span class="params">Error</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;Exception raised for errors in the input.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Attributes:</span></span><br><span class="line"><span class="string">        expression -- input expression in which the error occurred</span></span><br><span class="line"><span class="string">        message -- explanation of the error</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, expression, message</span>):</span></span><br><span class="line">        self.expression = expression</span><br><span class="line">        self.message = message</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TransitionError</span>(<span class="params">Error</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;Raised when an operation attempts a state transition that&#x27;s not</span></span><br><span class="line"><span class="string">    allowed.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Attributes:</span></span><br><span class="line"><span class="string">        previous -- state at beginning of transition</span></span><br><span class="line"><span class="string">        next -- attempted new state</span></span><br><span class="line"><span class="string">        message -- explanation of why the specific transition is not allowed</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, previous, <span class="built_in">next</span>, message</span>):</span></span><br><span class="line">        self.previous = previous</span><br><span class="line">        self.<span class="built_in">next</span> = <span class="built_in">next</span></span><br><span class="line">        self.message = message</span><br></pre></td></tr></table></figure></li><li><p>定义清理行为</p><p>try 语句还有另外一个可选的子句，它定义了无论在任何情况下都会执行的清理行为。 例如:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">try</span>:</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">raise</span> KeyboardInterrupt</span><br><span class="line"><span class="meta">... </span><span class="keyword">finally</span>:</span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span>(<span class="string">&#x27;Goodbye, world!&#x27;</span>)</span><br><span class="line">...</span><br><span class="line">Goodbye, world!</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">2</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">KeyboardInterrupt</span><br></pre></td></tr></table></figure><p>以上例子不管 try 子句里面有没有发生异常，finally 子句都会执行。</p><p>如果一个异常在 try 子句里（或者在 except 和 else 子句里）被抛出，而又没有任何的 except 把它截住，那么这个异常会在 finally 子句执行后被抛出。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">divide</span>(<span class="params">x, y</span>):</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            result = x / y</span><br><span class="line">        <span class="keyword">except</span> ZeroDivisionError:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;division by zero!&quot;</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;result is&quot;</span>, result)</span><br><span class="line">        <span class="keyword">finally</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;executing finally clause&quot;</span>)</span><br><span class="line">   </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>divide(<span class="number">2</span>, <span class="number">1</span>)</span><br><span class="line">result <span class="keyword">is</span> <span class="number">2.0</span></span><br><span class="line">executing <span class="keyword">finally</span> clause</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>divide(<span class="number">2</span>, <span class="number">0</span>)</span><br><span class="line">division by zero!</span><br><span class="line">executing <span class="keyword">finally</span> clause</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>divide(<span class="string">&quot;2&quot;</span>, <span class="string">&quot;1&quot;</span>)</span><br><span class="line">executing <span class="keyword">finally</span> clause</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> ?</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">3</span>, <span class="keyword">in</span> divide</span><br><span class="line">TypeError: unsupported operand <span class="built_in">type</span>(s) <span class="keyword">for</span> /: <span class="string">&#x27;str&#x27;</span> <span class="keyword">and</span> <span class="string">&#x27;str&#x27;</span></span><br></pre></td></tr></table></figure></li><li><p>预定义的清理行为</p><p>一些对象定义了标准的清理行为，无论系统是否成功的使用了它，一旦不需要它了，那么这个标准的清理行为就会执行。</p><p>这面这个例子展示了尝试打开一个文件，然后把内容打印到屏幕上:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> <span class="built_in">open</span>(<span class="string">&quot;myfile.txt&quot;</span>):</span><br><span class="line">    <span class="built_in">print</span>(line, end=<span class="string">&quot;&quot;</span>)</span><br></pre></td></tr></table></figure><p>以上这段代码的问题是，当执行完毕后，文件会保持打开状态，并没有被关闭。</p><p>关键词 with 语句就可以保证诸如文件之类的对象在使用完之后一定会正确的执行他的清理方法:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;myfile.txt&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> f:</span><br><span class="line">        <span class="built_in">print</span>(line, end=<span class="string">&quot;&quot;</span>)</span><br></pre></td></tr></table></figure><p>以上这段代码执行完毕后，就算在处理过程中出问题了，文件 f 总是会关闭。</p></li></ul></li><li><h5 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h5><ul><li><strong>类(Class):</strong> 用来描述具有相同的属性和方法的对象的集合。它定义了该集合中每个对象所共有的属性和方法。对象是类的实例。</li><li><strong>方法：</strong>类中定义的函数。</li><li><strong>类变量：</strong>类变量在整个实例化的对象中是公用的。类变量定义在类中且在函数体之外。类变量通常不作为实例变量使用。</li><li><strong>数据成员：</strong>类变量或者实例变量用于处理类及其实例对象的相关的数据。</li><li><strong>方法重写：</strong>如果从父类继承的方法不能满足子类的需求，可以对其进行改写，这个过程叫方法的覆盖（override），也称为方法的重写。</li><li><strong>局部变量：</strong>定义在方法中的变量，只作用于当前实例的类。</li><li><strong>实例变量：</strong>在类的声明中，属性是用变量来表示的，这种变量就称为实例变量，实例变量就是一个用 self 修饰的变量。</li><li><strong>继承：</strong>即一个派生类（derived class）继承基类（base class）的字段和方法。继承也允许把一个派生类的对象作为一个基类对象对待。例如，有这样一个设计：一个Dog类型的对象派生自Animal类，这是模拟”是一个（is-a）”关系（例图，Dog是一个Animal）。</li><li><strong>实例化：</strong>创建一个类的实例，类的具体对象。</li><li><strong>对象：</strong>通过类定义的数据结构实例。对象包括两个数据成员（类变量和实例变量）和方法。</li></ul><p>和其它编程语言相比，Python 在尽可能不增加新的语法和语义的情况下加入了类机制。</p><p>Python中的类提供了面向对象编程的所有基本功能：类的继承机制允许多个基类，派生类可以覆盖基类中的任何方法，方法中可以调用基类中的同名方法。</p><p>对象可以包含任意数量和类型的数据。</p><ul><li><p>类定义</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassName</span>:</span></span><br><span class="line">    &lt;statement-<span class="number">1</span>&gt;</span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line">    &lt;statement-N&gt;</span><br></pre></td></tr></table></figure><p>类实例化后，可以使用其属性，实际上，创建一个类之后，可以通过类名访问其属性。</p></li><li><p>类对象</p><p>类对象支持两种操作：属性引用和实例化。</p><p>属性引用使用和 Python 中所有的属性引用一样的标准语法：<strong>obj.name</strong>。</p><p>类对象创建后，类命名空间中所有的命名都是有效属性名。所以如果类定义是这样:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span>:</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;一个简单的类实例&quot;&quot;&quot;</span></span><br><span class="line">    i = <span class="number">12345</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">f</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;hello world&#x27;</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 实例化类</span></span><br><span class="line">x = MyClass()</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 访问类的属性和方法</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;MyClass 类的属性 i 为：&quot;</span>, x.i)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;MyClass 类的方法 f 输出为：&quot;</span>, x.f())</span><br></pre></td></tr></table></figure><p>类有一个名为 <strong>init</strong>() 的特殊方法（<strong>构造方法</strong>），该方法在类实例化时会自动调用，像下面这样：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">    self.data = []</span><br></pre></td></tr></table></figure><p>self是类的一个实例，而非类</p><p>类的方法与普通的函数只有一个特别的区别——它们必须有一个额外的<strong>第一个参数名称</strong>, 按照惯例它的名称是 self。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">prt</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(self)</span><br><span class="line">        <span class="built_in">print</span>(self.__class__)</span><br><span class="line"> </span><br><span class="line">t = Test()</span><br><span class="line">t.prt()</span><br><span class="line">以上实例执行结果为：</span><br><span class="line"></span><br><span class="line">&lt;__main__.Test instance at <span class="number">0x100771878</span>&gt;</span><br><span class="line">__main__.Test</span><br></pre></td></tr></table></figure><p>从执行结果可以很明显的看出，self 代表的是类的实例，代表当前对象的地址，而 self.class 则指向类。</p><p>self 不是 python 关键字，我们把他换成 runoob 也是可以正常执行的:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class Test:    </span><br><span class="line">def prt(runoob):        </span><br><span class="line">print(runoob)        </span><br><span class="line">print(runoob.__class__)  </span><br><span class="line">t = Test() </span><br><span class="line">t.prt()</span><br></pre></td></tr></table></figure><p>以上实例执行结果为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;__main__.Test instance at <span class="number">0x100771878</span>&gt;</span><br><span class="line">__main__.Test</span><br></pre></td></tr></table></figure></li><li><p>类方法</p><p>在类的内部，使用 <strong>def</strong> 关键字来定义一个方法，与一般函数定义不同，类方法必须包含参数 self, 且为第一个参数，self 代表的是类的实例。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#类定义</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">people</span>:</span></span><br><span class="line">    <span class="comment">#定义基本属性</span></span><br><span class="line">    name = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    age = <span class="number">0</span></span><br><span class="line">    <span class="comment">#定义私有属性,私有属性在类外部无法直接进行访问</span></span><br><span class="line">    __weight = <span class="number">0</span></span><br><span class="line">    <span class="comment">#定义构造方法</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,n,a,w</span>):</span></span><br><span class="line">        self.name = n</span><br><span class="line">        self.age = a</span><br><span class="line">        self.__weight = w</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">speak</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;%s 说: 我 %d 岁。&quot;</span> %(self.name,self.age))</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 实例化类</span></span><br><span class="line">p = people(<span class="string">&#x27;runoob&#x27;</span>,<span class="number">10</span>,<span class="number">30</span>)</span><br><span class="line">p.speak()</span><br><span class="line">执行以上程序输出结果为：</span><br><span class="line"></span><br><span class="line">runoob 说: 我 <span class="number">10</span> 岁。</span><br></pre></td></tr></table></figure></li><li><p>继承</p><p>Python 同样支持类的继承，如果一种语言不支持继承，类就没有什么意义。派生类的定义如下所示:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DerivedClassName</span>(<span class="params">BaseClassName</span>):</span></span><br><span class="line">    &lt;statement-<span class="number">1</span>&gt;</span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line">    &lt;statement-N&gt;</span><br></pre></td></tr></table></figure><p>子类（派生类 DerivedClassName）会继承父类（基类 BaseClassName）的属性和方法。</p><p>BaseClassName（实例中的基类名）必须与派生类定义在一个作用域内。除了类，还可以用表达式，基类定义在另一个模块中时这一点非常有用:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DerivedClassName</span>(<span class="params">modname.BaseClassName</span>):</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">#类定义</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">people</span>:</span></span><br><span class="line">    <span class="comment">#定义基本属性</span></span><br><span class="line">    name = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    age = <span class="number">0</span></span><br><span class="line">    <span class="comment">#定义私有属性,私有属性在类外部无法直接进行访问</span></span><br><span class="line">    __weight = <span class="number">0</span></span><br><span class="line">    <span class="comment">#定义构造方法</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,n,a,w</span>):</span></span><br><span class="line">        self.name = n</span><br><span class="line">        self.age = a</span><br><span class="line">        self.__weight = w</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">speak</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;%s 说: 我 %d 岁。&quot;</span> %(self.name,self.age))</span><br><span class="line"> </span><br><span class="line"><span class="comment">#单继承示例</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">student</span>(<span class="params">people</span>):</span></span><br><span class="line">    grade = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,n,a,w,g</span>):</span></span><br><span class="line">        <span class="comment">#调用父类的构函</span></span><br><span class="line">        people.__init__(self,n,a,w)</span><br><span class="line">        self.grade = g</span><br><span class="line">    <span class="comment">#覆写父类的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">speak</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;%s 说: 我 %d 岁了，我在读 %d 年级&quot;</span>%(self.name,self.age,self.grade))</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">s = student(<span class="string">&#x27;ken&#x27;</span>,<span class="number">10</span>,<span class="number">60</span>,<span class="number">3</span>)</span><br><span class="line">s.speak()</span><br><span class="line">执行以上程序输出结果为：</span><br><span class="line"></span><br><span class="line">ken 说: 我 <span class="number">10</span> 岁了，我在读 <span class="number">3</span> 年级</span><br></pre></td></tr></table></figure></li><li><p>多继承</p><p>Python同样有限的支持多继承形式。多继承的类定义形如下例:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DerivedClassName</span>(<span class="params">Base1, Base2, Base3</span>):</span></span><br><span class="line">    &lt;statement-<span class="number">1</span>&gt;</span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line">    &lt;statement-N&gt;</span><br></pre></td></tr></table></figure><p>需要注意圆括号中父类的顺序，若是父类中有相同的方法名，而在子类使用时未指定，python从左至右搜索 即方法在子类中未找到时，从左到右查找父类中是否包含方法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#类定义</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">people</span>:</span></span><br><span class="line">    <span class="comment">#定义基本属性</span></span><br><span class="line">    name = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    age = <span class="number">0</span></span><br><span class="line">    <span class="comment">#定义私有属性,私有属性在类外部无法直接进行访问</span></span><br><span class="line">    __weight = <span class="number">0</span></span><br><span class="line">    <span class="comment">#定义构造方法</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,n,a,w</span>):</span></span><br><span class="line">        self.name = n</span><br><span class="line">        self.age = a</span><br><span class="line">        self.__weight = w</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">speak</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;%s 说: 我 %d 岁。&quot;</span> %(self.name,self.age))</span><br><span class="line"> </span><br><span class="line"><span class="comment">#单继承示例</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">student</span>(<span class="params">people</span>):</span></span><br><span class="line">    grade = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,n,a,w,g</span>):</span></span><br><span class="line">        <span class="comment">#调用父类的构函</span></span><br><span class="line">        people.__init__(self,n,a,w)</span><br><span class="line">        self.grade = g</span><br><span class="line">    <span class="comment">#覆写父类的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">speak</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;%s 说: 我 %d 岁了，我在读 %d 年级&quot;</span>%(self.name,self.age,self.grade))</span><br><span class="line"> </span><br><span class="line"><span class="comment">#另一个类，多重继承之前的准备</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">speaker</span>():</span></span><br><span class="line">    topic = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    name = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,n,t</span>):</span></span><br><span class="line">        self.name = n</span><br><span class="line">        self.topic = t</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">speak</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;我叫 %s，我是一个演说家，我演讲的主题是 %s&quot;</span>%(self.name,self.topic))</span><br><span class="line"> </span><br><span class="line"><span class="comment">#多重继承</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">sample</span>(<span class="params">speaker,student</span>):</span></span><br><span class="line">    a =<span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,n,a,w,g,t</span>):</span></span><br><span class="line">        student.__init__(self,n,a,w,g)</span><br><span class="line">        speaker.__init__(self,n,t)</span><br><span class="line"> </span><br><span class="line">test = sample(<span class="string">&quot;Tim&quot;</span>,<span class="number">25</span>,<span class="number">80</span>,<span class="number">4</span>,<span class="string">&quot;Python&quot;</span>)</span><br><span class="line">test.speak()   <span class="comment">#方法名同，默认调用的是在括号中参数位置排前父类的方法</span></span><br><span class="line">执行以上程序输出结果为：</span><br><span class="line"></span><br><span class="line">我叫 Tim，我是一个演说家，我演讲的主题是 Python</span><br></pre></td></tr></table></figure></li><li><p>方法重写</p><p>如果你的父类方法的功能不能满足你的需求，你可以在子类重写你父类的方法，实例如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span>:</span>        <span class="comment"># 定义父类</span></span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">myMethod</span>(<span class="params">self</span>):</span></span><br><span class="line">      <span class="built_in">print</span> (<span class="string">&#x27;调用父类方法&#x27;</span>)</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span>(<span class="params">Parent</span>):</span> <span class="comment"># 定义子类</span></span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">myMethod</span>(<span class="params">self</span>):</span></span><br><span class="line">      <span class="built_in">print</span> (<span class="string">&#x27;调用子类方法&#x27;</span>)</span><br><span class="line"> </span><br><span class="line">c = Child()          <span class="comment"># 子类实例</span></span><br><span class="line">c.myMethod()         <span class="comment"># 子类调用重写方法</span></span><br><span class="line"><span class="built_in">super</span>(Child,c).myMethod() <span class="comment">#用子类对象调用父类已被覆盖的方法</span></span><br><span class="line">执行以上程序输出结果为：</span><br><span class="line">调用子类方法</span><br><span class="line">调用父类方法</span><br></pre></td></tr></table></figure></li><li><p>类属性与方法</p><ul><li><p>私有属性</p><p><strong>__private_attrs</strong>：两个下划线开头，声明该属性为私有，不能在类的外部被使用或直接访问。在类内部的方法中使用时 <strong>self.__private_attrs</strong>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">JustCounter</span>:</span></span><br><span class="line">    __secretCount = <span class="number">0</span>  <span class="comment"># 私有变量</span></span><br><span class="line">    publicCount = <span class="number">0</span>    <span class="comment"># 公开变量</span></span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">count</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.__secretCount += <span class="number">1</span></span><br><span class="line">        self.publicCount += <span class="number">1</span></span><br><span class="line">        <span class="built_in">print</span> (self.__secretCount)</span><br><span class="line"> </span><br><span class="line">counter = JustCounter()</span><br><span class="line">counter.count()</span><br><span class="line">counter.count()</span><br><span class="line"><span class="built_in">print</span> (counter.publicCount)</span><br><span class="line"><span class="built_in">print</span> (counter.__secretCount)  <span class="comment"># 报错，实例不能访问私有变量</span></span><br><span class="line">执行以上程序输出结果为：</span><br><span class="line"></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;test.py&quot;</span>, line <span class="number">16</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    <span class="built_in">print</span> (counter.__secretCount)  <span class="comment"># 报错，实例不能访问私有变量</span></span><br><span class="line">AttributeError: <span class="string">&#x27;JustCounter&#x27;</span> <span class="built_in">object</span> has no attribute <span class="string">&#x27;__secretCount&#x27;</span></span><br></pre></td></tr></table></figure></li><li><p>类的方法</p><p>在类的内部，使用 def 关键字来定义一个方法，与一般函数定义不同，类方法必须包含参数 <strong>self</strong>，且为第一个参数，<strong>self</strong> 代表的是类的实例。</p><p><strong>self</strong> 的名字并不是规定死的，也可以使用 <strong>this</strong>，但是最好还是按照约定使用 <strong>self</strong>。</p></li><li><p>私有方法</p><p><strong>__private_method</strong>：两个下划线开头，声明该方法为私有方法，只能在类的内部调用 ，不能在类的外部调用。<strong>self.__private_methods</strong>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Site</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name, url</span>):</span></span><br><span class="line">        self.name = name       <span class="comment"># public</span></span><br><span class="line">        self.__url = url   <span class="comment"># private</span></span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">who</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;name  : &#x27;</span>, self.name)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;url : &#x27;</span>, self.__url)</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__foo</span>(<span class="params">self</span>):</span>          <span class="comment"># 私有方法</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;这是私有方法&#x27;</span>)</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">foo</span>(<span class="params">self</span>):</span>            <span class="comment"># 公共方法</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;这是公共方法&#x27;</span>)</span><br><span class="line">        self.__foo()</span><br><span class="line"> </span><br><span class="line">x = Site(<span class="string">&#x27;菜鸟教程&#x27;</span>, <span class="string">&#x27;www.runoob.com&#x27;</span>)</span><br><span class="line">x.who()        <span class="comment"># 正常输出</span></span><br><span class="line">x.foo()        <span class="comment"># 正常输出</span></span><br><span class="line">x.__foo()      <span class="comment"># 报错</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>专有方法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">__init__ : 构造函数，在生成对象时调用</span><br><span class="line">__del__ : 析构函数，释放对象时使用</span><br><span class="line">__repr__ : 打印，转换</span><br><span class="line">__setitem__ : 按照索引赋值</span><br><span class="line">__getitem__: 按照索引获取值</span><br><span class="line">__len__: 获得长度</span><br><span class="line">__cmp__: 比较运算</span><br><span class="line">__call__: 函数调用</span><br><span class="line">__add__: 加运算</span><br><span class="line">__sub__: 减运算</span><br><span class="line">__mul__: 乘运算</span><br><span class="line">__truediv__: 除运算</span><br><span class="line">__mod__: 求余运算</span><br><span class="line">__pow__: 乘方</span><br></pre></td></tr></table></figure></li><li><p>运算符重载</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vector</span>:</span></span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, a, b</span>):</span></span><br><span class="line">      self.a = a</span><br><span class="line">      self.b = b</span><br><span class="line"> </span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">__str__</span>(<span class="params">self</span>):</span></span><br><span class="line">      <span class="keyword">return</span> <span class="string">&#x27;Vector (%d, %d)&#x27;</span> % (self.a, self.b)</span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">__add__</span>(<span class="params">self,other</span>):</span></span><br><span class="line">      <span class="keyword">return</span> Vector(self.a + other.a, self.b + other.b)</span><br><span class="line"> </span><br><span class="line">v1 = Vector(<span class="number">2</span>,<span class="number">10</span>)</span><br><span class="line">v2 = Vector(<span class="number">5</span>,-<span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span> (v1 + v2)</span><br><span class="line">以上代码执行结果如下所示:</span><br><span class="line"></span><br><span class="line">Vector(<span class="number">7</span>,<span class="number">8</span>)</span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li><h5 id="命名空间-作用域"><a href="#命名空间-作用域" class="headerlink" title="命名空间/作用域"></a>命名空间/作用域</h5><p>命名空间(Namespace)是从名称到对象的映射，大部分的命名空间都是通过 Python 字典来实现的。</p><p>命名空间提供了在项目中避免名字冲突的一种方法。各个命名空间是独立的，没有任何关系的，所以一个命名空间中不能有重名，但不同的命名空间是可以重名而没有任何影响。</p><p>一般有三种命名空间：</p><ul><li><strong>内置名称（built-in names</strong>）， Python 语言内置的名称，比如函数名 abs、char 和异常名称 BaseException、Exception 等等。</li><li><strong>全局名称（global names）</strong>，模块中定义的名称，记录了模块的变量，包括函数、类、其它导入的模块、模块级的变量和常量。</li><li><strong>局部名称（local names）</strong>，函数中定义的名称，记录了函数的变量，包括函数的参数和局部定义的变量。（类中定义的也是）</li></ul><p><img src="https://github.com/hxlpub/imgs/blob/master/types_namespace-1.png?raw=true" alt="types_namespace-1"></p><ul><li>命名空间查找顺序:</li></ul><p>假设我们要使用变量 runoob，则 Python 的查找顺序为：<strong>局部的命名空间去 -&gt; 全局命名空间 -&gt; 内置命名空间</strong>。</p><p>如果找不到变量 runoob，它将放弃查找并引发一个 NameError 异常:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NameError: name <span class="string">&#x27;runoob&#x27;</span> <span class="keyword">is</span> <span class="keyword">not</span> defined。</span><br></pre></td></tr></table></figure><ul><li>命名空间的生命周期：</li></ul><p>命名空间的生命周期取决于对象的作用域，如果对象执行完成，则该命名空间的生命周期就结束。</p><p>因此，我们无法从外部命名空间访问内部命名空间的对象。</p><ul><li><p>作用域</p><p>作用域就是一个 Python 程序可以直接访问命名空间的正文区域。</p><p>在一个 python 程序中，直接访问一个变量，会从内到外依次访问所有的作用域直到找到，否则会报未定义的错误。</p><p>Python 中，程序的变量并不是在哪个位置都可以访问的，访问权限决定于这个变量是在哪里赋值的。</p><p>变量的作用域决定了在哪一部分程序可以访问哪个特定的变量名称。Python 的作用域一共有4种，分别是：</p><p>有四种作用域：</p><ul><li><strong>L（Local）</strong>：最内层，包含局部变量，比如一个函数/方法内部。</li><li><strong>E（Enclosing）</strong>：包含了非局部(non-local)也非全局(non-global)的变量。比如两个嵌套函数，一个函数（或类） A 里面又包含了一个函数 B ，那么对于 B 中的名称来说 A 中的作用域就为 nonlocal。</li><li><strong>G（Global）</strong>：当前脚本的最外层，比如当前模块的全局变量。</li><li><strong>B（Built-in）</strong>： 包含了内建的变量/关键字等，最后被搜索。</li></ul><p>规则顺序： <strong>L –&gt; E –&gt; G –&gt; B</strong>。</p><p>在局部找不到，便会去局部外的局部找（例如闭包），再找不到就会去全局找，再者去内置中找。</p><p><img src="https://github.com/hxlpub/imgs/blob/master/1418490-20180906153626089-1835444372.png?raw=true"></p></li><li><p>全局和局部变量</p><p>定义在函数内部的变量拥有一个局部作用域，定义在函数外的拥有全局作用域。</p><p>局部变量只能在其被声明的函数内部访问，而全局变量可以在整个程序范围内访问。调用函数时，所有在函数内声明的变量名称都将被加入到作用域中。</p></li><li><p>global 和nolocal 关键字</p><p>当内部作用域想修改外部作用域的变量时，就要用到 global 和 nonlocal 关键字了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">num = <span class="number">1</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fun1</span>():</span></span><br><span class="line">    <span class="keyword">global</span> num  <span class="comment"># 需要使用 global 关键字声明</span></span><br><span class="line">    <span class="built_in">print</span>(num) </span><br><span class="line">    num = <span class="number">123</span></span><br><span class="line">    <span class="built_in">print</span>(num)</span><br><span class="line">fun1()</span><br><span class="line"><span class="built_in">print</span>(num)</span><br><span class="line">以上实例输出结果：</span><br><span class="line"></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">123</span></span><br><span class="line"><span class="number">123</span></span><br></pre></td></tr></table></figure><p>如果要修改嵌套作用域（enclosing 作用域，外层非全局作用域）中的变量则需要 nonlocal 关键字了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">outer</span>():</span></span><br><span class="line">    num = <span class="number">10</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inner</span>():</span></span><br><span class="line">        <span class="keyword">nonlocal</span> num   <span class="comment"># nonlocal关键字声明</span></span><br><span class="line">        num = <span class="number">100</span></span><br><span class="line">        <span class="built_in">print</span>(num)</span><br><span class="line">    inner()</span><br><span class="line">    <span class="built_in">print</span>(num)</span><br><span class="line">outer()</span><br><span class="line"></span><br><span class="line">以上实例输出结果：</span><br><span class="line"><span class="number">100</span></span><br><span class="line"><span class="number">100</span></span><br></pre></td></tr></table></figure></li></ul></li><li><h5 id="标准库"><a href="#标准库" class="headerlink" title="标准库"></a>标准库</h5></li></ol><hr><p>二、高级</p><ol><li><p>正则表达式</p><p>正则表达式是一个特殊的字符序列，它能帮助你方便的检查一个字符串是否与某种模式匹配。</p><p>Python 自1.5版本起增加了re 模块，它提供 Perl 风格的正则表达式模式。</p><p>re 模块使 Python 语言拥有全部的正则表达式功能。</p><p>compile 函数根据一个模式字符串和可选的标志参数生成一个正则表达式对象。该对象拥有一系列方法用于正则表达式匹配和替换。</p><p>re 模块也提供了与这些方法功能完全一致的函数，这些函数使用一个模式字符串做为它们的第一个参数。</p><p><strong>匹配字符串</strong></p><ul><li><p><strong>re.match() 函数</strong></p><p>re.match 尝试从字符串的起始位置匹配一个模式，匹配成功re.match方法返回一个匹配的对象，否则返回None。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">re.match(pattern, string, flags=0)</span><br></pre></td></tr></table></figure><table><thead><tr><th align="left">参数</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">pattern</td><td align="left">匹配的正则表达式</td></tr><tr><td align="left">string</td><td align="left">要匹配的字符串。</td></tr><tr><td align="left">flags</td><td align="left">标志位，用于控制正则表达式的匹配方式，如：是否区分大小写，多行匹配等等。参见：<a href="https://www.runoob.com/python3/python3-reg-expressions.html#flags">正则表达式修饰符 - 可选标志</a></td></tr></tbody></table></li><li><p>re.search()</p><p>re.search 扫描整个字符串并返回第一个成功的匹配。匹配成功re.search方法返回一个匹配的对象，否则返回None。</p><p>re.match 只匹配字符串的开始，如果字符串开始不符合正则表达式，则匹配失败，函数返回 None，而 re.search 匹配整个字符串，直到找到一个匹配。</p></li></ul><p><strong>检索替换</strong></p><ul><li><p>re.sub()</p><p>Python 的re模块提供了re.sub用于替换字符串中的匹配项。</p><p>语法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">re.sub(pattern, repl, string, count=0, flags=0)</span><br></pre></td></tr></table></figure><ul><li>pattern : 正则中的模式字符串。</li><li>repl : 替换的字符串，也可为一个函数。</li><li>string : 要被查找替换的原始字符串。</li><li>count : 模式匹配后替换的最大次数，默认 0 表示替换所有的匹配。</li><li>flags : 编译时用的匹配模式，数字形式。</li></ul></li><li></li><li></li><li></li><li></li></ul></li><li><p>CGI编程</p></li><li><p>MySql(mysql-connector)</p></li><li><p>MySql(pymysql)</p></li><li><p>网络编程</p><p>Python 提供了两个级别访问的网络服务。：</p><ul><li>低级别的网络服务支持基本的 Socket，它提供了标准的 BSD Sockets API，可以访问底层操作系统Socket接口的全部方法。</li><li>高级别的网络服务模块 SocketServer， 它提供了服务器中心类，可以简化网络服务器的开发。</li></ul><ul><li><p>什么是socket?</p><p>Socket又称”套接字”，应用程序通常通过”套接字”向网络发出请求或者应答网络请求，使主机间或者一台计算机上的进程间可以通讯。</p></li><li><p>socket()函数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">我们用 socket() 函数来创建套接字，语法格式如下：</span><br><span class="line"></span><br><span class="line">socket.socket([family[, <span class="built_in">type</span>[, proto]]])</span><br></pre></td></tr></table></figure><ul><li>family: 套接字家族可以是 AF_UNIX 或者 AF_INET</li><li>type: 套接字类型可以根据是面向连接的还是非连接分为<code>SOCK_STREAM</code>或<code>SOCK_DGRAM</code></li><li>protocol: 一般不填默认为0.</li></ul><table><thead><tr><th align="left">函数</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">服务器端套接字</td><td align="left"></td></tr><tr><td align="left">s.bind()</td><td align="left">绑定地址（host,port）到套接字， 在AF_INET下,以元组（host,port）的形式表示地址。</td></tr><tr><td align="left">s.listen()</td><td align="left">开始TCP监听。backlog指定在拒绝连接之前，操作系统可以挂起的最大连接数量。该值至少为1，大部分应用程序设为5就可以了。</td></tr><tr><td align="left">s.accept()</td><td align="left">被动接受TCP客户端连接,(阻塞式)等待连接的到来</td></tr><tr><td align="left">客户端套接字</td><td align="left"></td></tr><tr><td align="left">s.connect()</td><td align="left">主动初始化TCP服务器连接，。一般address的格式为元组（hostname,port），如果连接出错，返回socket.error错误。</td></tr><tr><td align="left">s.connect_ex()</td><td align="left">connect()函数的扩展版本,出错时返回出错码,而不是抛出异常</td></tr><tr><td align="left">公共用途的套接字函数</td><td align="left"></td></tr><tr><td align="left">s.recv()</td><td align="left">接收TCP数据，数据以字符串形式返回，bufsize指定要接收的最大数据量。flag提供有关消息的其他信息，通常可以忽略。</td></tr><tr><td align="left">s.send()</td><td align="left">发送TCP数据，将string中的数据发送到连接的套接字。返回值是要发送的字节数量，该数量可能小于string的字节大小。</td></tr><tr><td align="left">s.sendall()</td><td align="left">完整发送TCP数据，完整发送TCP数据。将string中的数据发送到连接的套接字，但在返回之前会尝试发送所有数据。成功返回None，失败则抛出异常。</td></tr><tr><td align="left">s.recvfrom()</td><td align="left">接收UDP数据，与recv()类似，但返回值是（data,address）。其中data是包含接收数据的字符串，address是发送数据的套接字地址。</td></tr><tr><td align="left">s.sendto()</td><td align="left">发送UDP数据，将数据发送到套接字，address是形式为（ipaddr，port）的元组，指定远程地址。返回值是发送的字节数。</td></tr><tr><td align="left">s.close()</td><td align="left">关闭套接字</td></tr><tr><td align="left">s.getpeername()</td><td align="left">返回连接套接字的远程地址。返回值通常是元组（ipaddr,port）。</td></tr><tr><td align="left">s.getsockname()</td><td align="left">返回套接字自己的地址。通常是一个元组(ipaddr,port)</td></tr><tr><td align="left">s.setsockopt(level,optname,value)</td><td align="left">设置给定套接字选项的值。</td></tr><tr><td align="left">s.getsockopt(level,optname[.buflen])</td><td align="left">返回套接字选项的值。</td></tr><tr><td align="left">s.settimeout(timeout)</td><td align="left">设置套接字操作的超时期，timeout是一个浮点数，单位是秒。值为None表示没有超时期。一般，超时期应该在刚创建套接字时设置，因为它们可能用于连接的操作（如connect()）</td></tr><tr><td align="left">s.gettimeout()</td><td align="left">返回当前超时期的值，单位是秒，如果没有设置超时期，则返回None。</td></tr><tr><td align="left">s.fileno()</td><td align="left">返回套接字的文件描述符。</td></tr><tr><td align="left">s.setblocking(flag)</td><td align="left">如果 flag 为 False，则将套接字设为非阻塞模式，否则将套接字设为阻塞模式（默认值）。非阻塞模式下，如果调用 recv() 没有发现任何数据，或 send() 调用无法立即发送数据，那么将引起 socket.error 异常。</td></tr><tr><td align="left">s.makefile()</td><td align="left">创建一个与该套接字相关连的文件</td></tr></tbody></table><p>实例</p><ul><li>服务端</li></ul><p>我们使用 socket 模块的 <strong>socket</strong> 函数来创建一个 socket 对象。socket 对象可以通过调用其他函数来设置一个 socket 服务。</p><p>现在我们可以通过调用 <strong>bind(hostname, port)</strong> 函数来指定服务的 *port(端口)*。</p><p>接着，我们调用 socket 对象的 <em>accept</em> 方法。该方法等待客户端的连接，并返回 <em>connection</em> 对象，表示已连接到客户端</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"><span class="comment"># 文件名：server.py</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 导入 socket、sys 模块</span></span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建 socket 对象</span></span><br><span class="line">serversocket = socket.socket(</span><br><span class="line">            socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取本地主机名</span></span><br><span class="line">host = socket.gethostname()</span><br><span class="line"></span><br><span class="line">port = <span class="number">9999</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 绑定端口号</span></span><br><span class="line">serversocket.bind((host, port))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置最大连接数，超过后排队</span></span><br><span class="line">serversocket.listen(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="comment"># 建立客户端连接</span></span><br><span class="line">    clientsocket,addr = serversocket.accept()      </span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;连接地址: %s&quot;</span> % <span class="built_in">str</span>(addr))</span><br><span class="line">   </span><br><span class="line">    msg=<span class="string">&#x27;欢迎访问菜鸟教程！&#x27;</span>+ <span class="string">&quot;\r\n&quot;</span></span><br><span class="line">    clientsocket.send(msg.encode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line">    clientsocket.close()</span><br></pre></td></tr></table></figure><ul><li><p>客户端</p><p>接下来我们写一个简单的客户端实例连接到以上创建的服务。端口号为 9999。</p><p><strong>socket.connect(hostname, port )</strong> 方法打开一个 TCP 连接到主机为 <em>hostname</em> 端口为 <em>port</em> 的服务商。连接后我们就可以从服务端获取数据，记住，操作完成后需要关闭连接。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"><span class="comment"># 文件名：client.py</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 导入 socket、sys 模块</span></span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建 socket 对象</span></span><br><span class="line">s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取本地主机名</span></span><br><span class="line">host = socket.gethostname()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置端口号</span></span><br><span class="line">port = <span class="number">9999</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 连接服务，指定主机和端口</span></span><br><span class="line">s.connect((host, port))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 接收小于 1024 字节的数据</span></span><br><span class="line">msg = s.recv(<span class="number">1024</span>)</span><br><span class="line"></span><br><span class="line">s.close()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> (msg.decode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br></pre></td></tr></table></figure><p>现在我们打开两个终端，第一个终端执行 server.py 文件：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ python3 server.py</span><br></pre></td></tr></table></figure><p>第二个终端执行 client.py 文件：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ python3 client.py </span><br><span class="line">欢迎访问菜鸟教程！</span><br></pre></td></tr></table></figure><p>这时我们再打开第一个终端，就会看到有以下信息输出：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">连接地址： (<span class="string">&#x27;192.168.0.118&#x27;</span>, <span class="number">33397</span>)</span><br></pre></td></tr></table></figure></li></ul></li><li><p>python Internet模块</p><p>以下列出了 Python 网络编程的一些重要模块：</p><table><thead><tr><th align="left">协议</th><th align="left">功能用处</th><th align="left">端口号</th><th align="left">Python 模块</th></tr></thead><tbody><tr><td align="left">HTTP</td><td align="left">网页访问</td><td align="left">80</td><td align="left">httplib, urllib, xmlrpclib</td></tr><tr><td align="left">NNTP</td><td align="left">阅读和张贴新闻文章，俗称为”帖子”</td><td align="left">119</td><td align="left">nntplib</td></tr><tr><td align="left">FTP</td><td align="left">文件传输</td><td align="left">20</td><td align="left">ftplib, urllib</td></tr><tr><td align="left">SMTP</td><td align="left">发送邮件</td><td align="left">25</td><td align="left">smtplib</td></tr><tr><td align="left">POP3</td><td align="left">接收邮件</td><td align="left">110</td><td align="left">poplib</td></tr><tr><td align="left">IMAP4</td><td align="left">获取邮件</td><td align="left">143</td><td align="left">imaplib</td></tr><tr><td align="left">Telnet</td><td align="left">命令行</td><td align="left">23</td><td align="left">telnetlib</td></tr><tr><td align="left">Gopher</td><td align="left">信息查找</td><td align="left">70</td><td align="left">gopherlib, urllib</td></tr></tbody></table></li></ul></li><li><p>SMTP发送发送邮件</p></li><li><p>多线程</p><p>多线程类似于同时执行多个不同程序，多线程运行有如下优点：</p><ul><li>使用线程可以把占据长时间的程序中的任务放到后台去处理。</li><li>用户界面可以更加吸引人，比如用户点击了一个按钮去触发某些事件的处理，可以弹出一个进度条来显示处理的进度。</li><li>程序的运行速度可能加快。</li><li>在一些等待的任务实现上如用户输入、文件读写和网络收发数据等，线程就比较有用了。在这种情况下我们可以释放一些珍贵的资源如内存占用等等。</li></ul><p>每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口。但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。</p><p>每个线程都有他自己的一组CPU寄存器，称为线程的上下文，该上下文反映了线程上次运行该线程的CPU寄存器的状态。</p><p>指令指针和堆栈指针寄存器是线程上下文中两个最重要的寄存器，线程总是在进程得到上下文中运行的，这些地址都用于标志拥有线程的进程地址空间中的内存。</p><ul><li>线程可以被抢占（中断）。</li><li>在其他线程正在运行时，线程可以暂时搁置（也称为睡眠） – 这就是线程的退让。</li></ul><p>线程可以分为:</p><ul><li><strong>内核线程：</strong>由操作系统内核创建和撤销。</li><li><strong>用户线程：</strong>不需要内核支持而在用户程序中实现的线程。</li></ul><p>Python3 线程中常用的两个模块为：</p><ul><li><strong>_thread</strong></li><li><strong>threading(推荐使用)</strong></li></ul><p>thread 模块已被废弃。用户可以使用 threading 模块代替。所以，在 Python3 中不能再使用”thread” 模块。为了兼容性，Python3 将 thread 重命名为 “_thread”。</p><p>Python中使用线程有两种方式：函数或者用类来包装线程对象。</p><p>函数式：调用 _thread 模块中的start_new_thread()函数来产生新线程。语法如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_thread.start_new_thread ( function, args[, kwargs] )</span><br></pre></td></tr></table></figure><p>参数说明:</p><ul><li>function - 线程函数。</li><li>args - 传递给线程函数的参数,他必须是个tuple类型。</li><li>kwargs - 可选参数。</li></ul><p>实例</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> _thread</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="comment"># 为线程定义一个函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_time</span>(<span class="params"> threadName, delay</span>):</span></span><br><span class="line">   count = <span class="number">0</span></span><br><span class="line">   <span class="keyword">while</span> count &lt; <span class="number">5</span>:</span><br><span class="line">      time.sleep(delay)</span><br><span class="line">      count += <span class="number">1</span></span><br><span class="line">      <span class="built_in">print</span> (<span class="string">&quot;%s: %s&quot;</span> % ( threadName, time.ctime(time.time()) ))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建两个线程</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">   _thread.start_new_thread( print_time, (<span class="string">&quot;Thread-1&quot;</span>, <span class="number">2</span>, ) )</span><br><span class="line">   _thread.start_new_thread( print_time, (<span class="string">&quot;Thread-2&quot;</span>, <span class="number">4</span>, ) )</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">   <span class="built_in">print</span> (<span class="string">&quot;Error: 无法启动线程&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">   <span class="keyword">pass</span></span><br><span class="line">执行以上程序输出结果如下：</span><br><span class="line"></span><br><span class="line">Thread-<span class="number">1</span>: Wed Jan  <span class="number">5</span> <span class="number">17</span>:<span class="number">38</span>:08 <span class="number">2022</span></span><br><span class="line">Thread-<span class="number">2</span>: Wed Jan  <span class="number">5</span> <span class="number">17</span>:<span class="number">38</span>:<span class="number">10</span> <span class="number">2022</span></span><br><span class="line">Thread-<span class="number">1</span>: Wed Jan  <span class="number">5</span> <span class="number">17</span>:<span class="number">38</span>:<span class="number">10</span> <span class="number">2022</span></span><br><span class="line">Thread-<span class="number">1</span>: Wed Jan  <span class="number">5</span> <span class="number">17</span>:<span class="number">38</span>:<span class="number">12</span> <span class="number">2022</span></span><br><span class="line">Thread-<span class="number">2</span>: Wed Jan  <span class="number">5</span> <span class="number">17</span>:<span class="number">38</span>:<span class="number">14</span> <span class="number">2022</span></span><br><span class="line">Thread-<span class="number">1</span>: Wed Jan  <span class="number">5</span> <span class="number">17</span>:<span class="number">38</span>:<span class="number">14</span> <span class="number">2022</span></span><br><span class="line">Thread-<span class="number">1</span>: Wed Jan  <span class="number">5</span> <span class="number">17</span>:<span class="number">38</span>:<span class="number">16</span> <span class="number">2022</span></span><br><span class="line">Thread-<span class="number">2</span>: Wed Jan  <span class="number">5</span> <span class="number">17</span>:<span class="number">38</span>:<span class="number">18</span> <span class="number">2022</span></span><br><span class="line">Thread-<span class="number">2</span>: Wed Jan  <span class="number">5</span> <span class="number">17</span>:<span class="number">38</span>:<span class="number">22</span> <span class="number">2022</span></span><br><span class="line">Thread-<span class="number">2</span>: Wed Jan  <span class="number">5</span> <span class="number">17</span>:<span class="number">38</span>:<span class="number">26</span> <span class="number">2022</span></span><br><span class="line">执行以上程后可以按下 ctrl-c 退出。</span><br></pre></td></tr></table></figure><ul><li><p>线程模块</p><p>Python3 通过两个标准库 _thread 和 threading 提供对线程的支持。</p><p>_thread 提供了低级别的、原始的线程以及一个简单的锁，它相比于 threading 模块的功能还是比较有限的。</p><p>threading 模块除了包含 _thread 模块中的所有方法外，还提供的其他方法：</p><ul><li>threading.currentThread(): 返回当前的线程变量。</li><li>threading.enumerate(): 返回一个包含正在运行的线程的list。正在运行指线程启动后、结束前，不包括启动前和终止后的线程。</li><li>threading.activeCount(): 返回正在运行的线程数量，与len(threading.enumerate())有相同的结果。</li></ul><p>除了使用方法外，线程模块同样提供了Thread类来处理线程，Thread类提供了以下方法:</p><ul><li><p><strong>run():</strong> 用以表示线程活动的方法。</p></li><li><p>start():</p><p>启动线程活动。</p></li><li><p><strong>join([time]):</strong> 等待至线程中止。这阻塞调用线程直至线程的join() 方法被调用中止-正常退出或者抛出未处理的异常-或者是可选的超时发生。</p></li><li><p><strong>isAlive():</strong> 返回线程是否活动的。</p></li><li><p><strong>getName():</strong> 返回线程名。</p></li><li><p><strong>setName():</strong> 设置线程名。</p></li></ul></li><li><p>使用threading 模块创建线程</p><p>直接从 threading.Thread 继承创建一个新的子类，并实例化后调用 start() 方法启动新线程，即它调用了线程的 run() 方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">exitFlag = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myThread</span> (<span class="params">threading.Thread</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, threadID, name, delay</span>):</span></span><br><span class="line">        threading.Thread.__init__(self)</span><br><span class="line">        self.threadID = threadID</span><br><span class="line">        self.name = name</span><br><span class="line">        self.delay = delay</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">print</span> (<span class="string">&quot;开始线程：&quot;</span> + self.name)</span><br><span class="line">        print_time(self.name, self.delay, <span class="number">5</span>)</span><br><span class="line">        <span class="built_in">print</span> (<span class="string">&quot;退出线程：&quot;</span> + self.name)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_time</span>(<span class="params">threadName, delay, counter</span>):</span></span><br><span class="line">    <span class="keyword">while</span> counter:</span><br><span class="line">        <span class="keyword">if</span> exitFlag:</span><br><span class="line">            threadName.exit()</span><br><span class="line">        time.sleep(delay)</span><br><span class="line">        <span class="built_in">print</span> (<span class="string">&quot;%s: %s&quot;</span> % (threadName, time.ctime(time.time())))</span><br><span class="line">        counter -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建新线程</span></span><br><span class="line">thread1 = myThread(<span class="number">1</span>, <span class="string">&quot;Thread-1&quot;</span>, <span class="number">1</span>)</span><br><span class="line">thread2 = myThread(<span class="number">2</span>, <span class="string">&quot;Thread-2&quot;</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 开启新线程</span></span><br><span class="line">thread1.start()</span><br><span class="line">thread2.start()</span><br><span class="line">thread1.join()</span><br><span class="line">thread2.join()</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;退出主线程&quot;</span>)</span><br><span class="line">以上程序执行结果如下；</span><br><span class="line"></span><br><span class="line">开始线程：Thread-<span class="number">1</span></span><br><span class="line">开始线程：Thread-<span class="number">2</span></span><br><span class="line">Thread-<span class="number">1</span>: Wed Jan  <span class="number">5</span> <span class="number">17</span>:<span class="number">34</span>:<span class="number">54</span> <span class="number">2022</span></span><br><span class="line">Thread-<span class="number">2</span>: Wed Jan  <span class="number">5</span> <span class="number">17</span>:<span class="number">34</span>:<span class="number">55</span> <span class="number">2022</span></span><br><span class="line">Thread-<span class="number">1</span>: Wed Jan  <span class="number">5</span> <span class="number">17</span>:<span class="number">34</span>:<span class="number">55</span> <span class="number">2022</span></span><br><span class="line">Thread-<span class="number">1</span>: Wed Jan  <span class="number">5</span> <span class="number">17</span>:<span class="number">34</span>:<span class="number">56</span> <span class="number">2022</span></span><br><span class="line">Thread-<span class="number">2</span>: Wed Jan  <span class="number">5</span> <span class="number">17</span>:<span class="number">34</span>:<span class="number">57</span> <span class="number">2022</span></span><br><span class="line">Thread-<span class="number">1</span>: Wed Jan  <span class="number">5</span> <span class="number">17</span>:<span class="number">34</span>:<span class="number">57</span> <span class="number">2022</span></span><br><span class="line">Thread-<span class="number">1</span>: Wed Jan  <span class="number">5</span> <span class="number">17</span>:<span class="number">34</span>:<span class="number">58</span> <span class="number">2022</span></span><br><span class="line">退出线程：Thread-<span class="number">1</span></span><br><span class="line">Thread-<span class="number">2</span>: Wed Jan  <span class="number">5</span> <span class="number">17</span>:<span class="number">34</span>:<span class="number">59</span> <span class="number">2022</span></span><br><span class="line">Thread-<span class="number">2</span>: Wed Jan  <span class="number">5</span> <span class="number">17</span>:<span class="number">35</span>:01 <span class="number">2022</span></span><br><span class="line">Thread-<span class="number">2</span>: Wed Jan  <span class="number">5</span> <span class="number">17</span>:<span class="number">35</span>:03 <span class="number">2022</span></span><br><span class="line">退出线程：Thread-<span class="number">2</span></span><br><span class="line">退出主线程</span><br></pre></td></tr></table></figure></li><li><p>线程同步</p><p>如果多个线程共同对某个数据修改，则可能出现不可预料的结果，为了保证数据的正确性，需要对多个线程进行同步。</p><p>使用 Thread 对象的 Lock 和 Rlock 可以实现简单的线程同步，这两个对象都有 acquire 方法和 release 方法，对于那些需要每次只允许一个线程操作的数据，可以将其操作放到 acquire 和 release 方法之间。如下：</p><p>多线程的优势在于可以同时运行多个任务（至少感觉起来是这样）。但是当线程需要共享数据时，可能存在数据不同步的问题。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myThread</span> (<span class="params">threading.Thread</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, threadID, name, delay</span>):</span></span><br><span class="line">        threading.Thread.__init__(self)</span><br><span class="line">        self.threadID = threadID</span><br><span class="line">        self.name = name</span><br><span class="line">        self.delay = delay</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">print</span> (<span class="string">&quot;开启线程： &quot;</span> + self.name)</span><br><span class="line">        <span class="comment"># 获取锁，用于线程同步</span></span><br><span class="line">        threadLock.acquire()</span><br><span class="line">        print_time(self.name, self.delay, <span class="number">3</span>)</span><br><span class="line">        <span class="comment"># 释放锁，开启下一个线程</span></span><br><span class="line">        threadLock.release()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_time</span>(<span class="params">threadName, delay, counter</span>):</span></span><br><span class="line">    <span class="keyword">while</span> counter:</span><br><span class="line">        time.sleep(delay)</span><br><span class="line">        <span class="built_in">print</span> (<span class="string">&quot;%s: %s&quot;</span> % (threadName, time.ctime(time.time())))</span><br><span class="line">        counter -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">threadLock = threading.Lock()</span><br><span class="line">threads = []</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建新线程</span></span><br><span class="line">thread1 = myThread(<span class="number">1</span>, <span class="string">&quot;Thread-1&quot;</span>, <span class="number">1</span>)</span><br><span class="line">thread2 = myThread(<span class="number">2</span>, <span class="string">&quot;Thread-2&quot;</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 开启新线程</span></span><br><span class="line">thread1.start()</span><br><span class="line">thread2.start()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加线程到线程列表</span></span><br><span class="line">threads.append(thread1)</span><br><span class="line">threads.append(thread2)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 等待所有线程完成</span></span><br><span class="line"><span class="keyword">for</span> t <span class="keyword">in</span> threads:</span><br><span class="line">    t.join()</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;退出主线程&quot;</span>)</span><br><span class="line">执行以上程序，输出结果为：</span><br><span class="line"></span><br><span class="line">开启线程： Thread-<span class="number">1</span></span><br><span class="line">开启线程： Thread-<span class="number">2</span></span><br><span class="line">Thread-<span class="number">1</span>: Wed Jan  <span class="number">5</span> <span class="number">17</span>:<span class="number">36</span>:<span class="number">50</span> <span class="number">2022</span></span><br><span class="line">Thread-<span class="number">1</span>: Wed Jan  <span class="number">5</span> <span class="number">17</span>:<span class="number">36</span>:<span class="number">51</span> <span class="number">2022</span></span><br><span class="line">Thread-<span class="number">1</span>: Wed Jan  <span class="number">5</span> <span class="number">17</span>:<span class="number">36</span>:<span class="number">52</span> <span class="number">2022</span></span><br><span class="line">Thread-<span class="number">2</span>: Wed Jan  <span class="number">5</span> <span class="number">17</span>:<span class="number">36</span>:<span class="number">54</span> <span class="number">2022</span></span><br><span class="line">Thread-<span class="number">2</span>: Wed Jan  <span class="number">5</span> <span class="number">17</span>:<span class="number">36</span>:<span class="number">56</span> <span class="number">2022</span></span><br><span class="line">Thread-<span class="number">2</span>: Wed Jan  <span class="number">5</span> <span class="number">17</span>:<span class="number">36</span>:<span class="number">58</span> <span class="number">2022</span></span><br><span class="line">退出主线程W</span><br></pre></td></tr></table></figure></li><li><p>线程优先级队列（Queue）</p></li></ul></li><li><p>XML解析</p></li><li><p>JSON</p></li><li><p>日期时间</p></li><li><p>内置函数</p></li><li><p>MongoDB</p></li><li><p>urllib</p></li><li><p>uWSGI 安装配置</p></li><li><p>pip</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;ol&gt;
&lt;li&gt;&lt;h5 id=&quot;环境配置&quot;&gt;&lt;a href=&quot;#环境配置&quot; class=&quot;headerlink&quot; title=&quot;环境配置&quot;&gt;&lt;/a&gt;环境配置&lt;/h5&gt;&lt;p&gt;import 时找不到模块，修改python sys.path  &lt;/p&gt;
&lt;blockquote&gt;
&lt;b</summary>
      
    
    
    
    <category term="编程语言" scheme="https://hxlpub.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
    <category term="python" scheme="https://hxlpub.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>【分布式对象存储】从0搭建框架：单机</title>
    <link href="https://hxlpub.github.io/2022/12/03/build-distributed-objstor-system-frame-from-zero/"/>
    <id>https://hxlpub.github.io/2022/12/03/build-distributed-objstor-system-frame-from-zero/</id>
    <published>2022-12-03T04:10:07.000Z</published>
    <updated>2023-05-28T10:18:10.736Z</updated>
    
    <content type="html"><![CDATA[<h5 id="1-什么是对象存储？"><a href="#1-什么是对象存储？" class="headerlink" title="1.什么是对象存储？"></a>1.什么是对象存储？</h5><p>对象存储也称为基于对象的存储，是一种计算机数据存储架构，旨在处理大量非结构化数据。与其他架构不同，它将数据指定为不同的单元，并捆绑元数据和唯一标识符，用于查找和访问每个数据单元。</p><p>这些单元（或对象）可以存储在本地，但通常存储在云端，以便于从任何地方轻松访问数据。由于对象存储具有横向扩容能力，它的可伸缩性几乎没有限制，并且存储大量数据的成本也低于块存储等其他存储方法。</p><p>如今的许多数据都是非结构化的，无法很好地存储在传统数据库中，包括电子邮件、媒体和音频文件、网页、传感器数据和其他类型的数字内容。因此，寻找高效且经济实惠的方法来存储和管理这类数据成为了一个难点。越来越多的企业将对象存储作为存储静态内容、数据架构和备份的首选方法。</p><ul><li><p>对象存储定义</p><p>对象存储是用于存储非结构化数据的数据存储架构，它将数据划分为单元（对象），并存储在结构扁平的数据环境中。每个对象都包含数据以及应用可用于轻松访问和检索对象的元数据和唯一标识符。</p></li><li><p>工作原理</p><p>在对象存储中，一个文件的数据块被共同保存为一个对象，并连同其相关的元数据和自定义标识符放入被称为存储池的扁平数据环境中。</p><p>当您需要访问数据时，对象存储系统将使用唯一标识符和元数据来查找所需的对象，例如图片或音频文件。您还可以自定义元数据，从而添加可用于其他用途（例如用于数据分析的检索）的上下文。 </p><p>您可以使用 RESTful API、HTTP 和 HTTPS 查询对象元数据，以查找和访问对象。由于对象存储在全局存储池中，因此您可以快速轻松地找到所需的确切数据。此外，扁平环境使您能够快速扩容，即便是 PB 或 EB 级负载也毫不费力。存储池可以分布在多个对象存储设备和地理位置中，因此规模不受限制。随着数据量的增长，您只需向池中添加更多存储设备即可。</p><p>对象存储的优势（例如弹性和可伸缩性）使其成为管理云基础架构中非结构化数据的理想选择。那么，什么是云对象存储呢？顾名思义，也就是作为按需云服务提供的基于对象的存储。事实上，对于大多数大型云服务提供商而言，云对象存储是主要的存储格式。</p></li></ul><h5 id="2-传统的网络存储"><a href="#2-传统的网络存储" class="headerlink" title="2.传统的网络存储"></a>2.传统的网络存储</h5><p>网络存储（Network Storage）是<a href="https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/9827490?fromModule=lemma_inlink">数据存储</a>的一种方式，网络存储结构大致分为三种：直连式存储（<a href="https://baike.baidu.com/item/DAS/2183059?fromModule=lemma_inlink">DAS</a>：Direct Attached Storage）、网络附加存储（<a href="https://baike.baidu.com/item/NAS/3465615?fromModule=lemma_inlink">NAS</a>：Network Attached Storage）和存储区域网（<a href="https://baike.baidu.com/item/SAN/10251732?fromModule=lemma_inlink">SAN</a>：Storage Area Network）。由于NAS对于普通消费者而言较为熟悉，所以一般网络存储都指NAS。</p><p>网络存储被定义为一种特殊的专用<a href="https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8?fromModule=lemma_inlink">数据存储</a>服务器，包括存储器件（例如<a href="https://baike.baidu.com/item/%E7%A3%81%E7%9B%98%E9%98%B5%E5%88%97?fromModule=lemma_inlink">磁盘阵列</a>、CD/DVD驱动器、磁带驱动器或可移动的存储介质）和内嵌系统软件，可提供跨平台文件共享功能。网络存储通常在一个LAN上占有自己的节点，无需应用服务器的干预，允许用户在网络上存取数据，在这种配置中，网络存储集中管理和处理网络上的所有数据，将负载从应用或企业服务器上<a href="https://baike.baidu.com/item/%E5%8D%B8%E8%BD%BD?fromModule=lemma_inlink">卸载</a>下来，有效降低总拥有成本，保护用户投资。</p><p>NAS（Network Attached Storage-网络附着存储），是一个<strong>可提供存储功能和文件系统</strong>的网络服务器，<strong>客户端可访问NAS上的文件系统，还可上传下载文件</strong>，客户端和服务端之间使用的协议有SMB、NFS以及AFS等<strong>网络文件系统协议</strong>。即将存储设备通过标准的<a href="https://baike.baidu.com/item/%E7%BD%91%E7%BB%9C%E6%8B%93%E6%89%91%E7%BB%93%E6%9E%84?fromModule=lemma_inlink">网络拓扑结构</a>（例如以太网）连接到一群计算机上。NAS是部件级的存储方法，它的重点在于帮助解决迅速增加存储容量的需求。</p><p>SAN(Storage Area Network<a href="https://baike.baidu.com/item/%E5%AD%98%E5%82%A8%E5%8C%BA%E5%9F%9F%E7%BD%91%E7%BB%9C?fromModule=lemma_inlink">存储区域网络</a>)通过<a href="https://baike.baidu.com/item/%E5%85%89%E7%BA%A4%E9%80%9A%E9%81%93?fromModule=lemma_inlink">光纤通道</a>连接到一群计算机上。在该网络中提供了多台<a href="https://baike.baidu.com/item/%E4%B8%BB%E6%9C%BA?fromModule=lemma_inlink">主机</a>连接，但并非通过标准的网络拓扑。<strong>只提供块存储，而把文件系统的抽象交给客户端来管理</strong>。<strong>对客户端来说，SAN就是一块磁盘，可以对其格式化、创建文件系统并挂载。</strong>客户端和服务端使用的协议有Fibre Channel、iSCSI、ATA over Ethernet(AoE) 和HyperSCSI。</p><p>现在的网络存储通常将SAN和NAS混合使用，同时提供文件级别和协议和块级别的协议。</p><h5 id="3-对象存储与传统网络存储区别"><a href="#3-对象存储与传统网络存储区别" class="headerlink" title="3.对象存储与传统网络存储区别"></a>3.对象存储与传统网络存储区别</h5><ul><li>文件存储</li></ul><p>文件存储将数据存储和整理到文件夹中，类似于您保存在办公室的纸质文件系统中的物理文件。如果您需要某个文件中的信息，则需要知道哪个房间、文件柜、抽屉和文件夹包含该特定文件。文件存储使用相同的分层存储结构，文件被命名，以元数据标记，然后放入文件夹中。</p><p>要找到某个数据，您需要知道查找该数据的正确路径。随着时间的推移，文件变得越来越多，搜索和检索数据文件可能会变得非常耗时。虽然可伸缩性较为有限，但通过这种方法可以很容易地存储几乎任何类型的少量数据，并且可供多个用户同时访问。</p><ul><li>块存储</li></ul><p>块存储在文件存储的基础上提升了性能，它将文件拆分为多个单独的块并单独存储。块存储系统会为每个原始数据块分配一个唯一标识符，当您需要访问完整的文件时，系统将使用唯一标识符将数据块重组为完整的文件。块存储不需要单一的数据路径，因此您可以将其存储在最方便的位置，并且在需要时仍然能够快速检索。</p><p>块存储非常适合需要处理大量事务型数据或使用任务关键型应用的组织，可提供低延迟和一致的性能。但是，块存储费用高昂，不提供元数据功能，并且需要操作系统才能访问块。</p><ul><li>对象存储</li></ul><p>如前所述，对象存储将文件存储为扁平数据环境（即存储池）中的独立对象，对象包含全部数据、唯一标识符和详细元数据（元数据包含关于数据、权限、政策和其他应急情况的信息）。对象存储最适合非结构化数据的静态存储，您只写入一次数据，但可能需要多次读取。</p><p>虽然对象存储不需要目录、文件夹和其他复杂的分层结构，但却不适合用来存储不断变化的动态数据，因为修改对象需要重写整个对象。根据您的速度和性能要求，在某些情况下文件存储和块存储可能仍然适合您的需求。</p><ul><li>访问数据方式</li></ul><p>网络文件系统的客户端通过NFS等网络协议访问某个远程服务器上存储的文件；</p><p>块存储的客户端通过数据块的地址访问SAN上的数据块。</p><p>对象存储则通过REST网络服务访问对象。</p><h5 id="4-对象存储的优势"><a href="#4-对象存储的优势" class="headerlink" title="4.对象存储的优势"></a>4.对象存储的优势</h5><ul><li>可伸缩性强</li></ul><p>您可以轻松横向扩容对象存储的扁平架构，而不会受到文件存储或块存储那样的限制。对象存储基本没有大小限制，因此只需添加新设备，即可将数据扩大到 EB 级。</p><ul><li>复杂性低</li></ul><p>对象存储没有文件夹或目录，也就不具有层次结构系统的大多数复杂性。由于没有复杂的树或分区，检索文件变得十分轻松，因为您不需要知道确切位置。 </p><ul><li>易于搜索</li></ul><p>元数据是对象的一部分，使您无需借助单独的应用即可轻松搜索和导航。它也更加灵活，并且可以深度自定义。您可以使用各种特性和信息来为对象添加标记，例如用量、费用以及自动删除、保留和分层的政策。</p><ul><li>具有弹性</li></ul><p>对象存储可以自动复制数据并存储在多个设备和多个地理位置。这有助于防范服务中断和数据丢失，并可为灾难恢复策略提供支持。</p><ul><li>成本效益高</li></ul><p>对象存储在设计时考虑了成本因素，与基于文件和块的系统相比，能够以更低的价格存储大量数据。使用对象存储时，您只为需要的容量付费，即使存储大量数据，也能很好地控制费用。</p><h5 id="5-单机版对象存储架构"><a href="#5-单机版对象存储架构" class="headerlink" title="5.单机版对象存储架构"></a>5.单机版对象存储架构</h5><h5 id="6-单机版对象存储接口"><a href="#6-单机版对象存储接口" class="headerlink" title="6.单机版对象存储接口"></a>6.单机版对象存储接口</h5><h5 id="7-代码实现过程"><a href="#7-代码实现过程" class="headerlink" title="7.代码实现过程"></a>7.代码实现过程</h5><h5 id="8-效果展示"><a href="#8-效果展示" class="headerlink" title="8.效果展示"></a>8.效果展示</h5>]]></content>
    
    
      
      
    <summary type="html">&lt;h5 id=&quot;1-什么是对象存储？&quot;&gt;&lt;a href=&quot;#1-什么是对象存储？&quot; class=&quot;headerlink&quot; title=&quot;1.什么是对象存储？&quot;&gt;&lt;/a&gt;1.什么是对象存储？&lt;/h5&gt;&lt;p&gt;对象存储也称为基于对象的存储，是一种计算机数据存储架构，旨在处理大量非结构化</summary>
      
    
    
    
    <category term="分布式存储" scheme="https://hxlpub.github.io/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8/"/>
    
    
    <category term="分布式对象存储" scheme="https://hxlpub.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AF%B9%E8%B1%A1%E5%AD%98%E5%82%A8/"/>
    
  </entry>
  
  <entry>
    <title>【c】c pointer</title>
    <link href="https://hxlpub.github.io/2022/06/25/c-pointer/"/>
    <id>https://hxlpub.github.io/2022/06/25/c-pointer/</id>
    <published>2022-06-25T12:57:55.000Z</published>
    <updated>2023-05-28T11:12:05.071Z</updated>
    
    <content type="html"><![CDATA[<h5 id="double-pointer"><a href="#double-pointer" class="headerlink" title="double pointer"></a>double pointer</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">change_ptr</span><span class="params">(<span class="keyword">int</span>** ptr)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">//int local =3;</span></span><br><span class="line">  <span class="keyword">int</span> *p =<span class="literal">NULL</span>;</span><br><span class="line">  <span class="comment">//*p = local;</span></span><br><span class="line">  <span class="comment">//printf(&quot;old *p =%d&quot;,p);</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;old p =%p\n&quot;</span>,p);</span><br><span class="line">  <span class="comment">//printf(&quot;old  =%p&quot;,p);</span></span><br><span class="line">  change_ptr(&amp;p);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;*p=%d\n&quot;</span>,*p);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;new p =%p\n&quot;</span>,p);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">change_ptr</span> <span class="params">(<span class="keyword">int</span> **ptr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> *tmp = <span class="literal">NULL</span>;</span><br><span class="line">  tmp = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">  *tmp = <span class="number">4</span> ;</span><br><span class="line">  *ptr = tmp ;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Makefile:</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">make:</span></span><br><span class="line">gcc -g  hello_rpms.c -o hello_rpms</span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">rm hello_rpms</span><br><span class="line"><span class="section">install:</span></span><br><span class="line">mkdir -p $&#123;DESTDIR&#125;/usr/bin</span><br><span class="line">install -m 0755 hello_rpms $&#123;DESTDIR&#125;/usr/bin/hello_rpms</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h5 id=&quot;double-pointer&quot;&gt;&lt;a href=&quot;#double-pointer&quot; class=&quot;headerlink&quot; title=&quot;double pointer&quot;&gt;&lt;/a&gt;double pointer&lt;/h5&gt;&lt;figure class=&quot;highlight </summary>
      
    
    
    
    <category term="编程语言" scheme="https://hxlpub.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
    <category term="c" scheme="https://hxlpub.github.io/tags/c/"/>
    
  </entry>
  
  <entry>
    <title>【Linux】How to be a rpms maker</title>
    <link href="https://hxlpub.github.io/2022/06/25/linux-to-be-rpms-maker/"/>
    <id>https://hxlpub.github.io/2022/06/25/linux-to-be-rpms-maker/</id>
    <published>2022-06-25T07:32:23.000Z</published>
    <updated>2023-05-28T11:26:10.844Z</updated>
    
    <content type="html"><![CDATA[<p>Reference:</p><p><a href="https://bbs.huaweicloud.com/forum/thread-38327-1-1.html">https://bbs.huaweicloud.com/forum/thread-38327-1-1.html</a></p><h5 id="Prerequisites"><a href="#Prerequisites" class="headerlink" title="Prerequisites"></a>Prerequisites</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">On Fedora, CentOS 8, and RHEL 8:</span><br><span class="line"><span class="meta">$</span><span class="bash"> dnf install gcc rpm-build rpm-devel rpmlint make python bash coreutils diffutils</span></span><br><span class="line">patch rpmdevtools</span><br><span class="line">On CentOS 7 and RHEL 7:</span><br><span class="line"><span class="meta">$</span><span class="bash"> yum install gcc rpm-build rpm-devel rpmlint make python bash coreutils diffutils</span></span><br><span class="line">patch rpmdevtools</span><br><span class="line">3</span><br></pre></td></tr></table></figure><h5 id="My-First-RPM-Package"><a href="#My-First-RPM-Package" class="headerlink" title="My First  RPM Package"></a>My First  RPM Package</h5><p>1.spec file with several things skipped and simplified:(put a bash script in /usr/bin)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">Name:   hello-world</span><br><span class="line">Version:        1</span><br><span class="line">Release:        1</span><br><span class="line">Summary:        Most simple RPM package</span><br><span class="line">License:        FIXME</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">%</span><span class="bash">description</span></span><br><span class="line">this is my first RPM package ,which does nothing.</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">%</span><span class="bash">prep</span></span><br><span class="line"><span class="meta">#</span><span class="bash">we have no <span class="built_in">source</span> ,so nothing here.</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">%</span><span class="bash">build</span></span><br><span class="line">cat &gt; hello-world.sh &lt;&lt; EOF</span><br><span class="line"><span class="meta">#</span><span class="bash">!/usr/bin/bash</span> </span><br><span class="line">echo hello world</span><br><span class="line">EOF</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">%</span><span class="bash">install</span></span><br><span class="line">mkdir -p %&#123;buildroot&#125;/usr/bin</span><br><span class="line">install -m 755 hello-world.sh %&#123;buildroot&#125;/usr/bin/hello-world.sh</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">%</span><span class="bash">files</span></span><br><span class="line">/usr/bin/hello-world.sh</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">%</span><span class="bash">changelog</span></span><br><span class="line">* Sat Jun 25 2022 root</span><br></pre></td></tr></table></figure><p>2.rpmbuild </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpmbuild -ba rpmbuild/SPECS/hello_world.spec</span><br></pre></td></tr></table></figure><p>3.install her</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -ivh rpmbuild/RPMS/x86_64/hello-world-1-1.x86_64.rpm</span><br></pre></td></tr></table></figure><p>4.validate her</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@hik ~]# ll /usr/bin/hello-world.sh </span><br><span class="line">-rwxr-xr-x. 1 root root 35 Jun 25 19:56 /usr/bin/hello-world.sh</span><br><span class="line">[root@hik ~]#  /usr/bin/hello-world.sh </span><br><span class="line">hello world</span><br></pre></td></tr></table></figure><h5 id="Preparing-Software-For-Packaging"><a href="#Preparing-Software-For-Packaging" class="headerlink" title="Preparing Software For Packaging"></a>Preparing Software For Packaging</h5><ol><li><p>Source codes including Makefile</p></li><li><p>Patch Software</p></li><li><p>Installing arbitrary Artifacts</p><p>In the context of this guide, an Arbitrary Artifact is anything installed from an RPM to the system.</p><p>For RPM and for the system it can be a script, a binary compiled from the package’s source code, a<br>pre-compiled binary, or any other file.</p><p>We will explore two popular ways of placing Arbitrary Artifacts in the system: using the install<br>command and using the make install command.</p><ul><li><p>Using the install command</p><p>Sometimes using build automation tooling such as GNU make is not optimal - for example, if the<br>packaged program is simple and does not need extra overhead. In these cases, packagers often use<br>the install command (provided to the system by coreutils), which places the artifact to the<br>specified directory in the filesystem with a specified set of permissions.</p><p>eg.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo install -m 0755 bello /usr/bin/bello</span></span><br></pre></td></tr></table></figure></li><li><p>Using the make install command</p><p>A popular automated way to install built software to the system is to use the make install<br>command. It requires you to specify how to install the arbitrary artifacts to the system in the<br>Makefile.<br>NOTE Usually Makefile is written by the developer and not by the packager.<br>Add the install section to the Makefile:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cello:</span><br><span class="line">gcc -g -o cello cello.c</span><br><span class="line">clean:</span><br><span class="line">rm cello</span><br><span class="line">install:</span><br><span class="line">mkdir -p $(DESTDIR)/usr/bin</span><br><span class="line">install -m 0755 cello $(DESTDIR)/usr/bin/cello</span><br></pre></td></tr></table></figure></li></ul></li><li><p>Preparing Source Code for Packaging</p><p>My eg.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@hik hello_rpm-1.0]# ll </span><br><span class="line">total 36</span><br><span class="line">-rwxr-xr-x. 1 root root 27560 Jun 25 20:48 hello_rpms</span><br><span class="line">-rw-r--r--. 1 root root   411 Jun 25 20:39 hello_rpms.c</span><br><span class="line">-rw-r--r--. 1 root root   160 Jun 25 20:47 Makefile</span><br><span class="line">[root@hik hello_rpm-1.0]# </span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Makefile:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">make:</span><br><span class="line">        gcc -g  hello_rpms.c -o hello_rpms</span><br><span class="line">clean:</span><br><span class="line">        rm hello_rpms</span><br><span class="line">install:</span><br><span class="line">        mkdir -p $&#123;DESTDIR&#125;/usr/bin</span><br><span class="line">        install -m 0755 hello_rpms $&#123;DESTDIR&#125;/usr/bin/hello_rpms</span><br></pre></td></tr></table></figure><p>validate her:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@hik hello_rpm-1.0]# make</span><br><span class="line">gcc -g  hello_rpms.c -o hello_rpms</span><br><span class="line">[root@hik hello_rpm-1.0]# make install</span><br><span class="line">mkdir -p /usr/bin</span><br><span class="line">install -m 0755 hello_rpms /usr/bin/hello_rpms</span><br><span class="line">[root@hik hello_rpm-1.0]# hello_rpms   #test for double pointer</span><br><span class="line">old p =(nil)</span><br><span class="line">*p=4</span><br><span class="line">new p =0x11ee6b0</span><br></pre></td></tr></table></figure></li><li><p>Putting Source Code Into Tarball</p><p>Prepare the cello project for distribution:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1.Put the files into a single directory hello_rpm-1.0 and Create the archive for distribution</span><br><span class="line">[root@hik SOURCES]# tar -czvf hello_rpm-1.0.tar.gz hello_rpm-1.0/*</span><br><span class="line">hello_rpm-1.0/hello_rpms.c</span><br><span class="line">hello_rpm-1.0/Makefile</span><br><span class="line">2.Move her to ~/rpmbuild/SOURCES/</span><br><span class="line">3. Add the patch: (later blog version)</span><br></pre></td></tr></table></figure></li></ol><h5 id="Packaging-Software"><a href="#Packaging-Software" class="headerlink" title="Packaging Software"></a>Packaging Software</h5><p>1.RPM Packages</p><ul><li><p>What is an RPM?</p><p>An RPM package is simply a file containing other files and information about them needed by the<br>system. Specifically, an RPM package consists of the cpio archive, which contains the files, and the<br>RPM header, which contains metadata about the package. The rpm package manager uses this<br>metadata to determine dependencies, where to install files, and other information.<br>There are two types of RPM packages:</p><pre><code>• source RPM (SRPM)• binary RPM</code></pre><p>SRPMs and binary RPMs share the file format and tooling, but have different contents and serve<br>different purposes. An SRPM contains source code, optionally patches to it, and a SPEC file, which<br>describes how to build the source code into a binary RPM. A binary RPM contains the binaries built<br>from the sources and patches.</p></li><li><p>RPM Packaging Tools</p><p>rpmdevtools</p></li><li><p>RPM Packaging Workspace</p><p>To set up a directory layout that is the RPM packaging workspace, use the rpmdev-setuptree utility:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> rpmdev-setuptree  <span class="comment">#生成 目录</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> tree ~/rpmbuild/  <span class="comment">#查看</span></span></span><br><span class="line">/home/user/rpmbuild/</span><br><span class="line">|-- BUILD</span><br><span class="line">|-- RPMS</span><br><span class="line">|-- SOURCES</span><br><span class="line">|-- SPECS</span><br><span class="line">`-- SRPMS</span><br><span class="line">5 directories, 0 files  </span><br></pre></td></tr></table></figure><p>The created directories serve these purposes:</p><table><thead><tr><th>Directory</th><th>Purpose</th></tr></thead><tbody><tr><td>BUILD</td><td>When packages are built, various %buildroot directories are created here. This<br/>is useful for investigating a failed build if the logs output do not provide<br/>enough information.</td></tr><tr><td>RPMS</td><td>Binary RPMs are created here, in subdirectories for different architectures, for<br/>example in subdirectories x86_64 and noarch.</td></tr><tr><td>SOURCES</td><td>Here, the packager puts compressed source code archives and patches. The<br/>rpmbuild command looks for them here.</td></tr><tr><td>SPECS</td><td>The packager puts SPEC files here.</td></tr><tr><td>SRPMS</td><td>When rpmbuild is used to build an SRPM instead of a binary RPM, the resulting<br/>SRPM is created here.</td></tr></tbody></table></li><li><p>What is a SPEC File?</p><p>A SPEC file can be thought of as the “recipe” that the rpmbuild utility uses to actually build an RPM.<br>It tells the build system what to do by defining instructions in a series of sections. The sections are<br>defined in the Preamble and the Body. The Preamble contains a series of metadata items that are<br>used in the Body. The Body contains the main part of the instructions.</p><ul><li><p>Preamble Items</p><p>This table lists the items used in the Preamble section of the RPM SPEC file:</p><table><thead><tr><th>SPEC Directive</th><th>Definition</th></tr></thead><tbody><tr><td>Name</td><td>The base name of the package, which should match the SPEC file<br/>name.</td></tr><tr><td>Version</td><td>The upstream version number of the software.</td></tr><tr><td>Release</td><td>The number of times this version of the software was released.<br/>Normally, set the initial value to 1%{?dist}, and increment it with<br/>each new release of the package. Reset to 1 when a new Version of<br/>the software is built.</td></tr><tr><td>Summary</td><td>A brief, one-line summary of the package.</td></tr><tr><td>License</td><td>The license of the software being packaged. For packages distributed<br/>in community distributions such as Fedora this must be an open<br/>source license abiding by the specific distribution’s licensing<br/>guidelines.</td></tr><tr><td>URL</td><td>The full URL for more information about the program. Most often<br/>this is the upstream project website for the software being packaged.</td></tr><tr><td>Source0</td><td>Path or URL to the compressed archive of the upstream source code<br/>(unpatched, patches are handled elsewhere). This should point to an<br/>accessible and reliable storage of the archive, for example, the<br/>upstream page and not the packager’s local storage. If needed, more<br/>SourceX directives can be added, incrementing the number each<br/>time, for example: Source1, Source2, Source3, and so on.</td></tr><tr><td>Patch0</td><td>The name of the first patch to apply to the source code if necessary.<br/>If needed, more PatchX directives can be added, incrementing the<br/>number each time, for example: Patch1, Patch2, Patch3, and so on.</td></tr><tr><td>BuildArch</td><td>If the package is not architecture dependent, for example, if written<br/>entirely in an interpreted programming language, set this to<br/>BuildArch: noarch. If not set, the package automatically inherits the<br/>Architecture of the machine on which it is built, for example x86_64.</td></tr><tr><td>BuildRequires</td><td>A comma- or whitespace-separated list of packages required for<br/>building the program written in a compiled language. There can be<br/>multiple entries of BuildRequires, each on its own line in the SPEC<br/>file.</td></tr><tr><td>Requires</td><td>A comma- or whitespace-separated list of packages required by the<br/>software to run once installed. There can be multiple entries of<br/>Requires, each on its own line in the SPEC file.</td></tr><tr><td>ExcludeArch</td><td>If a piece of software can not operate on a specific processor<br/>architecture, you can exclude that architecture here.</td></tr></tbody></table><p>RPM package filenames have the NAME-VERSION-RELEASE format:</p><p>eg.python-2.7.5-34.el7.x86_64</p></li><li><p>Body Items</p><p>This table lists the items used in the Body section of the RPM SPEC file:</p><table><thead><tr><th>SPEC Directive</th><th>Definition</th></tr></thead><tbody><tr><td>%description</td><td>full description of the software packaged in the RPM. This description can<br/>span multiple lines and can be broken into paragraphs.</td></tr><tr><td>%prep</td><td>Command or series of commands to prepare the software to be built, for<br/>example, unpacking the archive in Source0. This directive can contain a shell<br/>script.</td></tr><tr><td>%build</td><td>Command or series of commands for actually building the software into<br/>machine code (for compiled languages) or byte code (for some interpreted<br/>languages).</td></tr><tr><td>%install</td><td>Command or series of commands for copying the desired build artifacts from<br/>the %builddir (where the build happens) to the %buildroot directory (which<br/>contains the directory structure with the files to be packaged). This usually<br/>means copying files from ~/rpmbuild/BUILD to ~/rpmbuild/BUILDROOT and<br/>creating the necessary directories in ~/rpmbuild/BUILDROOT. This is only run<br/>when creating a package, not when the end-user installs the package. See<br/>Working with SPEC files for details.</td></tr><tr><td>%check</td><td>Command or series of commands to test the software. This normally includes<br/>things such as unit tests.</td></tr><tr><td>%files</td><td>The list of files that will be installed in the end user’s system</td></tr><tr><td>%changelog</td><td>A record of changes that have happened to the package between different<br/>Version or Release builds.</td></tr></tbody></table></li><li><p>Advanced items</p><p>The SPEC file can also contain advanced items. For example, a SPEC file can have scriptlets and<br>triggers. They take effect at different points during the installation process on the end user’s system<br>(not the build process).<br>See the Scriptlets and Triggers for advanced topics.</p></li></ul></li><li><p>BuildRoots</p></li><li><p>RPM Macros</p><p>rpm –eval %{_MACRO}  #check for a Macro</p><table><thead><tr><th>Macros</th><th></th></tr></thead><tbody><tr><td>%{version}</td><td></td></tr><tr><td>%{?dist}</td><td>distribution tag</td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr></tbody></table></li><li><p>More on Macros</p></li><li><p>Working with SPEC files</p></li><li><p>FAQ</p><ul><li>[Found ‘${BUILDROOT}’ in installed files; aborting]: <a href="http://adam.younglogic.com/2010/05/found-buildroot-in-installed-files-aborting/">http://adam.younglogic.com/2010/05/found-buildroot-in-installed-files-aborting/</a></li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Reference:&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://bbs.huaweicloud.com/forum/thread-38327-1-1.html&quot;&gt;https://bbs.huaweicloud.com/forum/thread-38327-1-1.ht</summary>
      
    
    
    
    <category term="Linux" scheme="https://hxlpub.github.io/categories/Linux/"/>
    
    
    <category term="rpm" scheme="https://hxlpub.github.io/tags/rpm/"/>
    
  </entry>
  
  <entry>
    <title>【工具】Xmind：how to use xmind efficently</title>
    <link href="https://hxlpub.github.io/2022/06/18/to-use-xmind/"/>
    <id>https://hxlpub.github.io/2022/06/18/to-use-xmind/</id>
    <published>2022-06-18T13:00:25.000Z</published>
    <updated>2023-05-28T11:36:16.601Z</updated>
    
    <content type="html"><![CDATA[<p>Here are some simple tips for using xmind .</p><ol><li></li></ol><ul><li>tip1. choose theme u like</li><li>tip2. choose theme u like</li><li>tip3. choose theme u like</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Here are some simple tips for using xmind .&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;tip1. choose theme u like&lt;/li&gt;
&lt;li&gt;tip2. choose theme u lik</summary>
      
    
    
    
    <category term="工具" scheme="https://hxlpub.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
    <category term="xmind" scheme="https://hxlpub.github.io/tags/xmind/"/>
    
  </entry>
  
  <entry>
    <title>【c】搭建C知识体系：知识map</title>
    <link href="https://hxlpub.github.io/2022/06/18/c-learn-roadmap/"/>
    <id>https://hxlpub.github.io/2022/06/18/c-learn-roadmap/</id>
    <published>2022-06-18T11:51:24.000Z</published>
    <updated>2023-05-28T11:12:08.384Z</updated>
    
    <content type="html"><![CDATA[<p>本文目的：</p><p>系统化C知识体系，提效开发，提高生产力。</p><p>xmind:</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本文目的：&lt;/p&gt;
&lt;p&gt;系统化C知识体系，提效开发，提高生产力。&lt;/p&gt;
&lt;p&gt;xmind:&lt;/p&gt;
</summary>
      
    
    
    
    <category term="编程语言" scheme="https://hxlpub.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
    <category term="c" scheme="https://hxlpub.github.io/tags/c/"/>
    
  </entry>
  
  <entry>
    <title>【debug】linux_coredump</title>
    <link href="https://hxlpub.github.io/2022/06/13/linux-coredump/"/>
    <id>https://hxlpub.github.io/2022/06/13/linux-coredump/</id>
    <published>2022-06-13T06:30:45.000Z</published>
    <updated>2023-05-28T11:25:39.489Z</updated>
    
    <content type="html"><![CDATA[<p>from <a href="https://www.cnblogs.com/Anker/p/6079580.html">https://www.cnblogs.com/Anker/p/6079580.html</a></p><h1 id="linux下core-dump【总结】"><a href="#linux下core-dump【总结】" class="headerlink" title="linux下core dump【总结】"></a><a href="https://www.cnblogs.com/Anker/p/6079580.html">linux下core dump【总结】</a></h1><p><strong>1、前言</strong></p><p>　　一直在从事linux下后台开发，经常与core文件打交道。还记得刚开始从事linux下开发时，程序突然崩溃了，也没有任何日志。我不知所措，同事叫我看看core，我却问什么是core，怎么看。同事鄙视的眼神，我依然在目。后来学会了从core文件中分析原因，通过gdb看出程序挂再哪里，分析前后的变量，找出问题的原因。当时就觉得很神奇，core文件是怎么产生的呢？难道系统会自动产生，可是我在自己的linux系统上面写个非法程序测试，并没有产生core问题？这又是怎么回事呢？今天在ngnix的源码时候，发现可以在程序中设置core dump，又是怎么回事呢？在公司发现生成的core文件都带有进程名称、进程ID、和时间，这又是怎么做到的呢？今天带着这些疑问来说说core文件是如何生成，如何配置。</p><p><strong>2、基本概念</strong></p><p>　　 当程序运行的过程中异常终止或崩溃，操作系统会将程序当时的内存状态记录下来，保存在一个文件中，这种行为就叫做Core Dump（中文有的翻译成“核心转储”)。我们可以认为 core dump 是“内存快照”，但实际上，除了内存信息之外，还有些关键的程序运行状态也会同时 dump 下来，例如寄存器信息（包括程序指针、栈指针等）、内存管理信息、其他处理器和操作系统状态和信息。core dump 对于编程人员诊断和调试程序是非常有帮助的，因为对于有些程序错误是很难重现的，例如指针异常，而 core dump 文件可以再现程序出错时的情景。</p><p><strong>3、开启core dump</strong></p><p>　　可以使用命令ulimit开启，也可以在程序中通过setrlimit系统调用开启。</p><p><img src="https://images2015.cnblogs.com/blog/305504/201611/305504-20161118233242123-1567391612.png" alt="img"></p><p>程序中开启core dump，通过如下API可以查看和设置RLIMIT_CORE</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/resource.h&gt;</span><br><span class="line"></span><br><span class="line">int getrlimit(int resource, struct rlimit *rlim);</span><br><span class="line">int setrlimit(int resource, const struct rlimit *rlim);</span><br></pre></td></tr></table></figure><p>参考程序如下所示：</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;sys/time.h&gt;</span><br><span class="line">#include &lt;sys/resource.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#define CORE_SIZE   1024 * 1024 * 500</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    struct rlimit rlmt;</span><br><span class="line">    if (getrlimit(RLIMIT_CORE, &amp;rlmt) == -1) &#123;</span><br><span class="line">        return -1; </span><br><span class="line">    &#125;   </span><br><span class="line">    printf(&quot;Before set rlimit CORE dump current is:%d, max is:%d\n&quot;, (int)rlmt.rlim_cur, (int)rlmt.rlim_max);</span><br><span class="line"></span><br><span class="line">    rlmt.rlim_cur = (rlim_t)CORE_SIZE;</span><br><span class="line">    rlmt.rlim_max  = (rlim_t)CORE_SIZE;</span><br><span class="line"></span><br><span class="line">    if (setrlimit(RLIMIT_CORE, &amp;rlmt) == -1) &#123;</span><br><span class="line">        return -1; </span><br><span class="line">    &#125;   </span><br><span class="line"></span><br><span class="line">    if (getrlimit(RLIMIT_CORE, &amp;rlmt) == -1) &#123;</span><br><span class="line">        return -1; </span><br><span class="line">    &#125;   </span><br><span class="line">    printf(&quot;After set rlimit CORE dump current is:%d, max is:%d\n&quot;, (int)rlmt.rlim_cur, (int)rlmt.rlim_max);</span><br><span class="line"></span><br><span class="line">    /*测试非法内存，产生core文件*/</span><br><span class="line">    int *ptr = NULL;</span><br><span class="line">    *ptr = 10; </span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>执行./main, 生成的core文件如下所示</p><p><img src="https://images2015.cnblogs.com/blog/305504/201611/305504-20161118233633717-104433407.png" alt="img"></p><p>GDB调试core文件，查看程序挂在位置。当core dump 之后，使用命令 <strong><code>gdb program core</code></strong> 来查看 core 文件，其中 program 为可执行程序名，core 为生成的 core 文件名。</p><p><img src="https://images2015.cnblogs.com/blog/305504/201611/305504-20161118233850138-2085849607.png" alt="img"></p><p><strong>4、参考资料</strong></p><p><a href="http://www.cnblogs.com/hazir/p/linxu_core_dump.html">http://www.cnblogs.com/hazir/p/linxu_core_dump.html</a></p><p><a href="http://www.cnblogs.com/niocai/archive/2012/04/01/2428128.html">http://www.cnblogs.com/niocai/archive/2012/04/01/2428128.html</a></p><p><a href="http://baidutech.blog.51cto.com/4114344/904419/">http://baidutech.blog.51cto.com/4114344/904419/</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;from &lt;a href=&quot;https://www.cnblogs.com/Anker/p/6079580.html&quot;&gt;https://www.cnblogs.com/Anker/p/6079580.html&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;linux下core-dump【</summary>
      
    
    
    
    <category term="debug" scheme="https://hxlpub.github.io/categories/debug/"/>
    
    
    <category term="coredump" scheme="https://hxlpub.github.io/tags/coredump/"/>
    
  </entry>
  
  <entry>
    <title>【c】标准库和常用函数</title>
    <link href="https://hxlpub.github.io/2022/06/12/c_stanardlib_func_common/"/>
    <id>https://hxlpub.github.io/2022/06/12/c_stanardlib_func_common/</id>
    <published>2022-06-12T09:26:07.000Z</published>
    <updated>2023-05-28T11:11:57.542Z</updated>
    
    <content type="html"><![CDATA[<p>Target:</p><p>1.To describe the c standard libs(section 1) and common functions (section 2)to use</p><hr><p>Section 1</p><p>1.<a href="https://www.onitroad.com/jc/linux/man-pages/linux/man3/open_memstream.3.html">https://www.onitroad.com/jc/linux/man-pages/linux/man3/open_memstream.3.html</a></p><hr><p>Section 2</p><ul><li>字符串函数</li></ul><table><thead><tr><th>func</th><th>desc</th><th>instance</th></tr></thead><tbody><tr><td>strlen(s)</td><td>获取字符串s的长度</td><td></td></tr><tr><td>strcmp(s1,s2)</td><td>比较字符串;比较的时候会把字符串转换成ASCII码再进行比较,返回结果为0表示s1和s2的ASCII码值相等,返回结果为1表示s1比s2的ASCII码大,返回结果为-1表示s1比s2的ACSII码小;</td><td></td></tr><tr><td>strcpy(s1,s2)</td><td>字符串拷贝;s2会取代s1中的内容</td><td></td></tr><tr><td>strcat(s1,s2)</td><td>将s2拼接到s1后面;注意:s1的length要足够才可以</td><td></td></tr><tr><td>atoi(s1)</td><td>将字符串转为整数</td><td></td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Target:&lt;/p&gt;
&lt;p&gt;1.To describe the c standard libs(section 1) and common functions (section 2)to use&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;Section 1&lt;/p&gt;
&lt;p&gt;1.&lt;a href</summary>
      
    
    
    
    <category term="编程语言" scheme="https://hxlpub.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
    <category term="c" scheme="https://hxlpub.github.io/tags/c/"/>
    
  </entry>
  
  <entry>
    <title>【c】UNIX API</title>
    <link href="https://hxlpub.github.io/2022/06/12/c-unix-apis/"/>
    <id>https://hxlpub.github.io/2022/06/12/c-unix-apis/</id>
    <published>2022-06-12T08:10:40.000Z</published>
    <updated>2023-05-28T11:11:47.991Z</updated>
    
    
    
    
    <category term="编程语言" scheme="https://hxlpub.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
    <category term="c" scheme="https://hxlpub.github.io/tags/c/"/>
    
  </entry>
  
  <entry>
    <title>【HPC】深度解析Lustre体系结构</title>
    <link href="https://hxlpub.github.io/2022/06/08/hpc_lustre/"/>
    <id>https://hxlpub.github.io/2022/06/08/hpc_lustre/</id>
    <published>2022-06-08T07:57:07.000Z</published>
    <updated>2023-05-28T11:22:34.779Z</updated>
    
    <content type="html"><![CDATA[<p>文章转自“Lustre文件系统与DDN”</p><p>Lustre架构是一种集群存储体系结构，其核心组件就是Lustre文件系统。该文件系统可在Linux操作系统上运行，并提供了符合POSIX标准的UNIX文件系统接口。</p><p>Lustre文件系统是什么</p><p>Lustre架构用于许多不同种类的集群。众所周知，它服务于许多全球最大的高性能计算(HPC)集群，提供了数以万计的客户端，PB级存储和每秒数百GB的吞吐量。许多HPC站点使用Lustre文件系统作为全站范围的全局文件系统，为数十个群集提供服务。</p><p>Lustre文件系统具有按需扩展容量和性能的能力，降低了部署多个独立文件系统的必要性(如每个计算群集部署一个文件系统)，从而避免了在计算集群之间复制数据，简化了存储管理。Lustre文件系统不仅可将许多服务器的存储容量进行聚合，也可将其I / O吞吐量进行聚合，并通过添置服务器进行扩展。通过动态地添加服务器，轻松实现整个集群的吞吐量和容量的提升。</p><p>虽然Lustre文件系统可以在许多工作环境中运行，但也并非就是所有应用程序的最佳选择。当单个服务器无法提供所需容量时，使用Lustre文件系统集群无疑是最适合的。在某些情况下，由于其强大的锁定和数据一致性，即使在单个服务器环境下Lustre文件系统也比其他文件系统表现得更好。</p><p>目前，Lustre文件系统并不特别适用于“端对端”的用户模式。在这种模式下，客户端和服务器在同一节点上运行，每个节点共享少量存储。由于Lustre缺少软件级别的数据副本，如果一个客户端或服务器发生故障，存储在该节点上的数据在该节点重新启动前将不可访问。</p><p>Lustre文件系统特性</p><p>Lustre文件系统可运行在各种厂商的内核上。一个Lustre文件系统在客户端节点数量、磁盘存储量、带宽上进行扩大或缩小。可扩展性和性能取决于可用磁盘、网络带宽以及系统中服务器的处理能力。</p><p>Lustre文件系统可以以多种配置进行部署，这些配置的可扩展性远远超出了迄今所观察到生产系统中的规模和性能。下表中列出了一些Lustre文件系统的可扩展性和性能:</p><p><img src="https://ask.qcloudimg.com/http-save/developer-news/2ayquv1wf7.jpeg?imageView2/2/w/1620" alt="img"></p><p><strong>性能增强的ext4文件系统：</strong>Lustre文件系统使用改进版的ext4日志文件系统来存储数据和元数据。这个版本被命名为ldiskfs，不仅性能有所提升且提供了Lustre文件系统所需的附加功能。</p><p>Lustre 2.4或更高版本中，可使用ZFS作为Lustre的MDT，OST和MGS存储的后备文件系统。这使Lustre能够利用ZFS的可扩展性和数据完整性特性来实现单个存储目标。</p><p><strong>符合POSIX标准：</strong>通过完整的POSIX测试集，像测试本地文件系统Ext4一样，测试Lustre文件系统客户端，只有极少量例外。在集群中，大多数操作都是原子操作，因此客户端永远不会看到损坏的数据或元数据。 Lustre软件支持mmap()文件I / O操作。</p><p><strong>高性能异构网络：</strong>Lustre软件支持各种高性能低延迟的网络，可使用远程直接内存访问(RDMA)方式，实现在InfiniBand、Intel OmniPath等高级网络上的快速高效网络传输。可使用Lustre路由桥接多个RDMA网络以获得最佳性能。Lustre软件同时也集成了网络诊断。</p><p><strong>高可用性：</strong>Lustre文件系统通过OSTs(OSS targets)的共享存储分区实现主动/主动故障切换。 Lustre 2.3或更早版本通过使用MDT(MDS target)的共享存储分区实现主动/被动故障切换。 Lustre文件系统可以与各种高可用性(HA)管理器一起工作，以实现自动故障切换并消除了单点故障(NSPF)。这使得应用程序透明恢复成为可能。多重挂载保护(MMP)提供了对高可用性系统中错误的综合保护，避免导致文件系统损坏。</p><p>Lustre 2.4或更高版本中，可配置多个MDT的主动/主动故障切换。这允许了通过添加MDT存储设备和MDS节点来扩展Lustre文件系统的元数据性能。</p><p><strong>安全性：</strong>默认情况下，TCP连接只允许授权端口通过。 UNIX组成员身份在MDS上进行验证。</p><p><strong>访问控制列表(ACL)及扩展属性：</strong>Lustre安全模型遵循UNIX文件系统原则，并使用POSIX ACL进行增强。此外还有一些额外功能，如root squash。</p><p><strong>互操作性：</strong>Lustre文件系统可运行在各种CPU架构和大小端混合的群集上，连续发布的Lustre主要软件版本之间保持互操作性性。</p><p><strong>基于对象的体系结构：</strong>客户端与磁盘文件结构相互隔离，可在不影响客户端的情况下升级存储体系结构。</p><p><strong>字节粒度文件锁和细粒度元数据锁：</strong>许多客户端可以同时读取和修改相同的文件或目录。 Lustre分布式锁管理器(LDLM)确保了文件系统中所有客户端和服务器之间的文件是一致的。其中，MDT锁管理器负责管理inode权限和路径名。每个OST都有其自己的锁管理器，用于锁定存储在其上的文件条带，其性能可随着文件系统大小增长而扩展。</p><p><strong>配额：</strong>用户、组和项目配额(User、Group、Project Quota)可用于Lustre文件系统。</p><p><strong>容量增长：</strong>通过向群集添加新的OST和MDT，可以在不中断服务的情况下增加Lustre文件系统的大小和集群总带宽。</p><p><strong>受控文件布局：</strong>可以在每个文件，每个目录或每个文件系统基础上配置跨OST的文件布局。这允许了在单个文件系统中调整文件I/O以适应特定的应用程序要求。 Lustre文件系统使用RAID-0进行条带化并可在OST之间调节空间使用大小。</p><p><strong>网络数据完整性保护：</strong>从客户端发送到OSS的所有数据的校验和可防止数据在传输期间被损坏。</p><p><strong>MPI I/O：</strong>Lustre架构具有专用的MPI ADIO层，优化了并行I/O以匹配基础文件系统架构。</p><p><strong>NFS和CIFS导出：</strong>可以使用NFS(通过Linux knfsd)或CIFS(通过Samba)将Lustre文件重新导出，使其可以与非Linux客户端(如Microsoft Windows和Apple Mac OS X)共享。</p><p><strong>灾难恢复工具：</strong>Lustre文件系统提供在线分布式文件系统检查(LFSCK)，当发生主要文件系统错误的情况下恢复存储组件之间的一致性。 Lustre文件系统在存在文件系统不一致的情况下也可以运行，而LFSCK可以在文件系统正在使用时运行，因此LFSCK不需要在文件系统恢复生产之前完成。</p><p><strong>性能监视：</strong>Lustre文件系统提供了多种机制来检查性能和进行调整。</p><p><strong>开放源代码：</strong>为在Linux操作系统上运行，Lustre软件使用GPL 2.0许可证。</p><p>Lustre组件介绍</p><p>一个Lustre安装实例包括管理服务器(MGS)和一个或多个与Lustre网络(LNet)互连的Lustre文件系统。Lustre文件系统组件的基本配置如下图所示：</p><p><img src="https://ask.qcloudimg.com/http-save/developer-news/zhoh5q9e7r.jpeg?imageView2/2/w/1620" alt="img"></p><p>管理服务器(MGS)</p><p>MGS存储集群中所有Lustre文件系统的配置信息，并将此信息提供给其他Lustre组件。每个Lustre目标(target)通过联系MGS提供信息，而Lustre客户通过联系MGS获取信息。MGS最好有自己的存储空间，以便可以独立管理。但同时，MGS可以与MDS放在一起，并共享存储空间，如上图中所示。</p><p>Lustre文件系统组件</p><p>**元数据服务器(MDS):**MDS使存储在一个或多个MDT中的元数据可供Lustre客户端使用。每个MDS管理Lustre文件系统中的名称和目录，并为一个或多个本地MDT提供网络请求处理。</p><p>**元数据目标(MDT):**在Lustre 2.3或更早版本中，每个文件系统只有一个MDT。 MDT在MDS的附加存储上存储元数据（例如文件名，目录，权限和文件布局）。虽然共享存储目标上的MDT可用于多个MDS，但一次只能有一个MDS可以访问。如果当前MDS发生故障，则备用MDS可以为MDT提供服务，并将其提供给客户端。这被称为MDS故障切换。</p><p>在Lustre 2.4中，分布式命名空间环境(DNE)中可支持多个MDT。除保存文件系统根目录的主MDT之外，还可以添加其他MDS节点，每个MDS节点都有自己的MDT，以保存文件系统的子目录树。</p><p>在Lustre 2.8中，DNE还允许文件系统将单个目录的文件分布到多个MDT节点。分布在多个MDT上的目录称为条带化目录。</p><p><strong>对象存储服务器(OSS)：</strong>OSS为一个或多个本地OST提供文件I / O服务和网络请求处理。通常，OSS服务于两个到八个OST，每个最多16TB；在专用节点上配置一个MDT；在每个OSS节点上配置两个或更多OST；而在大量计算节点上配置客户端。</p><p><strong>对象存储目标(OST)：</strong>用户文件数据存储在一个或多个对象中，每个对象位于Lustre文件系统的单独OST中。每个文件的对象数由用户配置，并可根据工作负载情况调试到最优性能。</p><p><strong>Lustre客户端：</strong>Lustre客户端是运行Lustre客户端软件的计算、可视化或桌面节点，可挂载Lustre文件系统。</p><p>Lustre客户端软件为Linux虚拟文件系统和Lustre服务器之间提供了接口。客户端软件包括一个管理客户端(MGC)，一个元数据客户端(MDC)和多个对象存储客户端(OSC)。每个OSC对应于文件系统中的一个OST。</p><p>逻辑对象卷(LOV)通过聚合OSC以提供对所有OST的透明访问。因此，挂载了Lustre文件系统的客户端会看到一个连贯的同步名字空间。多个客户端可以同时写入同一文件的不同部分，而其他客户端可以同时读取文件。</p><p>与LOV文件访问方式类似，逻辑元数据卷(LMV)通过聚合MDC提供一种对所有MDT透明的访问。这使得了客户端可将多个MDT上的目录树视为一个单一的连贯名字空间，并将条带化目录合并到客户端形成一个单一目录以便用户和应用程序查看。</p><p><img src="https://ask.qcloudimg.com/http-save/developer-news/wti1ln7mi6.jpeg?imageView2/2/w/1620" alt="img"></p><p>Lustre网络 (LNet)</p><p>Lustre Networking(LNet)是一种定制网络API，提供处理Lustre文件系统服务器和客户端的元数据和文件I/O数据的通信基础设施。</p><p>Lustr文件系统 集群</p><p>在规模上，一个Lustre文件系统集群可以包含数百个OSS和数千个客户端(如下图所示)。 Lustre集群中可以使用多种类型的网络，OSS之间的共享存储启用故障切换功能。</p><p><img src="https://ask.qcloudimg.com/http-save/developer-news/bzl2v4nhz0.jpeg?imageView2/2/w/1620" alt="img"></p><p>Lustre文件系统存储与I/O</p><p>在 Lustre 2.0 中引入了Lustre文件标识符(FID)来替换用于识别文件或对象的UNIX inode编号。 FID是一个128位的标识符，其中，64位用于存储唯一的序列号，32位用于存储对象标识符(OID)，另外32位用于存储版本号。序列号在文件系统(OST和MDT)中的所有Lustre目标中都是唯一的。这一改变使未来支持多种 MDT 和ZFS(均在Lustre 2.4中引入)成为了可能。</p><p>同时，在此版本中也引入了一个名为FID-in-dirent(也称为Dirdata)的ldiskfs功能，FID作为文件名称的一部分存储在父目录中。该功能通过减少磁盘I/O显著提高了ls命令执行的性能。 FID-in-dirent是在创建文件时生成的。</p><p>在 Lustre 2.4 中，LFSCK文件系统一致性检查工具提供了对现有文件启用FID-in-dirent的功能。具体如下：</p><p>为1.8版本文件系统上现有文件生成IGIF模式的FID。</p><p>验证每个文件的FID-in-dirent，如其无效或丢失，则重新生成FID-in-dirent。</p><p>验证每个linkEA条目，如其无效或丢失，则重新生成。 linkEA由文件名和父类FID组成，它作为扩展属性存储在文件本身中。因此，linkEA可以用来重建文件的完整路径名。</p><p>有关文件数据在OST上的位置信息将作为扩展属性布局EA，存储在由FID标识的MDT对象中(具体如下图所示)。若该文件是普通文件(即不是目录或符号链接)，则MDT对象1对N地指向包含文件数据的OST对象。若该MDT文件指向一个对象，则所有文件数据都存储在该对象中。若该MDT文件指向多个对象，则使用RAID 0将文件数据划分为多个对象，将每个对象存储在不同的OST上。</p><p><img src="https://ask.qcloudimg.com/http-save/developer-news/g504riegog.jpeg?imageView2/2/w/1620" alt="img"></p><p>当客户端读写文件时，首先从文件的MDT对象中获取布局EA，然后使用这个信息在文件上执行I / O，直接与存储对象的OSS节点进行交互。具体过程如下图所示。</p><p><img src="https://ask.qcloudimg.com/http-save/developer-news/38v2ao9oaf.jpeg?imageView2/2/w/1620" alt="img"></p><p>Lustre文件系统的可用带宽如下：</p><p>网络带宽等于OSS到目标的总带宽。</p><p>磁盘带宽等于存储目标(OST)的磁盘带宽总和，受网络带宽限制。</p><p>总带宽等于磁盘带宽和网络带宽的最小值。</p><p>可用的文件系统空间等于所有OST的可用空间总和。</p><p>Lustre文件系统条带化</p><p>Lustre文件系统高性能的主要原因之一是能够以轮询方式跨多个OST将数据条带化。用户可根据需要为每个文件配置条带数量，条带大小和OST。当单个文件的总带宽超过单个OST的带宽时，可以使用条带化来提高性能。同时，当单个OST没有足够的可用空间来容纳整个文件时，条带化也能发挥它的作用。</p><p>如图下图所示，条带化允许将文件中的数据段或“块”存储在不同的OST中。在Lustre文件系统中，通过RAID 0模式将数据在一定数量的对象上进行条带化。一个文件中处理的对象数称为stripe_count。每个对象包含文件中的一个数据块，当写入特定对象的数据块超过stripe_size时，文件中的下一个数据块将存储在下一个对象上。stripe_count和stripe_size的默认值由为文件系统设置的，其中，stripe_count为1，stripe_size为1MB。用户可以在每个目录或每个文件上更改这些值。</p><p>下图中，文件C的stripe_size大于文件A的stripe_size，表明更多的数据被允许存储在文件C的单个条带中。文件A的stripe_count为3，则数据在三个对象上条带化。文件B和文件C的stripe_count是1。OST上没有为未写入的数据预留空间。</p><p><img src="https://ask.qcloudimg.com/http-save/developer-news/mri8zksxf8.jpeg?imageView2/2/w/1620" alt="img"></p><p>最大文件大小不受单个目标大小的限制。在Lustre文件系统中，文件可以跨越多个对象(最多2000个)进行分割，每个对象可使用多达16 TB的ldiskfs，多达256PB的ZFS。也就是说，ldiskfs的最大文件大小为31.25 PB，ZFS的最大文件大小为8EB。Lustre文件系统上的文件大小受且仅受OST上可用空间的限制，Lustre最大可支持2 ^ 63字节(8EB)的文件。</p><p>**注意:**Lustre 2.2之前，单个文件的最大条带数为160个OST。尽管一个文件只能被分割成2000个以上的对象，但是Lustre文件系统可以有数千个。</p><ul><li>发表于: 2018-06-01</li><li>原文链接：<a href="https://kuaibao.qq.com/s/20180601A0AHSR00?refer=cp_1026">https://kuaibao.qq.com/s/20180601A0AHSR00?refer=cp_1026</a></li><li>腾讯「云+社区」是腾讯内容开放平台帐号（企鹅号）传播渠道之一，根据<a href="https://om.qq.com/notice/a/20160429/047194.htm">《腾讯内容开放平台服务协议》</a>转载发布内容。</li><li>如有侵权，请联系 <a href="mailto:&#x79;&#117;&#x6e;&#106;&#105;&#x61;&#x5f;&#x63;&#x6f;&#109;&#109;&#117;&#110;&#x69;&#x74;&#x79;&#x40;&#116;&#101;&#x6e;&#x63;&#x65;&#x6e;&#116;&#46;&#99;&#111;&#x6d;">&#x79;&#117;&#x6e;&#106;&#105;&#x61;&#x5f;&#x63;&#x6f;&#109;&#109;&#117;&#110;&#x69;&#x74;&#x79;&#x40;&#116;&#101;&#x6e;&#x63;&#x65;&#x6e;&#116;&#46;&#99;&#111;&#x6d;</a> 删除。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;文章转自“Lustre文件系统与DDN”&lt;/p&gt;
&lt;p&gt;Lustre架构是一种集群存储体系结构，其核心组件就是Lustre文件系统。该文件系统可在Linux操作系统上运行，并提供了符合POSIX标准的UNIX文件系统接口。&lt;/p&gt;
&lt;p&gt;Lustre文件系统是什么&lt;/p&gt;
</summary>
      
    
    
    
    <category term="HPC" scheme="https://hxlpub.github.io/categories/HPC/"/>
    
    
    <category term="HPC" scheme="https://hxlpub.github.io/tags/HPC/"/>
    
  </entry>
  
  <entry>
    <title>【存储】Basics：浅谈EC和多副本</title>
    <link href="https://hxlpub.github.io/2022/06/08/storage_basics/"/>
    <id>https://hxlpub.github.io/2022/06/08/storage_basics/</id>
    <published>2022-06-08T07:57:07.000Z</published>
    <updated>2023-05-28T11:30:22.914Z</updated>
    
    <content type="html"><![CDATA[<p>【摘要】 对于存储用户而言，存储系统的可靠性、性能、成本，是用户非常关注的几个方面。在传统的存储中，大多是采用RAID的方式，来保证数据的高可靠性；而在分布式存储系统中，多副本和EC(Erasure Code)是比较常见的数据保护方法。本文简单介绍多副本和EC概念、原理和优势对比等</p><h5 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h5><p>对于存储用户而言，存储系统的可靠性、性能、成本，是用户非常关注的几个方面。在传统的存储中，大多是采用RAID的方式，来保证数据的高可靠性；而在分布式存储系统中，多副本和EC(Erasure Code)是比较常见的数据保护方法。</p><p>那么什么是多副本？又如何理解EC？他们之间的区别和优势又是什么呢？</p><h5 id="多副本"><a href="#多副本" class="headerlink" title="多副本"></a>多副本</h5><p>简单说，多副本就是一份数据以副本的方式写到多个分布式系统中的存储节点中。这种多副本的数据保护方式，一来实现简单，而来可靠性高。除非所有副本所在的存储节点都故障，才会影响业务；除此之外，可以从未故障的其他副本读取数据以保证业务。但是多副本的空间利用率偏低，以三副本为例，存储空间利用率未33%，这也增加了企业级用户的存储成本。</p><h5 id="EC"><a href="#EC" class="headerlink" title="EC"></a>EC</h5><p>EC是一种技术。是指将n份原始数据，增加m份数据，并能通过n+m份中的任意n份数据，还原为原始数据。如果把n+m份数据分布在存储系统的不同节点上，那么任意小于等于m个节点故障（m份数据失效），都可以通过其他剩余的数据还原出原始数据，从而达到不影响业务的目的。EC算法可以灵活配置，比如系统要满足支持2个节点同时故障，则m=2即可。从空间利用率上，EC是优于多副本的，以4+2为例，空间利用率为4/（4+2）=67%。这个利用率相当于三副本的2倍。而可靠性上，与三副本一样可以满足支持2个节点同时故障。</p><p>疑问：n份数据是数据分摊吗？m份数据是校验的？怎么生成的m份数据？</p><h5 id="对比分析"><a href="#对比分析" class="headerlink" title="对比分析"></a>对比分析</h5><p>在满足同等可靠性要求的前提下，从以下方面对EC和多副本进行对比分析，如下：</p><table><thead><tr><th></th><th>空间利用率</th><th>硬件成本</th></tr></thead><tbody><tr><td>多副本</td><td>低</td><td>高</td></tr><tr><td>EC</td><td>高</td><td>低</td></tr></tbody></table><p>本文转载自华为云社区<a href="https://bbs.huaweicloud.com/blogs/115216%EF%BC%8C%E4%BD%9C%E8%80%85%EF%BC%9A[%E9%A3%8E%E4%B8%AD%E6%9C%89%E6%9C%B5%E7%8A%87%E7%8A%87%E4%BA%91](https://bbs.huaweicloud.com/community/usersnew/id_1513588727908205)">https://bbs.huaweicloud.com/blogs/115216，作者：[风中有朵犇犇云](https://bbs.huaweicloud.com/community/usersnew/id_1513588727908205)</a> 发表于 2019/04/25 14:32:21</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;【摘要】 对于存储用户而言，存储系统的可靠性、性能、成本，是用户非常关注的几个方面。在传统的存储中，大多是采用RAID的方式，来保证数据的高可靠性；而在分布式存储系统中，多副本和EC(Erasure Code)是比较常见的数据保护方法。本文简单介绍多副本和EC概念、原理和优</summary>
      
    
    
    
    <category term="存储" scheme="https://hxlpub.github.io/categories/%E5%AD%98%E5%82%A8/"/>
    
    
    <category term="存储" scheme="https://hxlpub.github.io/tags/%E5%AD%98%E5%82%A8/"/>
    
  </entry>
  
  <entry>
    <title>【c】内存管理：malloc、free</title>
    <link href="https://hxlpub.github.io/2022/06/07/c-funcs-malloc-free/"/>
    <id>https://hxlpub.github.io/2022/06/07/c-funcs-malloc-free/</id>
    <published>2022-06-07T00:38:07.000Z</published>
    <updated>2023-05-28T11:12:11.645Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://bbs.byr.cn/pc/pccon.php?id=315&amp;nid=68136">http://bbs.byr.cn/pc/pccon.php?id=315&amp;nid=68136</a></p><p>版权说明：转自bc-cn C语言论坛</p><p>写程序时用malloc竟然出现段错误，而且明显那块没有用错，肯定是别的地方有内存泄漏的问题，导致最后内存泄漏了。需要好好查一查原因了。但程序中很多地方都用来malloc，内存全是随便用的，要改起来估计十分麻烦。。。。</p><p> 下面找了点malloc与free的介绍，先看下，然后赶紧改代码。</p><p> 在C语言的学习中，对内存管理这部分的知识掌握尤其重要！之前对C中的malloc()和free()两个函数的了解甚少，只知道大概该怎么用——就是malloc然后free就一切OK了。当然现在对这两个函数的体会也不见得多，不过对于本文章第三部分的内容倒是有了转折性的认识，所以</p><p>写下这篇文章作为一个对知识的总结。这篇文章之所以命名中有个“浅谈”的字眼，也就是这个意思了！希望对大家有一点帮助！</p><p>   如果不扯得太远的话（比如说操作系统中虚拟内存和物理内存如何运做如何管理之类的知识等），我感觉这篇文章应该是比较全面地谈了一下malloc()和free().这篇文章由浅入深（不见得有多深）分三个部分介绍主要内容。</p><p>废话了那么多，下面立刻进入主题================》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》</p><p>一、malloc()和free()的基本概念以及基本用法：</p><p>1、函数原型及说明：</p><p>void *malloc(long NumBytes)：该函数分配了NumBytes个字节，并返回了指向这块内存的指针。如果分配失败，则返回一个空指针（NULL）。</p><p>关于分配失败的原因，应该有多种，比如说空间不足就是一种。</p><p>void free(void *FirstByte)： 该函数是将之前用malloc分配的空间还给程序或者是操作系统，也就是释放了这块内存，让它重新得到自由。</p><p>2、函数的用法：</p><p>   其实这两个函数用起来倒不是很难，也就是malloc()之后觉得用够了就甩了它把它给free()了，举个简单例子：</p><p>程序代码：<br>    // Code…<br>    char *Ptr = NULL;<br>    Ptr = (char *)malloc(100 * sizeof(char));<br>    if (NULL == Ptr)<br>  {<br>    exit (1);<br>  }<br>    gets(Ptr); </p><p>​    // code…<br>​    free(Ptr);<br>​    Ptr = NULL;<br>​    // code…<br>  就是这样！当然，具体情况要具体分析以及具体解决。比如说，你定义了一个指针，在一个函数里申请了一块内存然后通过函数返回传递给这个指针，那么也许释放这块内存这项工作就应该留给其他函数了。</p><p>3、关于函数使用需要注意的一些地方：</p><p>A、申请了内存空间后，必须检查是否分配成功。</p><p>B、当不需要再使用申请的内存时，记得释放；释放后应该把指向这块内存的指针指向NULL，防止程序后面不小心使用了它。</p><p>C、这两个函数应该是配对。如果申请后不释放就是内存泄露；如果无故释放那就是什么也没有做。释放只能一次，如果释放两次及两次以上会</p><p>出现错误（释放空指针例外，释放空指针其实也等于啥也没做，所以释放空指针释放多少次都没有问题）。</p><p>D、虽然malloc()函数的类型是(void *),任何类型的指针都可以转换成(void *),但是最好还是在前面进行强制类型转换，因为这样可以躲过一</p><p>些编译器的检查。</p><p>好了！最基础的东西大概这么说！现在进入第二部分：</p><p>二、malloc()到底从哪里得来了内存空间：</p><p>1、malloc()到底从哪里得到了内存空间？答案是从堆里面获得空间。也就是说函数返回的指针是指向堆里面的一块内存。操作系统中有一个记录空闲内存地址的链表。当操作系统收到程序的申请时，就会遍历该链表，然后就寻找第一个空间大于所申请空间的堆结点，然后就将该结点从空闲结点链表中删除，并将该结点的空间分配给程序。就是这样！</p><p>  说到这里，不得不另外插入一个小话题，相信大家也知道是什么话题了。什么是堆？说到堆，又忍不住说到了栈！什么是栈？下面就另外开个小部分专门而又简单地说一下这个题外话：</p><p>2、什么是堆：堆是大家共有的空间，分全局堆和局部堆。全局堆就是所有没有分配的空间，局部堆就是用户分配的空间。堆在操作系统对进程 初始化的时候分配，运行过程中也可以向系统要额外的堆，但是记得用完了要还给操作系统，要不然就是内存泄漏。</p><p>  什么是栈：栈是线程独有的，保存其运行状态和局部自动变量的。栈在线程开始的时候初始化，每个线程的栈互相独立。每个函数都有自己的栈，栈被用来在函数之间传递参数。操作系统在切换线程的时候会自动的切换栈，就是切换SS/ESP寄存器。栈空间不需要在高级语言里面显式的分配和释放。 </p><p>  以上的概念描述是标准的描述，不过有个别语句被我删除，不知道因为这样而变得不标准了^_^.</p><p>  通过上面对概念的描述，可以知道：</p><p>  栈是由编译器自动分配释放，存放函数的参数值、局部变量的值等。操作方式类似于数据结构中的栈。</p><p>  堆一般由程序员分配释放，若不释放，程序结束时可能由OS回收。注意这里说是可能，并非一定。所以我想再强调一次，记得要释放！</p><p>注意它与数据结构中的堆是两回事，分配方式倒是类似于链表。（这点我上面稍微提过）</p><p> 所以，举个例子，如果你在函数上面定义了一个指针变量，然后在这个函数里申请了一块内存让指针指向它。实际上，这个指针的地址是在栈上，但是它所指向的内容却是在堆上面的！这一点要注意！所以，再想想，在一个函数里申请了空间后，比如说下面这个函数：</p><p>程序代码：<br>  // code…<br>    void Function(void)<br>    {<br>    char *p = (char *)malloc(100 * sizeof(char));<br>  }</p><p>  就这个例子，千万不要认为函数返回，函数所在的栈被销毁指针也跟着销毁，申请的内存也就一样跟着销毁了！这绝对是错误的！因为申请的内存在堆上，而函数所在的栈被销毁跟堆完全没有啥关系。所以，还是那句话：记得释放！</p><p>3、free()到底释放了什么</p><p>  这个问题比较简单，其实我是想和第二大部分的题目相呼应而已！哈哈！free()释放的是指针指向的内存！注意！释放的是内存，不是指针！这点非常非常重要！指针是一个变量，只有程序结束时才被销毁。释放了内存空间后，原来指向这块空间的指针还是存在！只不过现在指针指向的内容的垃圾，是未定义的，所以说是垃圾。因此，前面我已经说过了，释放内存后把指针指向NULL，防止指针在后面不小心又被解引用了。非常重要啊这一点！</p><p>  好了！这个“题外话”终于说完了。就这么简单说一次，知道个大概就可以了！下面就进入第三个部分：</p><p>三、malloc()以及free()的机制：</p><p>  这个部分我今天才有了新的认识！而且是转折性的认识！所以，这部分可能会有更多一些认识上的错误！不对的地方请大家帮忙指出！</p><p>  事实上，仔细看一下free()的函数原型，也许也会发现似乎很神奇，free()函数非常简单，只有一个参数，只要把指向申请空间的指针传递</p><p>给free()中的参数就可以完成释放工作！这里要追踪到malloc()的申请问题了。申请的时候实际上占用的内存要比申请的大。因为超出的空间是用来记录对这块内存的管理信息。先看一下在《UNIX环境高级编程》中第七章的一段话：</p><p>  大多数实现所分配的存储空间比所要求的要稍大一些，额外的空间用来记录管理信息——分配块的长度，指向下一个分配块的指针等等。这就意味着如果写过一个已分配区的尾端，则会改写后一块的管理信息。这种类型的错误是灾难性的，但是因为这种错误不会很快就暴露出来，所以也就很难发现。将指向分配块的指针向后移动也可能会改写本块的管理信息。</p><p>  以上这段话已经给了我们一些信息了。malloc()申请的空间实际我觉得就是分了两个不同性质的空间。一个就是用来记录管理信息的空间，另外一个就是可用空间了。而用来记录管理信息的实际上是一个结构体。在C语言中，用结构体来记录同一个对象的不同信息是</p><p>天经地义的事！下面看看这个结构体的原型：</p><p>程序代码：<br>  struct mem_control_block {<br>  int is_available;  //这是一个标记？<br>  int size;      //这是实际空间的大小<br>  };</p><p>  对于size,这个是实际空间大小。这里其实我有个疑问，is_available是否是一个标记？因为我看了free()的源代码之后对这个变量感觉有点纳闷（源代码在下面分析）。这里还请大家指出！</p><p>  所以，free()就是根据这个结构体的信息来释放malloc()申请的空间！而结构体的两个成员的大小我想应该是操作系统的事了。但是这里有一个问题，malloc()申请空间后返回一个指针应该是指向第二种空间，也就是可用空间！不然，如果指向管理信息空间的话，写入的内容和结构体的类型有可能不一致，或者会把管理信息屏蔽掉，那就没法释放内存空间了，所以会发生错误！（感觉自己这里说的是废话）</p><p>  好了！下面看看free()的源代码，我自己分析了一下，觉得比起malloc()的源代码倒是容易简单很多。只是有个疑问，下面指出！</p><p>程序代码：<br>  // code… </p><pre><code>void free(void *ptr) </code></pre><p>  {<br>      struct mem_control_block *free;<br>      free = ptr - sizeof(struct mem_control_block);<br>      free-&gt;is_available = 1;<br>      return;<br>  }<br>  看一下函数第二句，这句非常重要和关键。其实这句就是把指向可用空间的指针倒回去，让它指向管理信息的那块空间，因为这里是在值上减去了一个结构体的大小！后面那一句free-&gt;is_available = 1;我有点纳闷！我的想法是：这里is_available应该只是一个标记而已！因为从这个变量的名称上来看，is_available 翻译过来就是“是可以用”。不要说我土！我觉得变量名字可以反映一个变量的作用，特别是严谨的代码。这是源代码，所以我觉得绝对是严谨的！！这个变量的值是1，表明是可以用的空间！只是这里我想了想，如果把它改为0或者是其他值不知道会发生什么事？！但是有一点我可以肯定，就是释放绝对不会那么顺利进行！因为这是一个标记！</p><p>  当然，这里可能还是有人会有疑问，为什么这样就可以释放呢？？我刚才也有这个疑问。后来我想到，释放是操作系统的事，那么就free()这个源代码来看，什么也没有释放，对吧？但是它确实是确定了管理信息的那块内存的内容。所以，free()只是记录了一些信息，然后告诉操作系统那块内存可以去释放，具体怎么告诉操作系统的我不清楚，但我觉得这个已经超出了我这篇文章的讨论范围了。</p><p>  那么，我之前有个错误的认识，就是认为指向那块内存的指针不管移到那块内存中的哪个位置都可以释放那块内存！但是，这是大错特错！释放是不可以释放一部分的！首先这点应该要明白。而且，从free()的源代码看，ptr只能指向可用空间的首地址，不然，减去结构体大小之后一定不是指向管理信息空间的首地址。所以，要确保指针指向可用空间的首地址！不信吗？自己可以写一个程序然后移动指向可用空间的指针，看程序会有会崩！</p><p>  最后可能想到malloc()的源代码看看malloc()到底是怎么分配空间的，这里面涉及到很多其他方面的知识！有兴趣的朋友可以自己去下载源<br>代码去看看。</p><p>四、关于其他：</p><p>  关于C中的malloc()和free()的讨论就写到这里吧！写了三个钟头，感觉有点累！希望对大家有所帮助！有不对的地方欢迎大家指出！最后<br>，谢谢参与这个帖子讨论的所有朋友，帖子：<a href="http://www.bc-cn.net/bbs/dispbbs.asp?boardID=5&amp;ID=81781&amp;page=1%E3%80%82%E4%B9%9F%E8%B0%88%E5%88%B0%E7%89%88%E6%9D%83%E9%97%AE%E9%A2%98%EF%BC%8C%E5%A6%82%E6%9E%9C%E5%93%AA%E4%BD%8D%E6%83%B3%E8%BD%AC%E8%BD%BD%E8%BF%99%E7%AF%87%E6%96%87%E7%AB%A0%EF%BC%88%E5%A6%82%E6%9E%9C%E6%88%91%E6%9C%89%E8%BF%99%E4%B8%AA%E8%8D%A3%E5%B9%B8%E7%9A%84%E8%AF%9D%EF%BC%89%EF%BC%8C%E6%9C%80%E8%B5%B7%E7%A0%81%E8%AF%B7%E6%A0%87%E6%98%8E%E2%80%9C%E6%9D%A5%E8%87%AAbc-cn">http://www.bc-cn.net/bbs/dispbbs.asp?boardID=5&amp;ID=81781&amp;page=1。也谈到版权问题，如果哪位想转载这篇文章（如果我有这个荣幸的话），最起码请标明“来自bc-cn</a> C语言论坛”这几个字眼，我的ID可以不用写上！谢谢合作！</p><p>五、参考文献：（只写书名）</p><p>——《UNIX环境高级编程》</p><p>——《计算机组成原理》</p><p>——《高质量C/C++编程指南》 </p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;http://bbs.byr.cn/pc/pccon.php?id=315&amp;amp;nid=68136&quot;&gt;http://bbs.byr.cn/pc/pccon.php?id=315&amp;amp;nid=68136&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;版权说明：转自bc-cn</summary>
      
    
    
    
    <category term="编程语言" scheme="https://hxlpub.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
    <category term="c" scheme="https://hxlpub.github.io/tags/c/"/>
    
  </entry>
  
  <entry>
    <title>【DAOS】dfs</title>
    <link href="https://hxlpub.github.io/2022/05/14/daos/"/>
    <id>https://hxlpub.github.io/2022/05/14/daos/</id>
    <published>2022-05-14T04:10:07.000Z</published>
    <updated>2023-05-28T11:15:13.763Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.intel.com/content/www/us/en/developer/articles/training/introduction-to-dfs.html">https://www.intel.com/content/www/us/en/developer/articles/training/introduction-to-dfs.html</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://www.intel.com/content/www/us/en/developer/articles/training/introduction-to-dfs.html&quot;&gt;https://www.intel.com/content/www/</summary>
      
    
    
    
    <category term="分布式存储" scheme="https://hxlpub.github.io/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8/"/>
    
    
    <category term="daos" scheme="https://hxlpub.github.io/tags/daos/"/>
    
  </entry>
  
  <entry>
    <title>【git】problems shooting</title>
    <link href="https://hxlpub.github.io/2022/05/10/git-problemsshooting/"/>
    <id>https://hxlpub.github.io/2022/05/10/git-problemsshooting/</id>
    <published>2022-05-10T14:19:51.000Z</published>
    <updated>2023-05-28T11:20:39.417Z</updated>
    
    <content type="html"><![CDATA[<h5 id="Failed-to-connect-to-github-com-port-443-connection-timed-out"><a href="#Failed-to-connect-to-github-com-port-443-connection-timed-out" class="headerlink" title="Failed to connect to github.com port 443:connection timed out"></a>Failed to connect to github.com port 443:connection timed out</h5><p>解决方法：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global --unset http.proxy &amp;&amp; git config --global --unset https.proxy</span><br></pre></td></tr></table></figure><h5 id="curl-56-OpenSSL-SSL-read-Connection-reset-by-peer-errno-104"><a href="#curl-56-OpenSSL-SSL-read-Connection-reset-by-peer-errno-104" class="headerlink" title="curl: (56) OpenSSL SSL_read: Connection reset by peer, errno 104"></a>curl: (56) OpenSSL SSL_read: Connection reset by peer, errno 104</h5><p>解决方法：</p><p>Running commands in /opt/daos/build/external/release/spdk<br>RUN: git submodule init<br>Submodule ‘dpdk’ (<a href="https://github.com/spdk/dpdk.git">https://github.com/spdk/dpdk.git</a>) registered for path ‘dpdk’<br>Submodule ‘intel-ipsec-mb’ (<a href="https://github.com/spdk/intel-ipsec-mb.git">https://github.com/spdk/intel-ipsec-mb.git</a>) registered for path ‘intel-ipsec-mb’<br>Submodule ‘isa-l’ (<a href="https://github.com/spdk/isa-l.git">https://github.com/spdk/isa-l.git</a>) registered for path ‘isa-l’<br>Submodule ‘libvfio-user’ (<a href="https://github.com/nutanix/libvfio-user.git">https://github.com/nutanix/libvfio-user.git</a>) registered for path ‘libvfio-user’<br>Submodule ‘ocf’ (<a href="https://github.com/Open-CAS/ocf.git">https://github.com/Open-CAS/ocf.git</a>) registered for path ‘ocf’<br>RUN: git submodule update<br>Cloning into ‘/opt/daos/build/external/release/spdk/dpdk’…<br>fatal: unable to access ‘<a href="https://github.com/spdk/dpdk.git/&#39;">https://github.com/spdk/dpdk.git/&#39;</a>: OpenSSL SSL_read: Connection reset by peer, errno 104<br>fatal: clone of ‘<a href="https://github.com/spdk/dpdk.git&#39;">https://github.com/spdk/dpdk.git&#39;</a> into submodule path ‘/opt/daos/build/external/release/spdk/dpdk’ failed<br>Failed to clone ‘dpdk’. Retry scheduled<br>Cloning into ‘/opt/daos/build/external/release/spdk/intel-ipsec-mb’…<br>Cloning into ‘/opt/daos/build/external/release/spdk/isa-l’…<br>Cloning into ‘/opt/daos/build/external/release/spdk/libvfio-user’…<br>fatal: unable to access ‘<a href="https://github.com/nutanix/libvfio-user.git/&#39;">https://github.com/nutanix/libvfio-user.git/&#39;</a>: OpenSSL SSL_read: Connection reset by peer, errno 104<br>fatal: clone of ‘<a href="https://github.com/nutanix/libvfio-user.git&#39;">https://github.com/nutanix/libvfio-user.git&#39;</a> into submodule path ‘/opt/daos/build/external/release/spdk/libvfio-user’ failed<br>Failed to clone ‘libvfio-user’. Retry scheduled<br>Cloning into ‘/opt/daos/build/external/release/spdk/ocf’…<br>fatal: unable to access ‘<a href="https://github.com/Open-CAS/ocf.git/&#39;">https://github.com/Open-CAS/ocf.git/&#39;</a>: Failed to connect to github.com port 443: Connection refused<br>fatal: clone of ‘<a href="https://github.com/Open-CAS/ocf.git&#39;">https://github.com/Open-CAS/ocf.git&#39;</a> into submodule path ‘/opt/daos/build/external/release/spdk/ocf’ failed<br>Failed to clone ‘ocf’. Retry scheduled<br>Cloning into ‘/opt/daos/build/external/release/spdk/dpdk’…<br>fatal: unable to access ‘<a href="https://github.com/spdk/dpdk.git/&#39;">https://github.com/spdk/dpdk.git/&#39;</a>: Failed to connect to github.com port 443: Connection refused<br>fatal: clone of ‘<a href="https://github.com/spdk/dpdk.git&#39;">https://github.com/spdk/dpdk.git&#39;</a> into submodule path ‘/opt/daos/build/external/release/spdk/dpdk’ failed<br>Failed to clone ‘dpdk’ a second time, aborting<br>DownloadFailure: Failed to get /opt/daos/build/external/release/spdk from <a href="https://github.com/spdk/spdk.git">https://github.com/spdk/spdk.git</a>:</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h5 id=&quot;Failed-to-connect-to-github-com-port-443-connection-timed-out&quot;&gt;&lt;a href=&quot;#Failed-to-connect-to-github-com-port-443-connection-timed-o</summary>
      
    
    
    
    <category term="代码管理工具" scheme="https://hxlpub.github.io/categories/%E4%BB%A3%E7%A0%81%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/"/>
    
    
    <category term="git" scheme="https://hxlpub.github.io/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>【typora】typora激活</title>
    <link href="https://hxlpub.github.io/2022/04/30/typora-activate/"/>
    <id>https://hxlpub.github.io/2022/04/30/typora-activate/</id>
    <published>2022-04-30T11:15:26.000Z</published>
    <updated>2023-05-28T11:36:37.209Z</updated>
    
    <content type="html"><![CDATA[<p>链接：<a href="https://pan.baidu.com/s/19QqJXAf9dTIYDe_kJ4P0fA">https://pan.baidu.com/s/19QqJXAf9dTIYDe_kJ4P0fA</a><br>提取码：nfl7</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;链接：&lt;a href=&quot;https://pan.baidu.com/s/19QqJXAf9dTIYDe_kJ4P0fA&quot;&gt;https://pan.baidu.com/s/19QqJXAf9dTIYDe_kJ4P0fA&lt;/a&gt;&lt;br&gt;提取码：nfl7&lt;/p&gt;
</summary>
      
    
    
    
    <category term="工具" scheme="https://hxlpub.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
    <category term="typora" scheme="https://hxlpub.github.io/tags/typora/"/>
    
  </entry>
  
  <entry>
    <title>【数据结构与算法】表栈队列</title>
    <link href="https://hxlpub.github.io/2022/04/28/datastructures_tutorial/"/>
    <id>https://hxlpub.github.io/2022/04/28/datastructures_tutorial/</id>
    <published>2022-04-28T12:11:08.000Z</published>
    <updated>2023-05-28T11:18:04.123Z</updated>
    
    <content type="html"><![CDATA[<p>参考</p><p>本文参考自《数据结构与算法分析C++描述》第三版，作者Mark Allen Weiss</p><h5 id="1-表"><a href="#1-表" class="headerlink" title="1.表"></a>1.表</h5><p>1)链表可以解决什么问题？其一般思想是？</p><ul><li><p>表的数组实现带来的问题</p><p>数组实现printList线性时间，findKth 常数时间，但插入和删除操作在整个表中发生时，时间开销最坏的情况是线性的O(N)，数组就不合适。</p></li><li><p>链表一般思想</p><p>为避免插入和删除带来的线性开销，允许表可以不连续存储，否则表的部分或全部都要整体移动。</p><p>下图表示了链表的一般性思想：</p><p><img src="https://github.com/hxlpub/imgs/blob/master/image_20220502111042397.png?raw=true" alt="一个链表"></p><p>以及插入和删除方法的一般性思想：</p><p><img src="https://github.com/hxlpub/imgs/blob/master/insert_node.png?raw=true" alt="insert a node"></p><p><img src="https://github.com/hxlpub/imgs/blob/master/remove_node.png?raw=true" alt="rm a node"></p><p>当删除最后一项时，需要找到最后一项前面的项，才能去更新其next 链接到NULL，需要O(N),如果双向链表则只需要O(1)</p><p><img src="https://github.com/hxlpub/imgs/blob/master/double__linkednode.png?raw=true" alt="double linked nodes"></p><p>​            </p></li></ul><h5 id="2-栈"><a href="#2-栈" class="headerlink" title="2.栈"></a>2.栈</h5><h5 id="3-队列"><a href="#3-队列" class="headerlink" title="3.队列"></a>3.队列</h5>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;参考&lt;/p&gt;
&lt;p&gt;本文参考自《数据结构与算法分析C++描述》第三版，作者Mark Allen Weiss&lt;/p&gt;
&lt;h5 id=&quot;1-表&quot;&gt;&lt;a href=&quot;#1-表&quot; class=&quot;headerlink&quot; title=&quot;1.表&quot;&gt;&lt;/a&gt;1.表&lt;/h5&gt;&lt;p&gt;1)链表可</summary>
      
    
    
    
    <category term="数据结构与算法" scheme="https://hxlpub.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="数据结构与算法" scheme="https://hxlpub.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>【c】搭建c知识体系：Basics</title>
    <link href="https://hxlpub.github.io/2022/04/23/c_new/"/>
    <id>https://hxlpub.github.io/2022/04/23/c_new/</id>
    <published>2022-04-23T10:12:50.000Z</published>
    <updated>2023-05-28T11:11:52.930Z</updated>
    
    <content type="html"><![CDATA[<p>1.本篇目的：搭建并完善C知识体系</p><p>2.本篇的结构</p><ul><li>第一部分：基础点</li><li>第二部分：调试技巧</li></ul><hr><p>第一部分：基础点</p><ul><li><p>预处理器</p><ul><li><p>#include指令：文件包含，该指令所在的行都将被替换为由文件名指定的文件的内容，一种将所有声明捆绑在一起的较好的办法，保证所有的源文件有相同的定义与变量声明</p><p> #include “文件” ：先在源文件所在位置查找该文件，如果在该位置未找到，再根据相应规则查找</p><p> #include &lt;文件&gt; ：根据相应规则查找</p></li><li><p>#define指令：宏替换，#define 名字 替换文本</p></li><li><p>宏<br>：将函数定义为宏可避免调用函数时所需的运行时开销</p></li></ul></li><li><p>变量存储类别</p><table><thead><tr><th>静态存储方式</th><th>程序运行期间分配固定的存储空间的方式。静态存储区中存放了在整个程序执行过程中都存在的变量，如全局变量。</th></tr></thead><tbody><tr><td>动态存储方式</td><td>指在程序运行期间根据需要进行动态的分配存储空间的方式。动态存储区中存放的变量是根据程序运行的需要而建立和释放的，通常包括：函数形式参数；自动变量；函数调用时的现场保护和返回地址等。</td></tr></tbody></table><table><thead><tr><th>类型</th><th>作用域</th><th>存储位置</th><th>生命周期</th><th>特点</th><th>实例</th></tr></thead><tbody><tr><td>static静态变量</td><td>所在文件（static 外部变量）、 所在函数（static 局部变量）</td><td>定义后一直占据存储空间</td><td>程序运行期间</td><td>只被初始化一次（程序执行前，编译时），初始化表达式是常量表达式，没有初始化表达式的元素被初始化为0或空字符</td><td></td></tr><tr><td>register</td><td>局部变量 、函数形参（局部静态变量不能定义为寄存器变量）</td><td>寄存器</td><td></td><td>程序更小，执行速度更快</td><td></td></tr><tr><td>外部变量external</td><td>外部变量的意义是某函数可以调用在该函数之后定义的变量。</td><td></td><td></td><td>只被初始化一次（程序执行前），初始化表达式必须是常量表达式，没有初始化表达式的元素被初始化为0;</td><td>#includ &lt;stdio.h&gt;  int main() {     //定义外部局部变量     extern int x;     return 0; } int x=100;</td></tr><tr><td>自动变量auto</td><td>函数内部</td><td></td><td>函数被调用期间</td><td>每次进入函数或程序块都初始化，没有初始化表达式的元素被初始化为0</td><td></td></tr></tbody></table></li><li><p>函数</p><table><thead><tr><th>函数</th><th>形式</th><th>说明</th></tr></thead><tbody><tr><td>内部函数（静态函数）</td><td>static [数据类型] 函数名（[参数]）</td><td>不能被其他源文件调用的函数称为内部函数 ，static是对函数的作用范围的一个限定，限定该函数只能在其所处的源文件中使用，因此在不同文件中出现相同的函数名称的内部函数是没有问题的。</td></tr><tr><td>外部函数</td><td>extern [数据类型] 函数名([参数])</td><td>能被其他源文件调用的函数称为外部函数，C语言规定，在没有指定函数的作用范围时，系统会默认认为是外部函数，因此当需要定义外部函数时extern也可以省略。 extern可以省略;</td></tr></tbody></table></li><li><p>指针</p><p> 运算符&amp;：取地址，只能应用于内存中对象，即变量与数组元素，不能作用与表达式、常量、或register变量<br> ​ 运算符<em>：间接寻址或间接引用运算符，作用于指针时，将访问指针所指向的对象。<br> ​ &amp;、</em>优先级高于算术运算符<br> ​ 指针变量可以相互赋值，指向相同的对象</p><ul><li>1）指针与数组 ：</li></ul><p>  一般，指针编写的程序比用数组下标编写的程序执行速度快<br> ​ 一个通过数组和下标实现的表达式可等价地通过指针和偏移量实现</p><p>  char s[] == char *s 、&amp;a[2] == a+2 （a数组）</p><ul><li><p>2）特性</p><ul><li>某些情况下对指针进行比较运算（如指针p、q指向同一个数组的成员）</li><li>指针可以和整数相加或相减</li><li>指针的算术运算具有一致性：所有的指针运算都会自动考虑它所指向的对象的长度</li><li>有效的指针运算：<ul><li>相同类型指针之间赋值运算</li><li>指针同整数之间的加法减法</li><li>指向相同数组中元素的两个指针间的减法和比较运算</li><li>指针赋值为0或指针与0之间的比较运算</li></ul></li></ul></li><li><p>3）指针数组、指针的指针</p><ul><li>如char *lineptr[10]<ul><li>初始化：如，static char *name[] = {“xiaoming”,”xiaoqiang”}</li></ul></li><li>指针数组优点：数组的每一个元素的长度可以不同</li></ul></li><li><p>4)函数指针</p><p>K&amp;R P99</p></li></ul></li><li><p>运算符优先级</p><p> 1）优先级1：数组下标[]<strong>，</strong>圆括号( )<strong>，</strong>成员选择（对象）.，成员选择（指针）-&gt;</p><p> 结合方向为左到右</p><p> <img src="https://github.com/hxlpub/imgs/blob/master/%E4%BC%98%E5%85%88%E7%BA%A71.jpg?raw=true&ynotemdtimestamp=1650186921046" alt="优先级1"></p><p> 2）优先级2：负号运算符-，强制类型转换，自增运算符++，自减运算符–，取值运算符，取地址运算符&amp;，逻辑非运算符！，按位取反运算符~，长度运算sizeof符，结合方向为右到左</p><p> <img src="https://github.com/hxlpub/imgs/blob/master/%E4%BC%98%E5%85%88%E7%BA%A72.jpg?raw=true&ynotemdtimestamp=1650186921046" alt="优先级2"></p><p> 3）优先级3：除/，乘*，余数%，结合方向为左到右</p><p> <img src="https://github.com/hxlpub/imgs/blob/master/%E4%BC%98%E5%85%88%E7%BA%A73.jpg?raw=true&ynotemdtimestamp=1650186921046" alt="优先级3"></p><p> 4）优先级4：加+，减-，结合方向为左到右</p><p> <img src="https://github.com/hxlpub/imgs/blob/master/%E4%BC%98%E5%85%88%E7%BA%A74.jpg?raw=true&ynotemdtimestamp=1650186921046" alt="优先级4"></p><p> 5）优先级5：左移&lt;&lt;，右移&gt;&gt;，结合方向为左到右</p><p> <img src="https://github.com/hxlpub/imgs/blob/master/%E4%BC%98%E5%85%88%E7%BA%A75.jpg?raw=true&ynotemdtimestamp=1650186921046" alt="优先级5"></p><p> 6）优先级6：大于&gt;，大于等于&gt;=，小于&lt;，小于等于&lt;=，结合方向为左到右</p><p> <img src="https://github.com/hxlpub/imgs/blob/master/%E4%BC%98%E5%85%88%E7%BA%A76.jpg?raw=true&ynotemdtimestamp=1650186921046" alt="优先级6"></p><p> 7）优先级7：等于==，不等于!=，结合方向为左到右</p><p> <img src="https://github.com/hxlpub/imgs/blob/master/%E4%BC%98%E5%85%88%E7%BA%A77.jpg?raw=true&ynotemdtimestamp=1650186921046" alt="优先级7"></p><p> 8）优先级8：级别先后为，按位与&amp;，按位异或^，按位或| ，逻辑与&amp;&amp;，逻辑或|| 条件运算符?:，注意得是条件运算结合方向为右到左</p><p> <img src="https://github.com/hxlpub/imgs/blob/master/%E4%BC%98%E5%85%88%E7%BA%A78.jpg?raw=true&ynotemdtimestamp=1650186921046" alt="优先级8"></p><p> 9）优先级9：赋值运算符=，除后赋值/=，乘后赋值*=，取模后赋值%=，加后赋值+=，减后赋值-=，左移后赋值&lt;&lt;=，右移后赋值&gt;&gt;=，按位与后赋值&amp;=，按位异或后赋值^=，按位或后赋值|=，结合方向为右到左</p><p> <img src="https://github.com/hxlpub/imgs/blob/master/%E4%BC%98%E5%85%88%E7%BA%A79.jpg?raw=true&ynotemdtimestamp=1650186921046" alt="优先级9"></p></li><li><p>结构</p><p> struct point {</p><p>  int x;</p><p>  int y;</p><p> };</p><ul><li><p>声明：struct {int x,int y} x,y,z; #分配存储空间</p><p> struct point pt;</p></li></ul></li></ul><ul><li><p>初始化：</p><p> struct point maxpt = {320, 200};</p></li></ul><ul><li><p>成员：maxpt.x</p><p> maxpt.y</p></li></ul><ul><li><p>嵌套：</p><p> struct rect {</p><p> struct point pt1;</p><p> struct point pt2;</p><p> };</p><p> struct rect screen;</p><ul><li> 成员： screen.pt1.x</li></ul></li></ul><ul><li><p>合法操作：</p><p> 1.作为一个整体赋值和赋值</p><p> 2.通过&amp;取地址</p><p> 3.访问其成员</p></li></ul><ul><li><p>结构指针：</p><p> struct point *ptrstr;</p><p> ptrstr -&gt; x</p></li><li><p>结构数组</p></li></ul>   <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">key</span> &#123;</span></span><br><span class="line"><span class="keyword">char</span> *word;</span><br><span class="line"><span class="keyword">int</span> count;</span><br><span class="line">&#125; keytab[] = &#123; </span><br><span class="line"> &#123; <span class="string">&quot;auto&quot;</span>, <span class="number">0</span> &#125;,</span><br><span class="line"> &#123; <span class="string">&quot;break&quot;</span>, <span class="number">0</span> &#125;,</span><br><span class="line"> &#123; <span class="string">&quot;case&quot;</span>, <span class="number">0</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><pre><code>&#125;；</code></pre><ul><li>结构指针</li></ul><ul><li> 关键字统计</li></ul><ul><li><p>自引用结构</p><p>K$R P116 ex:统计输入所有单词出现频次（二叉树）</p></li><li><p>表查找</p></li></ul><ul><li>类型定义（typedef）</li></ul><ul><li>联合</li></ul><ul><li>位字段</li></ul><ul><li><p>命令行参数</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[] )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        #./test -x 注意优先级顺序</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,argv[<span class="number">0</span>]);#./<span class="function">test</span></span><br><span class="line"><span class="function">        <span class="title">printf</span><span class="params">(<span class="string">&quot;%c\n&quot;</span>,(*++argv)[<span class="number">0</span>])</span></span>;#-  argv指向argv[<span class="number">1</span>]</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c\n&quot;</span>,*++argv[<span class="number">0</span>]);<span class="meta">#x,先与[]结合,所以依然指向argv[1]</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,argc);#<span class="number">2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>运算符集合</p></li><li><p>控制流语句</p></li><li><p>标准库</p><p>输入输出：printf (“%d”,i)、scanf(“%d”,&amp;i)</p><p>文件访问：</p><p>1.打开文件，返回文件指针</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">FILE *fp;</span><br><span class="line"><span class="function">FILE *<span class="title">fopen</span><span class="params">(<span class="keyword">char</span> *name,<span class="keyword">char</span> *mode)</span> </span></span><br><span class="line"><span class="function">fp </span>= fopen(name,mode)</span><br></pre></td></tr></table></figure></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2.</span>文件读写</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getc</span><span class="params">(FILE *fp)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">putc</span><span class="params">(FILE *fp)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="meta">#<span class="meta-keyword">define</span> getchar() getc(stdin)</span></span></span><br><span class="line"><span class="function"><span class="meta">#<span class="meta-keyword">define</span> putchar(c) putc((c), stdout)</span></span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fscanf</span><span class="params">(FILE *fp, <span class="keyword">char</span> *format, ...)</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fprintf</span><span class="params">(FILE *fp, <span class="keyword">char</span> *format, ...)</span></span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3.</span>关闭文件</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fclose</span> <span class="params">(FILE *fp)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">错误处理</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="built_in">stderr</span> 和<span class="built_in">exit</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">fprintf</span><span class="params">(<span class="built_in">stderr</span>, <span class="string">&quot;%s: can&#x27;t open %s\n&quot;</span>,prog, *argv)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ferror（FILE *fp）#若流fp中出错，则函数返回一个非<span class="number">0</span>值</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">feof</span><span class="params">(FILE *fp)</span> #如果指定的文件到达文件结尾，返回一个非0值</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">行输入行输出</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">fgets</span><span class="params">(<span class="keyword">char</span> *line, <span class="keyword">int</span> maxline, FILE *fp)</span> #读文件一行到line</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fputs</span><span class="params">(<span class="keyword">char</span> *line, FILE *fp)</span>#写line到文件</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">其他函数</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">![字符和字符串操作函数]<span class="params">(https:<span class="comment">//github.com/hxlpub/imgs/blob/master/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AD%97%E7%AC%A6%E7%B1%BB%E5%87%BD%E6%95%B0.png?raw=true&amp;ynotemdtimestamp=1650186921046)</span></span></span></span><br></pre></td></tr></table></figure><hr><p>第二部分：调试技巧</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#gdb 段错误</span></span><br><span class="line">gcc -o a -g a.c a.h</span><br><span class="line">gcc ./a</span><br><span class="line">r#运行</span><br><span class="line">bt#查看seg fault</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;1.本篇目的：搭建并完善C知识体系&lt;/p&gt;
&lt;p&gt;2.本篇的结构&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;第一部分：基础点&lt;/li&gt;
&lt;li&gt;第二部分：调试技巧&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;p&gt;第一部分：基础点&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;预处理器&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;</summary>
      
    
    
    
    <category term="编程语言" scheme="https://hxlpub.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
    <category term="c" scheme="https://hxlpub.github.io/tags/c/"/>
    
  </entry>
  
  <entry>
    <title>【刷题】</title>
    <link href="https://hxlpub.github.io/2022/04/16/1000codes/"/>
    <id>https://hxlpub.github.io/2022/04/16/1000codes/</id>
    <published>2022-04-16T12:42:24.000Z</published>
    <updated>2023-05-28T11:36:43.403Z</updated>
    
    <content type="html"><![CDATA[<!--c--><ol><li></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;!--c--&gt;

&lt;ol&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ol&gt;
</summary>
      
    
    
    
    <category term="刷题" scheme="https://hxlpub.github.io/categories/%E5%88%B7%E9%A2%98/"/>
    
    
    <category term="刷题" scheme="https://hxlpub.github.io/tags/%E5%88%B7%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>【编程语言】python常见问题</title>
    <link href="https://hxlpub.github.io/2022/04/06/python-common-problems/"/>
    <id>https://hxlpub.github.io/2022/04/06/python-common-problems/</id>
    <published>2022-04-06T07:44:09.000Z</published>
    <updated>2023-05-28T11:07:51.744Z</updated>
    
    <content type="html"><![CDATA[<ol><li><p>“ModuleNotFoundError: No module named ‘xxx’</p><p><a href="https://www.cnblogs.com/hi3254014978/p/15202910.html"></a></p></li><li></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;ol&gt;
&lt;li&gt;&lt;p&gt;“ModuleNotFoundError: No module named ‘xxx’&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/hi3254014978/p/15202910.html&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;</summary>
      
    
    
    
    
    <category term="python" scheme="https://hxlpub.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>【python】理解python的if__name</title>
    <link href="https://hxlpub.github.io/2022/04/03/ifname/"/>
    <id>https://hxlpub.github.io/2022/04/03/ifname/</id>
    <published>2022-04-03T10:16:20.000Z</published>
    <updated>2023-05-28T11:22:53.034Z</updated>
    
    <content type="html"><![CDATA[<p>1.<a href="https://www.zhihu.com/question/49136398">参考</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;1.&lt;a href=&quot;https://www.zhihu.com/question/49136398&quot;&gt;参考&lt;/a&gt;&lt;/p&gt;
</summary>
      
    
    
    
    <category term="编程语言" scheme="https://hxlpub.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
    <category term="python" scheme="https://hxlpub.github.io/tags/python/"/>
    
  </entry>
  
</feed>
